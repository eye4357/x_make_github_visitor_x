{
    "failures": [
        {
            "captured_at": "2025-10-31T02:53:43.722615+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 2.8051298999926075,
                "ended_at": "2025-10-31T02:53:43.722615+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "db602e95828154e4c20192d7beb007d0453c618584a7e426ebbab2abd8401e37",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T02:53:40.917108+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\main.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n6 files would be reformatted, 10 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:27:57.459385+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:53:43.151630+00:00\n@@ -12,11 +12,13 @@\n \n     def update_orientation(self, gravity, forward_axis):\n         self.gravity = gravity\n         self.forward_axis = features.normalize(forward_axis)\n         self.up_axis = features.normalize(tuple(-g for g in gravity))\n-        self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n+        self.lateral_axis = features.normalize(\n+            features.cross(self.up_axis, self.forward_axis)\n+        )\n \n     def classify(self, event):\n         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n \n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\t2025-10-31 02:27:57.463157+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\t2025-10-31 02:53:43.168422+00:00\n@@ -2,11 +2,21 @@\n \n from . import x_cls_features_imu_x as features\n \n \n class CalibrationResult:\n-    def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n+    def __init__(\n+        self,\n+        gravity,\n+        accel_noise,\n+        jerk_noise,\n+        omega_noise,\n+        forward_axis,\n+        accel_samples,\n+        jerk_samples,\n+        omega_samples,\n+    ):\n         self.gravity = gravity\n         self.accel_noise = accel_noise\n         self.jerk_noise = jerk_noise\n         self.omega_noise = omega_noise\n         self.forward_axis = forward_axis\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\t2025-10-31 02:53:40.820806+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\t2025-10-31 02:53:43.196783+00:00\n@@ -12,10 +12,11 @@\n \n \n if hasattr(time, \"sleep_ms\"):\n     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n else:  # pragma: no cover - CPython tooling\n+\n     def sleep_ms(ms: int) -> None:\n         time.sleep(ms / 1000.0)\n \n \n _DEFAULT_ADDR = 0x28\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\t2025-10-31 02:53:40.795012+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\t2025-10-31 02:53:43.246594+00:00\n@@ -72,15 +72,11 @@\n             if time.ticks_diff(ts_ms, self._last_event_ms) >= self.cfg[\"refractory_ms\"]:\n                 self._state = \"idle\"\n             else:\n                 return None\n \n-        trigger = (\n-            accel_mag >= a_thresh\n-            or jerk >= j_thresh\n-            or omega_mag >= o_thresh\n-        )\n+        trigger = accel_mag >= a_thresh or jerk >= j_thresh or omega_mag >= o_thresh\n \n         if self._state == \"idle\":\n             if trigger:\n                 self._candidate = {\n                     \"start_ms\": ts_ms,\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\t2025-10-31 02:53:40.813088+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\t2025-10-31 02:53:43.287811+00:00\n@@ -22,11 +22,13 @@\n class Display:\n     def __init__(self):\n         self.available = bool(st7789)\n         if not self.available:\n             return\n-        spi = SPI(1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19))\n+        spi = SPI(\n+            1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19)\n+        )\n         self._tft = st7789.ST7789(\n             spi,\n             135,\n             240,\n             reset=Pin(23, Pin.OUT),\n@@ -61,11 +63,13 @@\n         self._draw_text(font_big, 10, 10, f\"{int(counts):03d}\", _COLOR_GREEN)\n         self._draw_text(font_small, 140, 16, f\"{last_type.upper():>8}\", _COLOR_WHITE)\n         self._draw_text(font_small, 140, 40, f\"Conf {confidence:>4.2f}\", _COLOR_WHITE)\n         self._tft.fill_rect(0, 80, 240, 40, _COLOR_BLACK)\n         self._draw_text(font_small, 10, 86, f\"SPM {spm:>5.1f}\", _COLOR_YELLOW)\n-        self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n+        self._draw_text(\n+            font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW\n+        )\n \n     def show_status(self, message, success=True):\n         if not self.available:\n             return\n         color = _COLOR_GREEN if success else _COLOR_RED\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\main.py\t2025-10-31 02:53:40.801319+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\main.py\t2025-10-31 02:53:43.374862+00:00\n@@ -9,27 +9,30 @@\n \n \n if hasattr(time, \"sleep_ms\"):\n     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n else:  # pragma: no cover - CPython tooling\n+\n     def sleep_ms(ms):\n         time.sleep(ms / 1000.0)\n \n \n if hasattr(time, \"ticks_ms\"):\n     ticks_ms = time.ticks_ms  # type: ignore[attr-defined]\n     ticks_add = time.ticks_add  # type: ignore[attr-defined]\n     ticks_diff = time.ticks_diff  # type: ignore[attr-defined]\n else:  # pragma: no cover - CPython tooling\n+\n     def ticks_ms():\n         return int(time.time() * 1000)\n \n     def ticks_add(value, delta):\n         return value + delta\n \n     def ticks_diff(a, b):\n         return a - b\n+\n \n from lib import x_cls_cfg_x as cfg_mod\n from lib import x_cls_features_imu_x as features\n from lib.x_cls_calibrate_x import Calibrator\n from lib.x_cls_combo_segmenter_x import ComboSegmenter\n@@ -115,12 +118,20 @@\n \n     # Seed detector baselines with calibration samples\n     limit = len(calibrator.accel_samples)\n     for idx in range(limit):\n         accel = calibrator.accel_samples[idx]\n-        jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n-        omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n+        jerk = (\n+            calibrator.jerk_samples[idx]\n+            if idx < len(calibrator.jerk_samples)\n+            else jerk_noise\n+        )\n+        omega = (\n+            calibrator.omega_samples[idx]\n+            if idx < len(calibrator.omega_samples)\n+            else omega_noise\n+        )\n         detector.ingest_idle(accel, jerk, omega)\n \n     running = False\n     session_id = 0\n     log_timer = SimpleTimer(2000)\n@@ -151,11 +162,13 @@\n         dt_s = dt_ms / 1000.0 if dt_ms > 0 else sample_period / 1000.0\n         jerk = features.jerk(last_accel, linear, dt_s)\n         last_accel = linear\n \n         if not running:\n-            detector.ingest_idle(features.magnitude(linear), jerk, features.magnitude(gyro))\n+            detector.ingest_idle(\n+                features.magnitude(linear), jerk, features.magnitude(gyro)\n+            )\n \n         if start_button.pressed():\n             running = not running\n             if running:\n                 session_id += 1\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T02:53:40.917108+00:00\nduration: 2.805s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:27:57.459385+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:53:43.151630+00:00\n@@ -12,11 +12,13 @@\n \n     def update_orientation(self, gravity, forward_axis):\n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\n\u2026",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\n\u2026",
            "stdout_preview": "--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:27:57.459385+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:53:43.151630+00:00\n@@ -12,11 +12,13 @@\n \n     def update_orientation(self, gravity, forward_axis):\n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-31T0\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T02:53:44.844285+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_legatus_tactica_impetus_x",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 0.799476399901323,
                "ended_at": "2025-10-31T02:53:44.844285+00:00",
                "exit": 2,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "db602e95828154e4c20192d7beb007d0453c618584a7e426ebbab2abd8401e37",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T02:53:44.047707+00:00",
                "stderr": "Package 'x_legatus_tactica_impetus_x' cannot be type checked due to missing py.typed marker. See https://mypy.readthedocs.io/en/stable/installed_packages.html for more details\n",
                "stdout": "",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 2",
            "message": "mypy failed for x_legatus_tactica_impetus_x (exit 2)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T02:53:44.047707+00:00\nduration: 0.799s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\n<empty>\nstderr:\nPackage 'x_legatus_tactica_impetus_x' cannot be type checked due to missing py.typed marker. See https://mypy.readthedocs.io/en/stable/installed_packages.html for more details",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": "Package 'x_legatus_tactica_impetus_x' cannot be type checked due to missing py.typed marker. See https://mypy.readthedocs.io/en/stable/installed_packages.html for more details",
            "stdout_preview": null,
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_legatus_tactica_impetus_x (exit 2) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-erro\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        },
        {
            "captured_at": "2025-10-31T02:53:49.209310+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "pyright",
                    ".",
                    "--level",
                    "error"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 4.362078699981794,
                "ended_at": "2025-10-31T02:53:49.209310+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "db602e95828154e4c20192d7beb007d0453c618584a7e426ebbab2abd8401e37",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T02:53:44.850595+00:00",
                "stderr": "",
                "stdout": "c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:21 - error: \"ticks_add\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:36 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:43 - error: \"ticks_diff\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:69 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:37:14 - error: \"sleep_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:44:10 - error: \"sleep_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_comm_uart_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_comm_uart_x.py:22:17 - error: \"stdout\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_comm_uart_x.py:23:17 - error: \"stdout\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:27:15 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:27:68 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:27:82 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:28:28 - error: \"ST7789\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:32:19 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:32:31 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:33:16 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:33:28 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:34:16 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:34:27 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:37:9 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:37:20 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:90:20 - error: \"ticks_ms\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:92:31 - error: \"ticks_add\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:94:17 - error: \"ticks_diff\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:95:31 - error: \"ticks_add\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py:72:21 - error: \"ticks_diff\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py:105:58 - error: Argument of type \"complex | float\" cannot be assigned to parameter \"arg2\" of type \"SupportsRichComparisonT@max\" in function \"max\"\n  \u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderLT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__lt__\" is not present\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderGT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__gt__\" is not present (reportArgumentType)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py:106:58 - error: Argument of type \"complex | float\" cannot be assigned to parameter \"arg2\" of type \"SupportsRichComparisonT@max\" in function \"max\"\n  \u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderLT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__lt__\" is not present\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderGT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__gt__\" is not present (reportArgumentType)\n27 errors, 0 warnings, 0 informations\n",
                "tool": "pyright",
                "tool_module": "pyright",
                "tool_version": "pyright 1.1.407"
            },
            "exit": "exit 1",
            "message": "pyright failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error\nstarted_at: 2025-10-31T02:53:44.850595+00:00\nduration: 4.362s\ntool_version: pyright 1.1.407\nstdout:\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:21 - error: \"ticks_add\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:36 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:43 - error: \"ticks_diff\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:69 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n\u2026\nstderr:\n<empty>",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": null,
            "stdout_preview": "c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:21 - error: \"ticks_add\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:36 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:43 - error: \"ticks_diff\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:69 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n\u2026",
            "suggested_action": "Investigate",
            "summary": "pyright failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error started_at: 2025-10-31T02:53:44.850595+00:00 duration: 4.362s\u2026",
            "tool": "pyright",
            "tool_version": "pyright 1.1.407"
        },
        {
            "captured_at": "2025-10-31T02:53:43.994607+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 0.27179450006224215,
                "ended_at": "2025-10-31T02:53:43.994607+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "db602e95828154e4c20192d7beb007d0453c618584a7e426ebbab2abd8401e37",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T02:53:43.731010+00:00",
                "stderr": "",
                "stdout": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:9:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:10:27\n   |\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |                           ^^^^^^^^^^^^^^\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:12:21\n   |\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:13:21\n   |\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:14:18\n   |\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n15 |\n16 | SAFE_MODE_PIN = 0  # Button B (GPIO0) used to skip Wi-Fi when held\n   |\n\nPLC0415 `import` should be at the top-level of a file\n  --> firmware\\boot.py:24:9\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:24:45\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |                                             ^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:25:12\n   |\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n25 |     except Exception:  # secrets missing; stay offline\n   |            ^^^^^^^^^\n26 |         return\n   |\n\nFBT003 Boolean positional value in function call\n  --> firmware\\boot.py:30:21\n   |\n28 |     wlan = network.WLAN(network.STA_IF)\n29 |     if not wlan.active():\n30 |         wlan.active(True)\n   |                     ^^^^\n31 |     if wlan.isconnected():\n32 |         return\n   |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n  --> firmware\\boot.py:49:5\n   |\n48 |   if machine is not None:\n49 | /     try:\n50 | |         machine.freq(240_000_000)\n51 | |     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\boot.py:51:5\n   |\n49 |       try:\n50 |           machine.freq(240_000_000)\n51 | /     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:51:12\n   |\n49 |     try:\n50 |         machine.freq(240_000_000)\n51 |     except Exception:\n   |            ^^^^^^^^^\n52 |         pass\n   |\n\nPLR0913 Too many arguments in function definition (8 > 5)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:24\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                        ^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:33\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                 ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:46\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                              ^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:58\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                          ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `forward_axis`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:71\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                       ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:85\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                     ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nE501 Line too long (128 > 88)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:89\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:100\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                    ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:114\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                                  ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:9\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |         ^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `sample_target`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:24\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |                        ^^^^^^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\n\nANN201 Missing return type annotation for public function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:9\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |         ^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:19\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                   ^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:26\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                          ^^^^^^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:40\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                        ^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:49\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                                 ^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:53:38\n   |\n51 |         self._jerk_stats.add(jerk)\n52 |         self._omega_stats.add(omega_mag)\n53 |         if len(self.accel_samples) < 512:\n   |                                      ^^^\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:55:37\n   |\n53 |         if len(self.accel_samples) < 512:\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |                                     ^^^\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:57:38\n   |\n55 |         if len(self.jerk_samples) < 512:\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |                                      ^^^\n58 |             self.omega_samples.append(omega_mag)\n   |\n\nANN201 Missing return type annotation for public function `done`\n  --> firmware\\lib\\x_cls_calibrate_x.py:60:9\n   |\n58 |             self.omega_samples.append(omega_mag)\n59 |\n60 |     def done(self):\n   |         ^^^^\n61 |         return self._count >= self._target\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `result`\n  --> firmware\\lib\\x_cls_calibrate_x.py:63:9\n   |\n61 |         return self._count >= self._target\n62 |\n63 |     def result(self):\n   |         ^^^^^^\n64 |         if self._count == 0:\n65 |             return None\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:85:9\n   |\n84 | class _RunningStats:\n85 |     def __init__(self):\n   |         ^^^^^^^^\n86 |         self.count = 0\n87 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:9\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |         ^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:19\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |                   ^^^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_calibrate_x.py:96:9\n   |\n94 |         self.ssq += delta * (value - self.mean)\n95 |\n96 |     def std(self):\n   |         ^^^\n97 |         if self.count < 2:\n98 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:97:25\n   |\n96 |     def std(self):\n97 |         if self.count < 2:\n   |                         ^\n98 |             return 0.0\n99 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_cfg_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_cfg_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover - CPython tooling\n11 |     import os\n   |\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:38:14\n   |\n36 |     cfg = DEFAULT_CFG.copy()\n37 |     try:\n38 |         with open(_CFG_PATH) as handle:\n   |              ^^^^\n39 |             user_cfg = json.load(handle)\n40 |         if isinstance(user_cfg, dict):\n   |\nhelp: Replace with `Path.open()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:52:14\n   |\n50 |     try:\n51 |         tmp_path = _CFG_PATH + \".tmp\"\n52 |         with open(tmp_path, \"w\") as handle:\n   |              ^^^^\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |\nhelp: Replace with `Path.open()`\n\nPTH104 `os.rename()` should be replaced by `Path.rename()`\n  --> firmware\\lib\\x_cls_cfg_x.py:54:9\n   |\n52 |         with open(tmp_path, \"w\") as handle:\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |         ^^^^^^^^^\n55 |     except OSError:\n56 |         pass\n   |\nhelp: Replace with `Path(...).rename(...)`\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:9\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |         ^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `combo_gap_ms`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:24\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |                        ^^^^^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:9:9\n   |\n 7 |         self.reset()\n 8 |\n 9 |     def reset(self):\n   |         ^^^^^\n10 |         self._current_combo_id = 0\n11 |         self._last_ts = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `assign`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:9\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |         ^^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:22\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |                      ^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_comm_uart_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_comm_uart_x.py:11:17\n   |\n 9 |     import sys\n10 | except ImportError:  # pragma: no cover\n11 |     sys = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:9\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |         ^^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\nhelp: Add return type annotation: `None`\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN001 Missing type annotation for function argument `enabled`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN201 Missing return type annotation for public function `emit`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:9\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |         ^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `payload`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:20\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |                    ^^^^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:9\n   |\n22 |               sys.stdout.write(json.dumps(payload))\n23 |               sys.stdout.write(\"\\n\")\n24 | /         except Exception:\n25 | |             pass\n   | |________________^\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:16\n   |\n22 |             sys.stdout.write(json.dumps(payload))\n23 |             sys.stdout.write(\"\\n\")\n24 |         except Exception:\n   |                ^^^^^^^^^\n25 |             pass\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_datalogger_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:11:16\n   |\n 9 |     import uos as os  # type: ignore\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |                ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:9\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |         ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `root_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:24\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |                        ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\n\nANN202 Missing return type annotation for private function `_ensure_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:21:9\n   |\n19 |         self._session_path = None\n20 |\n21 |     def _ensure_dir(self):\n   |         ^^^^^^^^^^^\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |\nhelp: Add return type annotation: `None`\n\nSIM105 Use `contextlib.suppress(OSError)` instead of `try`-`except`-`pass`\n  --> firmware\\lib\\x_cls_datalogger_x.py:22:9\n   |\n21 |       def _ensure_dir(self):\n22 | /         try:\n23 | |             os.mkdir(self.root_dir)\n24 | |         except OSError:\n25 | |             pass\n   | |________________^\n26 |\n27 |       def start_session(self, session_id):\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError): ...`\n\nPTH102 `os.mkdir()` should be replaced by `Path.mkdir()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:23:13\n   |\n21 |     def _ensure_dir(self):\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |             ^^^^^^^^\n24 |         except OSError:\n25 |             pass\n   |\nhelp: Replace with `Path(...).mkdir()`\n\nANN201 Missing return type annotation for public function `start_session`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:9\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |         ^^^^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `session_id`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:29\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |                             ^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\n\nUP031 Use format specifiers instead of percent format\n  --> firmware\\lib\\x_cls_datalogger_x.py:28:30\n   |\n27 |     def start_session(self, session_id):\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n29 |         self._buffer = []\n   |\nhelp: Replace with format specifiers\n\nANN201 Missing return type annotation for public function `append`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:9\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |         ^^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:22\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |                      ^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `256` with a constant variable\n  --> firmware\\lib\\x_cls_datalogger_x.py:32:32\n   |\n31 |     def append(self, event):\n32 |         if len(self._buffer) > 256:\n   |                                ^^^\n33 |             self.flush()\n34 |         self._buffer.append(event)\n   |\n\nANN201 Missing return type annotation for public function `flush`\n  --> firmware\\lib\\x_cls_datalogger_x.py:36:9\n   |\n34 |         self._buffer.append(event)\n35 |\n36 |     def flush(self):\n   |         ^^^^^\n37 |         if not self._buffer or self._session_path is None:\n38 |             return\n   |\nhelp: Add return type annotation: `None`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:40:18\n   |\n38 |             return\n39 |         try:\n40 |             with open(self._session_path, \"a\") as handle:\n   |                  ^^^^\n41 |                 for item in self._buffer:\n42 |                     handle.write(json.dumps(item))\n   |\nhelp: Replace with `Path.open()`\n\nANN201 Missing return type annotation for public function `close`\n  --> firmware\\lib\\x_cls_datalogger_x.py:48:9\n   |\n46 |         self._buffer = []\n47 |\n48 |     def close(self):\n   |         ^^^^^\n49 |         self.flush()\n50 |         self._session_path = None\n   |\nhelp: Add return type annotation: `None`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:4:20\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n  |                    ^^^^^^^^^^^^^^\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:5:36\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:6:36\n  |\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n7 |     from machine import SPI, Pin  # type: ignore\n8 | except ImportError:  # pragma: no cover - running under CPython\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:7:35\n  |\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |                                   ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - running under CPython\n9 |     st7789 = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:9:20\n   |\n 7 |     from machine import SPI, Pin  # type: ignore\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:10:24\n   |\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n   |                        ^^^^^^^^^^^^^^\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:11:22\n   |\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |                      ^^^^^^^^^^^^^^\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:12:17\n   |\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:13:17\n   |\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n14 |\n15 | _COLOR_BLACK = 0x0000\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_display_tft_x.py:23:9\n   |\n22 | class Display:\n23 |     def __init__(self):\n   |         ^^^^^^^^\n24 |         self.available = bool(st7789)\n25 |         if not self.available:\n   |\nhelp: Add return type annotation: `None`\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:27:89\n   |\n25 |         if not self.available:\n26 |             return\n27 |         spi = SPI(1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19))\n   |                                                                                         ^\n28 |         self._tft = st7789.ST7789(\n29 |             spi,\n   |\n\nANN201 Missing return type annotation for public function `clear`\n  --> firmware\\lib\\x_cls_display_tft_x.py:45:9\n   |\n43 |         self._punch_count = 0\n44 |\n45 |     def clear(self):\n   |         ^^^^^\n46 |         if not self.available:\n47 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `show_idle`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:9\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |         ^^^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:25\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |                         ^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\n\nANN201 Missing return type annotation for public function `show_session`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:9\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |         ^^^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `counts`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:31\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                               ^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `last_type`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:39\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                       ^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `confidence`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:50\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                  ^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `spm`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:62\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                              ^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `peak`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:67\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                                   ^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:66:89\n   |\n64 |         self._tft.fill_rect(0, 80, 240, 40, _COLOR_BLACK)\n65 |         self._draw_text(font_small, 10, 86, f\"SPM {spm:>5.1f}\", _COLOR_YELLOW)\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n   |                                                                                         ^\n67 |\n68 |     def show_status(self, message, success=True):\n   |\n\nANN201 Missing return type annotation for public function `show_status`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:9\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |         ^^^^^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:27\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                           ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN001 Missing type annotation for function argument `success`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN202 Missing return type annotation for private function `_draw_text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:9\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |         ^^^^^^^^^^\n76 |         if not self.available:\n77 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `font`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:26\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                          ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `x`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:32\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `y`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:35\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                   ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:38\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                      ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `color`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:44\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                            ^^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_features_imu_x.py:6:27\n  |\n4 |     import math\n5 | except ImportError:  # pragma: no cover - MicroPython bundles math\n6 |     import cmath as math  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `magnitude`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:5\n   |\n 9 | def magnitude(vector):\n   |     ^^^^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:15\n   |\n 9 | def magnitude(vector):\n   |               ^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\n\nANN201 Missing return type annotation for public function `dot`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:5\n   |\n14 | def dot(a, b):\n   |     ^^^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:9\n   |\n14 | def dot(a, b):\n   |         ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:12\n   |\n14 | def dot(a, b):\n   |            ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN201 Missing return type annotation for public function `subtract`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:5\n   |\n18 | def subtract(a, b):\n   |     ^^^^^^^^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:14\n   |\n18 | def subtract(a, b):\n   |              ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:17\n   |\n18 | def subtract(a, b):\n   |                 ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN201 Missing return type annotation for public function `cross`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:5\n   |\n22 | def cross(a, b):\n   |     ^^^^^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:11\n   |\n22 | def cross(a, b):\n   |           ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:14\n   |\n22 | def cross(a, b):\n   |              ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN201 Missing return type annotation for public function `jerk`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:5\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |     ^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `prev_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:10\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |          ^^^^^^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:22\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                      ^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `dt`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:29\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                             ^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN201 Missing return type annotation for public function `projection_onto`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:5\n   |\n37 | def projection_onto(vector, axis):\n   |     ^^^^^^^^^^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:21\n   |\n37 | def projection_onto(vector, axis):\n   |                     ^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN001 Missing type annotation for function argument `axis`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:29\n   |\n37 | def projection_onto(vector, axis):\n   |                             ^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `normalize`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:5\n   |\n44 | def normalize(vector):\n   |     ^^^^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:15\n   |\n44 | def normalize(vector):\n   |               ^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `gravity_aligned_components`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:5\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:32\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                ^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:46\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                              ^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN201 Missing return type annotation for public function `angular_rate_features`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:5\n   |\n61 | def angular_rate_features(gyro):\n   |     ^^^^^^^^^^^^^^^^^^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:27\n   |\n61 | def angular_rate_features(gyro):\n   |                           ^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:12:9\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:12:24\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |                        ^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:17:9\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |         ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:17:21\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |                     ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:21:9\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |         ^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:21:20\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |                    ^^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:33:9\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:33:24\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |                        ^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:39:9\n   |\n37 |         self._initialized = False\n38 |\n39 |     def reset(self):\n   |         ^^^^^\n40 |         self._prev_input = 0.0\n41 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:44:9\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |         ^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:44:20\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |                    ^^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:57:9\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |         ^^^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `window`\n  --> firmware\\lib\\x_cls_filters_x.py:57:24\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |                        ^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:63:9\n   |\n61 |         self._count = 0\n62 |\n63 |     def reset(self):\n   |         ^^^^^\n64 |         self._values = [0.0] * self._window\n65 |         self._idx = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:68:9\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |         ^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:68:20\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |                    ^^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:82:9\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |         ^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `period_ms`\n  --> firmware\\lib\\x_cls_filters_x.py:82:24\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |                        ^^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:86:9\n   |\n84 |         self._next = 0\n85 |\n86 |     def reset(self):\n   |         ^^^^^\n87 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ready`\n  --> firmware\\lib\\x_cls_filters_x.py:89:9\n   |\n87 |         self._next = 0\n88 |\n89 |     def ready(self):\n   |         ^^^^^\n90 |         now = time.ticks_ms()\n91 |         if self._next == 0:\n   |\nhelp: Add return type annotation: `bool`\n\nSIM105 Use `contextlib.suppress(ImportError)` instead of `try`-`except`-`pass`\n --> firmware\\lib\\x_cls_metrics_x.py:3:1\n  |\n1 |   \"\"\"Session metrics aggregation.\"\"\"\n2 |\n3 | / try:\n4 | |     import utime as time  # type: ignore\n5 | | except ImportError:  # pragma: no cover - CPython tooling\n6 | |     pass  # type: ignore\n  | |________^\n  |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(ImportError): ...`\n\nF401 `utime` imported but unused; consider using `importlib.util.find_spec` to test for availability\n --> firmware\\lib\\x_cls_metrics_x.py:4:21\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                     ^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\nhelp: Remove unused import: `utime`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:6:11\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |           ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_metrics_x.py:10:9\n   |\n 9 | class MetricsTracker:\n10 |     def __init__(self):\n   |         ^^^^^^^^\n11 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_metrics_x.py:13:9\n   |\n11 |         self.reset()\n12 |\n13 |     def reset(self):\n   |         ^^^^^\n14 |         self.count = 0\n15 |         self.start_ms = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `begin`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:9\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |         ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:21\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |                     ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\n\nANN201 Missing return type annotation for public function `register`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:9\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |         ^^^^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:24\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |                        ^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\n\nANN201 Missing return type annotation for public function `strokes_per_minute`\n  --> firmware\\lib\\x_cls_metrics_x.py:33:9\n   |\n31 |         self.peaks.append(event.get(\"peak_accel\", 0.0))\n32 |\n33 |     def strokes_per_minute(self):\n   |         ^^^^^^^^^^^^^^^^^^\n34 |         if self.start_ms is None or self.last_ms is None:\n35 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `peak_accel`\n  --> firmware\\lib\\x_cls_metrics_x.py:42:9\n   |\n40 |         return self.count / minutes if minutes else 0.0\n41 |\n42 |     def peak_accel(self):\n   |         ^^^^^^^^^^\n43 |         if not self.peaks:\n44 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_punch_classifier_x.py:7:9\n  |\n6 | class PunchClassifier:\n7 |     def __init__(self):\n  |         ^^^^^^^^\n8 |         self.gravity = (0.0, 0.0, -9.81)\n9 |         self.forward_axis = (1.0, 0.0, 0.0)\n  |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `update_orientation`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:9\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |         ^^^^^^^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:34\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                  ^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nANN001 Missing type annotation for function argument `forward_axis`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:43\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                           ^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nE501 Line too long (95 > 88)\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:17:89\n   |\n15 |         self.forward_axis = features.normalize(forward_axis)\n16 |         self.up_axis = features.normalize(tuple(-g for g in gravity))\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n   |                                                                                         ^^^^^^^\n18 |\n19 |     def classify(self, event):\n   |\n\nANN201 Missing return type annotation for public function `classify`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:9\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |         ^^^^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:24\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |                        ^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n7 |\n8 | from . import x_cls_features_imu_x as features\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:14:9\n   |\n12 |     \"\"\"Unbiased running mean/variance for baseline estimation.\"\"\"\n13 |\n14 |     def __init__(self):\n   |         ^^^^^^^^\n15 |         self.count = 0\n16 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:9\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |         ^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:19\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |                   ^^^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:25:9\n   |\n23 |         self.ssq += delta * (value - self.mean)\n24 |\n25 |     def std(self):\n   |         ^^^\n26 |         if self.count < 2:\n27 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_punch_detector_x.py:26:25\n   |\n25 |     def std(self):\n26 |         if self.count < 2:\n   |                         ^\n27 |             return 0.0\n28 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:9\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |         ^^^^^^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:24\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |                        ^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:38:9\n   |\n36 |         self.reset()\n37 |\n38 |     def reset(self):\n   |         ^^^^^\n39 |         self._state = \"idle\"\n40 |         self._last_event_ms = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ingest_idle`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:9\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |         ^^^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `accel_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:27\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                           ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `jerk_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:38\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                      ^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `omega_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:48\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                                ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN201 Missing return type annotation for public function `thresholds`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:51:9\n   |\n49 |         self._omega_stats.add(omega_mag)\n50 |\n51 |     def thresholds(self):\n   |         ^^^^^^^^^^\n52 |         a = max(\n53 |             self.cfg[\"accel_thresh_min\"],\n   |\nhelp: Add return type annotation\n\nPLR0911 Too many return statements (7 > 6)\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN201 Missing return type annotation for public function `update`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:25\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                         ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:32\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                ^^^^^^^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:46\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                              ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `jerk`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:52\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                    ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `dt_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:58\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                          ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `40` with a constant variable\n   --> firmware\\lib\\x_cls_punch_detector_x.py:112:42\n    |\n111 |             if not trigger:\n112 |                 if cand[\"duration_ms\"] < 40:\n    |                                          ^^\n113 |                     self._state = \"idle\"\n114 |                     self._candidate = None\n    |\n\nANN202 Missing return type annotation for private function `_emit_event`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:9\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |         ^^^^^^^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:27\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |                           ^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:6:21\n  |\n4 |     import struct\n5 |\n6 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n7 |     import utime as time  # type: ignore\n8 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:7:27\n  |\n6 |     import machine  # type: ignore\n7 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - CPython tooling\n9 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:9:21\n   |\n 7 |     import utime as time  # type: ignore\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:10:20\n   |\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:11:18\n   |\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:9\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |         ^^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `i2c`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:24\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                        ^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN001 Missing type annotation for function argument `address`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:29\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                             ^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN201 Missing return type annotation for public function `initialize`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:57:9\n   |\n55 |         self._mode = _MODE_CONFIG\n56 |\n57 |     def initialize(self):\n   |         ^^^^^^^^^^\n58 |         self._write8(_REG_OPR_MODE, _MODE_CONFIG)\n59 |         sleep_ms(25)\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `set_mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:9\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |         ^^^^^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:24\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |                        ^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\n\nANN201 Missing return type annotation for public function `read_linear_accel`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:75:9\n   |\n73 |         self._mode = mode\n74 |\n75 |     def read_linear_accel(self):\n   |         ^^^^^^^^^^^^^^^^^\n76 |         x, y, z = self._read_vector(_LINEAR_ACCEL_DATA_X_LSB)\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gravity`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:79:9\n   |\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n78 |\n79 |     def read_gravity(self):\n   |         ^^^^^^^^^^^^\n80 |         x, y, z = self._read_vector(_GRAVITY_DATA_X_LSB)\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gyro`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:83:9\n   |\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n82 |\n83 |     def read_gyro(self):\n   |         ^^^^^^^^^\n84 |         x, y, z = self._read_vector(_GYRO_DATA_X_LSB)\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_euler`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:87:9\n   |\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n86 |\n87 |     def read_euler(self):\n   |         ^^^^^^^^^^\n88 |         heading, roll, pitch = self._read_vector(_EULER_H_LSB)\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_temperature`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:91:9\n   |\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n90 |\n91 |     def read_temperature(self):\n   |         ^^^^^^^^^^^^^^^^\n92 |         buf = self._read_bytes(_REG_TEMP, 1)\n93 |         return float(struct.unpack(\"b\", buf)[0])\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_read_vector`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:9\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |         ^^^^^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:28\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |                            ^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\n\nANN202 Missing return type annotation for private function `_write8`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:9\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |         ^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:23\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                       ^^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN001 Missing type annotation for function argument `value`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:33\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                                 ^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN202 Missing return type annotation for private function `_read_bytes`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:9\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |         ^^^^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:27\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                           ^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nANN001 Missing type annotation for function argument `length`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:37\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                                     ^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nINP001 File `firmware\\main.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\main.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:4:21\n  |\n3 | try:\n4 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:5:27\n  |\n3 | try:\n4 |     import machine  # type: ignore\n5 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:7:21\n  |\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n8 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:8:18\n  |\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n8 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `sleep_ms`\n  --> firmware\\main.py:14:9\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |         ^^^^^^^^\n15 |         time.sleep(ms / 1000.0)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ms`\n  --> firmware\\main.py:14:18\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |                  ^^\n15 |         time.sleep(ms / 1000.0)\n   |\n\nANN201 Missing return type annotation for public function `ticks_ms`\n  --> firmware\\main.py:23:9\n   |\n21 |     ticks_diff = time.ticks_diff  # type: ignore[attr-defined]\n22 | else:  # pragma: no cover - CPython tooling\n23 |     def ticks_ms():\n   |         ^^^^^^^^\n24 |         return int(time.time() * 1000)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `ticks_add`\n  --> firmware\\main.py:26:9\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |         ^^^^^^^^^\n27 |         return value + delta\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\main.py:26:19\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                   ^^^^^\n27 |         return value + delta\n   |\n\nANN001 Missing type annotation for function argument `delta`\n  --> firmware\\main.py:26:26\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                          ^^^^^\n27 |         return value + delta\n   |\n\nANN201 Missing return type annotation for public function `ticks_diff`\n  --> firmware\\main.py:29:9\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |         ^^^^^^^^^^\n30 |         return a - b\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\main.py:29:20\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                    ^\n30 |         return a - b\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\main.py:29:23\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                       ^\n30 |         return a - b\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\main.py:47:9\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |         ^^^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `pin_no`\n  --> firmware\\main.py:47:24\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |                        ^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\n\nANN201 Missing return type annotation for public function `pressed`\n  --> firmware\\main.py:54:9\n   |\n52 |         self._last = 1\n53 |\n54 |     def pressed(self):\n   |         ^^^^^^^\n55 |         if self._pin is None:\n56 |             return False\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_init_sensor`\n  --> firmware\\main.py:63:5\n   |\n63 | def _init_sensor():\n   |     ^^^^^^^^^^^^\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |\nhelp: Add return type annotation\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:65:15\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:65:28\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\nhelp: Assign to variable; remove string literal\n\nANN202 Missing return type annotation for private function `_run_calibration`\n  --> firmware\\main.py:72:5\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |     ^^^^^^^^^^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `sensor`\n  --> firmware\\main.py:72:22\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                      ^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\main.py:72:30\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                              ^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `display`\n  --> firmware\\main.py:72:35\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                                   ^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nC901 `main` is too complex (14 > 10)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0912 Too many branches (15 > 12)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0915 Too many statements (83 > 50)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nANN201 Missing return type annotation for public function `main`\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\nhelp: Add return type annotation: `None`\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:93:15\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:93:28\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> firmware\\main.py:110:15\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> firmware\\main.py:110:28\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |                            ^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (97 > 88)\n   --> firmware\\main.py:120:89\n    |\n118 |     for idx in range(limit):\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n    |                                                                                         ^^^^^^^^^\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nE501 Line too long (101 > 88)\n   --> firmware\\main.py:121:89\n    |\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n    |                                                                                         ^^^^^^^^^^^^^\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nSIM108 Use ternary operator `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)` instead of `if`-`else`-block\n   --> firmware\\main.py:145:9\n    |\n143 |           classifier.update_orientation(gravity, forward_axis)\n144 |\n145 | /         if last_ts is None:\n146 | |             dt_ms = sample_period\n147 | |         else:\n148 | |             dt_ms = ticks_diff(now, last_ts)\n    | |____________________________________________^\n149 |           last_ts = now\n    |\nhelp: Replace `if`-`else`-block with `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)`\n\nE501 Line too long (92 > 88)\n   --> firmware\\main.py:156:89\n    |\n155 |         if not running:\n156 |             detector.ingest_idle(features.magnitude(linear), jerk, features.magnitude(gyro))\n    |                                                                                         ^^^^\n157 |\n158 |         if start_button.pressed():\n    |\n\nINP001 File `firmware\\secrets_template.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\secrets_template.py:1:1\n\nS105 Possible hardcoded password assigned to: \"PASSWORD\"\n --> firmware\\secrets_template.py:8:12\n  |\n7 | SSID = \"YourNetwork\"\n8 | PASSWORD = \"SuperSecret\"\n  |            ^^^^^^^^^^^^^\n  |\n\nFound 263 errors.\nNo fixes available (55 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T02:53:43.731010+00:00\nduration: 0.272s\ntool_version: ruff 0.14.3\nstdout:\nINP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026\nstderr:\n<empty>",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": null,
            "stdout_preview": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-v\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T02:53:40.873586+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 0.4842816999880597,
                "ended_at": "2025-10-31T02:53:40.873586+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "db602e95828154e4c20192d7beb007d0453c618584a7e426ebbab2abd8401e37",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T02:53:40.393772+00:00",
                "stderr": "",
                "stdout": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:9:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:10:27\n   |\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |                           ^^^^^^^^^^^^^^\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:12:21\n   |\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:13:21\n   |\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:14:18\n   |\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n15 |\n16 | SAFE_MODE_PIN = 0  # Button B (GPIO0) used to skip Wi-Fi when held\n   |\n\nPLC0415 `import` should be at the top-level of a file\n  --> firmware\\boot.py:24:9\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:24:45\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |                                             ^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:25:12\n   |\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n25 |     except Exception:  # secrets missing; stay offline\n   |            ^^^^^^^^^\n26 |         return\n   |\n\nFBT003 Boolean positional value in function call\n  --> firmware\\boot.py:30:21\n   |\n28 |     wlan = network.WLAN(network.STA_IF)\n29 |     if not wlan.active():\n30 |         wlan.active(True)\n   |                     ^^^^\n31 |     if wlan.isconnected():\n32 |         return\n   |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n  --> firmware\\boot.py:49:5\n   |\n48 |   if machine is not None:\n49 | /     try:\n50 | |         machine.freq(240_000_000)\n51 | |     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\boot.py:51:5\n   |\n49 |       try:\n50 |           machine.freq(240_000_000)\n51 | /     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:51:12\n   |\n49 |     try:\n50 |         machine.freq(240_000_000)\n51 |     except Exception:\n   |            ^^^^^^^^^\n52 |         pass\n   |\n\nPLR0913 Too many arguments in function definition (8 > 5)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:24\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                        ^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:33\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                 ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:46\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                              ^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:58\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                          ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `forward_axis`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:71\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                       ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:85\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                     ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nE501 Line too long (128 > 88)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:89\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:100\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                    ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:114\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                                  ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:9\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |         ^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `sample_target`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:24\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |                        ^^^^^^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\n\nANN201 Missing return type annotation for public function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:9\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |         ^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:19\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                   ^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:26\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                          ^^^^^^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:40\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                        ^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:49\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                                 ^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:53:38\n   |\n51 |         self._jerk_stats.add(jerk)\n52 |         self._omega_stats.add(omega_mag)\n53 |         if len(self.accel_samples) < 512:\n   |                                      ^^^\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:55:37\n   |\n53 |         if len(self.accel_samples) < 512:\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |                                     ^^^\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:57:38\n   |\n55 |         if len(self.jerk_samples) < 512:\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |                                      ^^^\n58 |             self.omega_samples.append(omega_mag)\n   |\n\nANN201 Missing return type annotation for public function `done`\n  --> firmware\\lib\\x_cls_calibrate_x.py:60:9\n   |\n58 |             self.omega_samples.append(omega_mag)\n59 |\n60 |     def done(self):\n   |         ^^^^\n61 |         return self._count >= self._target\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `result`\n  --> firmware\\lib\\x_cls_calibrate_x.py:63:9\n   |\n61 |         return self._count >= self._target\n62 |\n63 |     def result(self):\n   |         ^^^^^^\n64 |         if self._count == 0:\n65 |             return None\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:85:9\n   |\n84 | class _RunningStats:\n85 |     def __init__(self):\n   |         ^^^^^^^^\n86 |         self.count = 0\n87 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:9\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |         ^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:19\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |                   ^^^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_calibrate_x.py:96:9\n   |\n94 |         self.ssq += delta * (value - self.mean)\n95 |\n96 |     def std(self):\n   |         ^^^\n97 |         if self.count < 2:\n98 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:97:25\n   |\n96 |     def std(self):\n97 |         if self.count < 2:\n   |                         ^\n98 |             return 0.0\n99 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_cfg_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_cfg_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover - CPython tooling\n11 |     import os\n   |\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:38:14\n   |\n36 |     cfg = DEFAULT_CFG.copy()\n37 |     try:\n38 |         with open(_CFG_PATH) as handle:\n   |              ^^^^\n39 |             user_cfg = json.load(handle)\n40 |         if isinstance(user_cfg, dict):\n   |\nhelp: Replace with `Path.open()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:52:14\n   |\n50 |     try:\n51 |         tmp_path = _CFG_PATH + \".tmp\"\n52 |         with open(tmp_path, \"w\") as handle:\n   |              ^^^^\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |\nhelp: Replace with `Path.open()`\n\nPTH104 `os.rename()` should be replaced by `Path.rename()`\n  --> firmware\\lib\\x_cls_cfg_x.py:54:9\n   |\n52 |         with open(tmp_path, \"w\") as handle:\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |         ^^^^^^^^^\n55 |     except OSError:\n56 |         pass\n   |\nhelp: Replace with `Path(...).rename(...)`\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:9\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |         ^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `combo_gap_ms`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:24\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |                        ^^^^^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:9:9\n   |\n 7 |         self.reset()\n 8 |\n 9 |     def reset(self):\n   |         ^^^^^\n10 |         self._current_combo_id = 0\n11 |         self._last_ts = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `assign`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:9\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |         ^^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:22\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |                      ^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_comm_uart_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_comm_uart_x.py:11:17\n   |\n 9 |     import sys\n10 | except ImportError:  # pragma: no cover\n11 |     sys = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:9\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |         ^^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\nhelp: Add return type annotation: `None`\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN001 Missing type annotation for function argument `enabled`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN201 Missing return type annotation for public function `emit`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:9\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |         ^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `payload`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:20\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |                    ^^^^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:9\n   |\n22 |               sys.stdout.write(json.dumps(payload))\n23 |               sys.stdout.write(\"\\n\")\n24 | /         except Exception:\n25 | |             pass\n   | |________________^\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:16\n   |\n22 |             sys.stdout.write(json.dumps(payload))\n23 |             sys.stdout.write(\"\\n\")\n24 |         except Exception:\n   |                ^^^^^^^^^\n25 |             pass\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_datalogger_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:11:16\n   |\n 9 |     import uos as os  # type: ignore\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |                ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:9\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |         ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `root_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:24\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |                        ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\n\nANN202 Missing return type annotation for private function `_ensure_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:21:9\n   |\n19 |         self._session_path = None\n20 |\n21 |     def _ensure_dir(self):\n   |         ^^^^^^^^^^^\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |\nhelp: Add return type annotation: `None`\n\nSIM105 Use `contextlib.suppress(OSError)` instead of `try`-`except`-`pass`\n  --> firmware\\lib\\x_cls_datalogger_x.py:22:9\n   |\n21 |       def _ensure_dir(self):\n22 | /         try:\n23 | |             os.mkdir(self.root_dir)\n24 | |         except OSError:\n25 | |             pass\n   | |________________^\n26 |\n27 |       def start_session(self, session_id):\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError): ...`\n\nPTH102 `os.mkdir()` should be replaced by `Path.mkdir()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:23:13\n   |\n21 |     def _ensure_dir(self):\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |             ^^^^^^^^\n24 |         except OSError:\n25 |             pass\n   |\nhelp: Replace with `Path(...).mkdir()`\n\nANN201 Missing return type annotation for public function `start_session`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:9\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |         ^^^^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `session_id`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:29\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |                             ^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\n\nUP031 Use format specifiers instead of percent format\n  --> firmware\\lib\\x_cls_datalogger_x.py:28:30\n   |\n27 |     def start_session(self, session_id):\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n29 |         self._buffer = []\n   |\nhelp: Replace with format specifiers\n\nANN201 Missing return type annotation for public function `append`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:9\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |         ^^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:22\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |                      ^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `256` with a constant variable\n  --> firmware\\lib\\x_cls_datalogger_x.py:32:32\n   |\n31 |     def append(self, event):\n32 |         if len(self._buffer) > 256:\n   |                                ^^^\n33 |             self.flush()\n34 |         self._buffer.append(event)\n   |\n\nANN201 Missing return type annotation for public function `flush`\n  --> firmware\\lib\\x_cls_datalogger_x.py:36:9\n   |\n34 |         self._buffer.append(event)\n35 |\n36 |     def flush(self):\n   |         ^^^^^\n37 |         if not self._buffer or self._session_path is None:\n38 |             return\n   |\nhelp: Add return type annotation: `None`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:40:18\n   |\n38 |             return\n39 |         try:\n40 |             with open(self._session_path, \"a\") as handle:\n   |                  ^^^^\n41 |                 for item in self._buffer:\n42 |                     handle.write(json.dumps(item))\n   |\nhelp: Replace with `Path.open()`\n\nANN201 Missing return type annotation for public function `close`\n  --> firmware\\lib\\x_cls_datalogger_x.py:48:9\n   |\n46 |         self._buffer = []\n47 |\n48 |     def close(self):\n   |         ^^^^^\n49 |         self.flush()\n50 |         self._session_path = None\n   |\nhelp: Add return type annotation: `None`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:4:20\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n  |                    ^^^^^^^^^^^^^^\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:5:36\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:6:36\n  |\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n7 |     from machine import SPI, Pin  # type: ignore\n8 | except ImportError:  # pragma: no cover - running under CPython\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:7:35\n  |\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |                                   ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - running under CPython\n9 |     st7789 = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:9:20\n   |\n 7 |     from machine import SPI, Pin  # type: ignore\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:10:24\n   |\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n   |                        ^^^^^^^^^^^^^^\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:11:22\n   |\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |                      ^^^^^^^^^^^^^^\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:12:17\n   |\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:13:17\n   |\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n14 |\n15 | _COLOR_BLACK = 0x0000\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_display_tft_x.py:23:9\n   |\n22 | class Display:\n23 |     def __init__(self):\n   |         ^^^^^^^^\n24 |         self.available = bool(st7789)\n25 |         if not self.available:\n   |\nhelp: Add return type annotation: `None`\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:27:89\n   |\n25 |         if not self.available:\n26 |             return\n27 |         spi = SPI(1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19))\n   |                                                                                         ^\n28 |         self._tft = st7789.ST7789(\n29 |             spi,\n   |\n\nANN201 Missing return type annotation for public function `clear`\n  --> firmware\\lib\\x_cls_display_tft_x.py:45:9\n   |\n43 |         self._punch_count = 0\n44 |\n45 |     def clear(self):\n   |         ^^^^^\n46 |         if not self.available:\n47 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `show_idle`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:9\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |         ^^^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:25\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |                         ^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\n\nANN201 Missing return type annotation for public function `show_session`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:9\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |         ^^^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `counts`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:31\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                               ^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `last_type`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:39\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                       ^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `confidence`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:50\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                  ^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `spm`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:62\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                              ^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `peak`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:67\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                                   ^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:66:89\n   |\n64 |         self._tft.fill_rect(0, 80, 240, 40, _COLOR_BLACK)\n65 |         self._draw_text(font_small, 10, 86, f\"SPM {spm:>5.1f}\", _COLOR_YELLOW)\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n   |                                                                                         ^\n67 |\n68 |     def show_status(self, message, success=True):\n   |\n\nANN201 Missing return type annotation for public function `show_status`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:9\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |         ^^^^^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:27\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                           ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN001 Missing type annotation for function argument `success`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN202 Missing return type annotation for private function `_draw_text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:9\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |         ^^^^^^^^^^\n76 |         if not self.available:\n77 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `font`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:26\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                          ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `x`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:32\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `y`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:35\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                   ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:38\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                      ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `color`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:44\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                            ^^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_features_imu_x.py:6:27\n  |\n4 |     import math\n5 | except ImportError:  # pragma: no cover - MicroPython bundles math\n6 |     import cmath as math  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `magnitude`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:5\n   |\n 9 | def magnitude(vector):\n   |     ^^^^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:15\n   |\n 9 | def magnitude(vector):\n   |               ^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\n\nANN201 Missing return type annotation for public function `dot`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:5\n   |\n14 | def dot(a, b):\n   |     ^^^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:9\n   |\n14 | def dot(a, b):\n   |         ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:12\n   |\n14 | def dot(a, b):\n   |            ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN201 Missing return type annotation for public function `subtract`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:5\n   |\n18 | def subtract(a, b):\n   |     ^^^^^^^^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:14\n   |\n18 | def subtract(a, b):\n   |              ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:17\n   |\n18 | def subtract(a, b):\n   |                 ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN201 Missing return type annotation for public function `cross`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:5\n   |\n22 | def cross(a, b):\n   |     ^^^^^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:11\n   |\n22 | def cross(a, b):\n   |           ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:14\n   |\n22 | def cross(a, b):\n   |              ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN201 Missing return type annotation for public function `jerk`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:5\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |     ^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `prev_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:10\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |          ^^^^^^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:22\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                      ^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `dt`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:29\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                             ^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN201 Missing return type annotation for public function `projection_onto`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:5\n   |\n37 | def projection_onto(vector, axis):\n   |     ^^^^^^^^^^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:21\n   |\n37 | def projection_onto(vector, axis):\n   |                     ^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN001 Missing type annotation for function argument `axis`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:29\n   |\n37 | def projection_onto(vector, axis):\n   |                             ^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `normalize`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:5\n   |\n44 | def normalize(vector):\n   |     ^^^^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:15\n   |\n44 | def normalize(vector):\n   |               ^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `gravity_aligned_components`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:5\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:32\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                ^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:46\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                              ^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN201 Missing return type annotation for public function `angular_rate_features`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:5\n   |\n61 | def angular_rate_features(gyro):\n   |     ^^^^^^^^^^^^^^^^^^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:27\n   |\n61 | def angular_rate_features(gyro):\n   |                           ^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:12:9\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:12:24\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |                        ^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:17:9\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |         ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:17:21\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |                     ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:21:9\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |         ^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:21:20\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |                    ^^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:33:9\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:33:24\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |                        ^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:39:9\n   |\n37 |         self._initialized = False\n38 |\n39 |     def reset(self):\n   |         ^^^^^\n40 |         self._prev_input = 0.0\n41 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:44:9\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |         ^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:44:20\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |                    ^^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:57:9\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |         ^^^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `window`\n  --> firmware\\lib\\x_cls_filters_x.py:57:24\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |                        ^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:63:9\n   |\n61 |         self._count = 0\n62 |\n63 |     def reset(self):\n   |         ^^^^^\n64 |         self._values = [0.0] * self._window\n65 |         self._idx = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:68:9\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |         ^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:68:20\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |                    ^^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:82:9\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |         ^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `period_ms`\n  --> firmware\\lib\\x_cls_filters_x.py:82:24\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |                        ^^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:86:9\n   |\n84 |         self._next = 0\n85 |\n86 |     def reset(self):\n   |         ^^^^^\n87 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ready`\n  --> firmware\\lib\\x_cls_filters_x.py:89:9\n   |\n87 |         self._next = 0\n88 |\n89 |     def ready(self):\n   |         ^^^^^\n90 |         now = time.ticks_ms()\n91 |         if self._next == 0:\n   |\nhelp: Add return type annotation: `bool`\n\nSIM105 Use `contextlib.suppress(ImportError)` instead of `try`-`except`-`pass`\n --> firmware\\lib\\x_cls_metrics_x.py:3:1\n  |\n1 |   \"\"\"Session metrics aggregation.\"\"\"\n2 |\n3 | / try:\n4 | |     import utime as time  # type: ignore\n5 | | except ImportError:  # pragma: no cover - CPython tooling\n6 | |     pass  # type: ignore\n  | |________^\n  |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(ImportError): ...`\n\nF401 `utime` imported but unused; consider using `importlib.util.find_spec` to test for availability\n --> firmware\\lib\\x_cls_metrics_x.py:4:21\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                     ^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\nhelp: Remove unused import: `utime`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:6:11\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |           ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_metrics_x.py:10:9\n   |\n 9 | class MetricsTracker:\n10 |     def __init__(self):\n   |         ^^^^^^^^\n11 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_metrics_x.py:13:9\n   |\n11 |         self.reset()\n12 |\n13 |     def reset(self):\n   |         ^^^^^\n14 |         self.count = 0\n15 |         self.start_ms = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `begin`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:9\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |         ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:21\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |                     ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\n\nANN201 Missing return type annotation for public function `register`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:9\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |         ^^^^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:24\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |                        ^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\n\nANN201 Missing return type annotation for public function `strokes_per_minute`\n  --> firmware\\lib\\x_cls_metrics_x.py:33:9\n   |\n31 |         self.peaks.append(event.get(\"peak_accel\", 0.0))\n32 |\n33 |     def strokes_per_minute(self):\n   |         ^^^^^^^^^^^^^^^^^^\n34 |         if self.start_ms is None or self.last_ms is None:\n35 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `peak_accel`\n  --> firmware\\lib\\x_cls_metrics_x.py:42:9\n   |\n40 |         return self.count / minutes if minutes else 0.0\n41 |\n42 |     def peak_accel(self):\n   |         ^^^^^^^^^^\n43 |         if not self.peaks:\n44 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_punch_classifier_x.py:7:9\n  |\n6 | class PunchClassifier:\n7 |     def __init__(self):\n  |         ^^^^^^^^\n8 |         self.gravity = (0.0, 0.0, -9.81)\n9 |         self.forward_axis = (1.0, 0.0, 0.0)\n  |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `update_orientation`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:9\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |         ^^^^^^^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:34\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                  ^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nANN001 Missing type annotation for function argument `forward_axis`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:43\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                           ^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nE501 Line too long (95 > 88)\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:17:89\n   |\n15 |         self.forward_axis = features.normalize(forward_axis)\n16 |         self.up_axis = features.normalize(tuple(-g for g in gravity))\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n   |                                                                                         ^^^^^^^\n18 |\n19 |     def classify(self, event):\n   |\n\nANN201 Missing return type annotation for public function `classify`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:9\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |         ^^^^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:24\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |                        ^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n7 |\n8 | from . import x_cls_features_imu_x as features\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:14:9\n   |\n12 |     \"\"\"Unbiased running mean/variance for baseline estimation.\"\"\"\n13 |\n14 |     def __init__(self):\n   |         ^^^^^^^^\n15 |         self.count = 0\n16 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:9\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |         ^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:19\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |                   ^^^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:25:9\n   |\n23 |         self.ssq += delta * (value - self.mean)\n24 |\n25 |     def std(self):\n   |         ^^^\n26 |         if self.count < 2:\n27 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_punch_detector_x.py:26:25\n   |\n25 |     def std(self):\n26 |         if self.count < 2:\n   |                         ^\n27 |             return 0.0\n28 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:9\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |         ^^^^^^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:24\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |                        ^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:38:9\n   |\n36 |         self.reset()\n37 |\n38 |     def reset(self):\n   |         ^^^^^\n39 |         self._state = \"idle\"\n40 |         self._last_event_ms = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ingest_idle`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:9\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |         ^^^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `accel_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:27\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                           ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `jerk_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:38\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                      ^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `omega_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:48\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                                ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN201 Missing return type annotation for public function `thresholds`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:51:9\n   |\n49 |         self._omega_stats.add(omega_mag)\n50 |\n51 |     def thresholds(self):\n   |         ^^^^^^^^^^\n52 |         a = max(\n53 |             self.cfg[\"accel_thresh_min\"],\n   |\nhelp: Add return type annotation\n\nPLR0911 Too many return statements (7 > 6)\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN201 Missing return type annotation for public function `update`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:25\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                         ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:32\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                ^^^^^^^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:46\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                              ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `jerk`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:52\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                    ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `dt_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:58\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                          ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `40` with a constant variable\n   --> firmware\\lib\\x_cls_punch_detector_x.py:112:42\n    |\n111 |             if not trigger:\n112 |                 if cand[\"duration_ms\"] < 40:\n    |                                          ^^\n113 |                     self._state = \"idle\"\n114 |                     self._candidate = None\n    |\n\nANN202 Missing return type annotation for private function `_emit_event`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:9\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |         ^^^^^^^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:27\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |                           ^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:6:21\n  |\n4 |     import struct\n5 |\n6 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n7 |     import utime as time  # type: ignore\n8 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:7:27\n  |\n6 |     import machine  # type: ignore\n7 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - CPython tooling\n9 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:9:21\n   |\n 7 |     import utime as time  # type: ignore\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:10:20\n   |\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:11:18\n   |\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:9\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |         ^^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `i2c`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:24\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                        ^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN001 Missing type annotation for function argument `address`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:29\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                             ^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN201 Missing return type annotation for public function `initialize`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:57:9\n   |\n55 |         self._mode = _MODE_CONFIG\n56 |\n57 |     def initialize(self):\n   |         ^^^^^^^^^^\n58 |         self._write8(_REG_OPR_MODE, _MODE_CONFIG)\n59 |         sleep_ms(25)\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `set_mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:9\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |         ^^^^^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:24\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |                        ^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\n\nANN201 Missing return type annotation for public function `read_linear_accel`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:75:9\n   |\n73 |         self._mode = mode\n74 |\n75 |     def read_linear_accel(self):\n   |         ^^^^^^^^^^^^^^^^^\n76 |         x, y, z = self._read_vector(_LINEAR_ACCEL_DATA_X_LSB)\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gravity`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:79:9\n   |\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n78 |\n79 |     def read_gravity(self):\n   |         ^^^^^^^^^^^^\n80 |         x, y, z = self._read_vector(_GRAVITY_DATA_X_LSB)\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gyro`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:83:9\n   |\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n82 |\n83 |     def read_gyro(self):\n   |         ^^^^^^^^^\n84 |         x, y, z = self._read_vector(_GYRO_DATA_X_LSB)\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_euler`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:87:9\n   |\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n86 |\n87 |     def read_euler(self):\n   |         ^^^^^^^^^^\n88 |         heading, roll, pitch = self._read_vector(_EULER_H_LSB)\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_temperature`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:91:9\n   |\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n90 |\n91 |     def read_temperature(self):\n   |         ^^^^^^^^^^^^^^^^\n92 |         buf = self._read_bytes(_REG_TEMP, 1)\n93 |         return float(struct.unpack(\"b\", buf)[0])\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_read_vector`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:9\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |         ^^^^^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:28\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |                            ^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\n\nANN202 Missing return type annotation for private function `_write8`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:9\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |         ^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:23\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                       ^^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN001 Missing type annotation for function argument `value`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:33\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                                 ^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN202 Missing return type annotation for private function `_read_bytes`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:9\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |         ^^^^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:27\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                           ^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nANN001 Missing type annotation for function argument `length`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:37\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                                     ^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nINP001 File `firmware\\main.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\main.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:4:21\n  |\n3 | try:\n4 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:5:27\n  |\n3 | try:\n4 |     import machine  # type: ignore\n5 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:7:21\n  |\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n8 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:8:18\n  |\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n8 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `sleep_ms`\n  --> firmware\\main.py:14:9\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |         ^^^^^^^^\n15 |         time.sleep(ms / 1000.0)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ms`\n  --> firmware\\main.py:14:18\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |                  ^^\n15 |         time.sleep(ms / 1000.0)\n   |\n\nANN201 Missing return type annotation for public function `ticks_ms`\n  --> firmware\\main.py:23:9\n   |\n21 |     ticks_diff = time.ticks_diff  # type: ignore[attr-defined]\n22 | else:  # pragma: no cover - CPython tooling\n23 |     def ticks_ms():\n   |         ^^^^^^^^\n24 |         return int(time.time() * 1000)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `ticks_add`\n  --> firmware\\main.py:26:9\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |         ^^^^^^^^^\n27 |         return value + delta\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\main.py:26:19\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                   ^^^^^\n27 |         return value + delta\n   |\n\nANN001 Missing type annotation for function argument `delta`\n  --> firmware\\main.py:26:26\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                          ^^^^^\n27 |         return value + delta\n   |\n\nANN201 Missing return type annotation for public function `ticks_diff`\n  --> firmware\\main.py:29:9\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |         ^^^^^^^^^^\n30 |         return a - b\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\main.py:29:20\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                    ^\n30 |         return a - b\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\main.py:29:23\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                       ^\n30 |         return a - b\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\main.py:47:9\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |         ^^^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `pin_no`\n  --> firmware\\main.py:47:24\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |                        ^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\n\nANN201 Missing return type annotation for public function `pressed`\n  --> firmware\\main.py:54:9\n   |\n52 |         self._last = 1\n53 |\n54 |     def pressed(self):\n   |         ^^^^^^^\n55 |         if self._pin is None:\n56 |             return False\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_init_sensor`\n  --> firmware\\main.py:63:5\n   |\n63 | def _init_sensor():\n   |     ^^^^^^^^^^^^\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |\nhelp: Add return type annotation\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:65:15\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:65:28\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\nhelp: Assign to variable; remove string literal\n\nANN202 Missing return type annotation for private function `_run_calibration`\n  --> firmware\\main.py:72:5\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |     ^^^^^^^^^^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `sensor`\n  --> firmware\\main.py:72:22\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                      ^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\main.py:72:30\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                              ^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `display`\n  --> firmware\\main.py:72:35\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                                   ^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nC901 `main` is too complex (14 > 10)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0912 Too many branches (15 > 12)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0915 Too many statements (83 > 50)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nANN201 Missing return type annotation for public function `main`\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\nhelp: Add return type annotation: `None`\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:93:15\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:93:28\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> firmware\\main.py:110:15\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> firmware\\main.py:110:28\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |                            ^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (97 > 88)\n   --> firmware\\main.py:120:89\n    |\n118 |     for idx in range(limit):\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n    |                                                                                         ^^^^^^^^^\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nE501 Line too long (101 > 88)\n   --> firmware\\main.py:121:89\n    |\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n    |                                                                                         ^^^^^^^^^^^^^\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nSIM108 Use ternary operator `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)` instead of `if`-`else`-block\n   --> firmware\\main.py:145:9\n    |\n143 |           classifier.update_orientation(gravity, forward_axis)\n144 |\n145 | /         if last_ts is None:\n146 | |             dt_ms = sample_period\n147 | |         else:\n148 | |             dt_ms = ticks_diff(now, last_ts)\n    | |____________________________________________^\n149 |           last_ts = now\n    |\nhelp: Replace `if`-`else`-block with `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)`\n\nE501 Line too long (92 > 88)\n   --> firmware\\main.py:156:89\n    |\n155 |         if not running:\n156 |             detector.ingest_idle(features.magnitude(linear), jerk, features.magnitude(gyro))\n    |                                                                                         ^^^^\n157 |\n158 |         if start_button.pressed():\n    |\n\nINP001 File `firmware\\secrets_template.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\secrets_template.py:1:1\n\nS105 Possible hardcoded password assigned to: \"PASSWORD\"\n --> firmware\\secrets_template.py:8:12\n  |\n7 | SSID = \"YourNetwork\"\n8 | PASSWORD = \"SuperSecret\"\n  |            ^^^^^^^^^^^^^\n  |\n\nFound 279 errors (16 fixed, 263 remaining).\nNo fixes available (55 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T02:53:40.393772+00:00\nduration: 0.484s\ntool_version: ruff 0.14.3\nstdout:\nINP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026\nstderr:\n<empty>",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": null,
            "stdout_preview": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --targ\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T02:53:57.750267+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "duration_seconds": 2.317516299895942,
                "ended_at": "2025-10-31T02:53:57.750267+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/conftest.py",
                    "tests/test_cli_script.py",
                    "tests/test_scaffolder.py",
                    "x_cls_make_cli_scaffolder_x.py"
                ],
                "repo": "x_make_cli_scaffolder_x",
                "repo_hash": "7d0d1c39b2d7688950a11ebb63704b5a9ef9fb92e823250f7d0893bb378a5c56",
                "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "started_at": "2025-10-31T02:53:55.436726+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\nwould reformat C:\\x_runner_x\\x_make_cli_scaffolder_x\\x_cls_make_cli_scaffolder_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n2 files would be reformatted, 4 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\t2025-10-30 21:27:03.743331+00:00\n+++ C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\t2025-10-31 02:53:57.097203+00:00\n@@ -25,13 +25,15 @@\n         if path.is_file()\n     }\n \n \n def test_project_config_from_mapping_defaults() -> None:\n-    config = ProjectConfig.from_mapping({\n-        \"project_name\": \"My CLI\",\n-    })\n+    config = ProjectConfig.from_mapping(\n+        {\n+            \"project_name\": \"My CLI\",\n+        }\n+    )\n     assert config.package_name == \"my_cli\"\n     assert config.resolved_script_name == \"my-cli\"\n     assert config.console_entrypoint == \"my_cli.cli:main\"\n     assert config.include_tests is True\n     assert config.include_license is True\n@@ -72,11 +74,15 @@\n     (first.root_path / \"README.md\").write_text(\"updated\", encoding=\"utf-8\")\n     with pytest.raises(FileExistsError):\n         scaffolder.scaffold(tmp_workspace, config)\n     overwriting = CliScaffolder(overwrite=True)\n     result = overwriting.scaffold(tmp_workspace, config)\n-    assert (result.root_path / \"README.md\").read_text(encoding=\"utf-8\").startswith(\"# Overwrite\")\n+    assert (\n+        (result.root_path / \"README.md\")\n+        .read_text(encoding=\"utf-8\")\n+        .startswith(\"# Overwrite\")\n+    )\n \n \n def test_run_entrypoint(tmp_workspace: Path) -> None:\n     payload: Mapping[str, object] = {\n         \"parameters\": {\n--- C:\\x_runner_x\\x_make_cli_scaffolder_x\\x_cls_make_cli_scaffolder_x.py\t2025-10-30 21:27:03.758806+00:00\n+++ C:\\x_runner_x\\x_make_cli_scaffolder_x\\x_cls_make_cli_scaffolder_x.py\t2025-10-31 02:53:57.557542+00:00\n@@ -66,19 +66,21 @@\n             project_name if package_raw is None else str(package_raw)\n         )\n         description = str(payload.get(\"description\", \"\") or \"\")\n         version = str(payload.get(\"version\", \"0.1.0\") or \"0.1.0\")\n         author_value = payload.get(\"author\")\n-        author = str(author_value) if author_value is not None and author_value != \"\" else None\n+        author = (\n+            str(author_value)\n+            if author_value is not None and author_value != \"\"\n+            else None\n+        )\n         python_version = str(payload.get(\"python_version\", \"3.11\") or \"3.11\")\n         include_tests = bool(payload.get(\"include_tests\", True))\n         include_license = bool(payload.get(\"include_license\", True))\n         script_raw = payload.get(\"script_name\")\n         script_name = (\n-            _normalise_script_name(str(script_raw))\n-            if script_raw is not None\n-            else None\n+            _normalise_script_name(str(script_raw)) if script_raw is not None else None\n         )\n         return cls(\n             project_name=project_name,\n             package_name=package_name,\n             description=description,\n@@ -168,13 +170,11 @@\n \n def _render_pyproject(config: ProjectConfig) -> str:\n     author_block = \"\"\n     if config.author:\n         author_block = (\n-            \"    authors = [\\n\"\n-            f'        {{ name = \"{config.author}\" }}\\n'\n-            \"    ]\\n\"\n+            \"    authors = [\\n\" f'        {{ name = \"{config.author}\" }}\\n' \"    ]\\n\"\n         )\n     script_name = config.resolved_script_name\n     return (\n         \"[build-system]\\n\"\n         'requires = [\"setuptools>=68\", \"wheel\"]\\n'\n@@ -311,20 +311,36 @@\n \n \n def main(argv: Sequence[str] | None = None) -> int:\n     parser = argparse.ArgumentParser(description=\"Generate a CLI project scaffold\")\n     parser.add_argument(\"--project-name\", required=True, help=\"Project directory name\")\n-    parser.add_argument(\"--target-dir\", default=\".\", help=\"Directory where the project will be created\")\n+    parser.add_argument(\n+        \"--target-dir\", default=\".\", help=\"Directory where the project will be created\"\n+    )\n     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n-    parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n-    parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n-    parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n-    parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n-    parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n+    parser.add_argument(\n+        \"--author\", default=None, help=\"Author name for README and LICENSE\"\n+    )\n+    parser.add_argument(\n+        \"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\"\n+    )\n+    parser.add_argument(\n+        \"--python-version\", default=\"3.11\", help=\"Minimum Python version\"\n+    )\n+    parser.add_argument(\n+        \"--package-name\", default=None, help=\"Override the generated package name\"\n+    )\n+    parser.add_argument(\n+        \"--script-name\", default=None, help=\"Override the console script name\"\n+    )\n     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n-    parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n-    parser.add_argument(\"--json\", action=\"store_true\", help=\"Emit JSON summary instead of text\")\n+    parser.add_argument(\n+        \"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\"\n+    )\n+    parser.add_argument(\n+        \"--json\", action=\"store_true\", help=\"Emit JSON summary instead of text\"\n+    )\n     args = parser.parse_args(list(argv) if argv is not None else None)\n \n     config_payload = {\n         \"project_name\": args.project_name,\n         \"package_name\": args.package_name,\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_make_cli_scaffolder_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_cli_scaffolder_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T02:53:55.436726+00:00\nduration: 2.318s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\t2025-10-30 21:27:03.743331+00:00\n+++ C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\t2025-10-31 02:53:57.097203+00:00\n@@ -25,13 +25,15 @@\n         if path.is_file()\n     }\n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\nwould reformat C:\\x_runner_x\\x_make_cli_scaffolder_x\\x_cls_make_cli_scaffolder_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n2 files would be reformatted, 4 files would be left unchanged.",
            "repo": "x_make_cli_scaffolder_x",
            "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\nwould reformat C:\\x_runner_x\\x_make_cli_scaffolder_x\\x_cls_make_cli_scaffolder_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n2 files would be reformatted, 4 files would be left unchanged.",
            "stdout_preview": "--- C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\t2025-10-30 21:27:03.743331+00:00\n+++ C:\\x_runner_x\\x_make_cli_scaffolder_x\\tests\\test_scaffolder.py\t2025-10-31 02:53:57.097203+00:00\n@@ -25,13 +25,15 @@\n         if path.is_file()\n     }\n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_make_cli_scaffolder_x (exit 1) cwd: C:\\x_runner_x\\x_make_cli_scaffolder_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-31T02:53:55.\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T02:54:05.320500+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_cli_scaffolder_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_make_cli_scaffolder_x",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_cli_scaffolder_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "duration_seconds": 7.334328699973412,
                "ended_at": "2025-10-31T02:54:05.320500+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/conftest.py",
                    "tests/test_cli_script.py",
                    "tests/test_scaffolder.py",
                    "x_cls_make_cli_scaffolder_x.py"
                ],
                "repo": "x_make_cli_scaffolder_x",
                "repo_hash": "7d0d1c39b2d7688950a11ebb63704b5a9ef9fb92e823250f7d0893bb378a5c56",
                "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "started_at": "2025-10-31T02:53:57.987030+00:00",
                "stderr": "",
                "stdout": "tests\\conftest.py:9: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_cli_scaffolder_x.py:328: error: Expression type contains \"Any\" (has type \"dict[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:329: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:329: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:330: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:330: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:331: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:331: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:332: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:332: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:333: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:333: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:334: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:334: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:335: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:336: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:337: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:337: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:339: error: Expression type contains \"Any\" (has type \"dict[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:340: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:341: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:342: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\ntests\\test_scaffolder.py:109: error: Expression has type \"Any\"  [misc]\ntests\\test_scaffolder.py:110: error: Expression has type \"Any\"  [misc]\ntests\\test_scaffolder.py:111: error: Expression has type \"Any\"  [misc]\nFound 25 errors in 3 files (checked 6 source files)\n",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 1",
            "message": "mypy failed for x_make_cli_scaffolder_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_cli_scaffolder_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_cli_scaffolder_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T02:53:57.987030+00:00\nduration: 7.334s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\ntests\\conftest.py:9: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_cli_scaffolder_x.py:328: error: Expression type contains \"Any\" (has type \"dict[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:329: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:329: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:330: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_cli_scaffolder_x",
            "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
            "stderr_preview": null,
            "stdout_preview": "tests\\conftest.py:9: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_cli_scaffolder_x.py:328: error: Expression type contains \"Any\" (has type \"dict[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:329: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\nx_cls_make_cli_scaffolder_x.py:329: error: Expression has type \"Any\"  [misc]\nx_cls_make_cli_scaffolder_x.py:330: error: Expression type contains \"Any\" (has type \"tuple[str, Any]\")  [misc]\n\u2026",
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_make_cli_scaffolder_x (exit 1) cwd: C:\\x_runner_x\\x_make_cli_scaffolder_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_cli_scaffolder_x --strict --no-warn-unused-configs --show-error-codes --wa\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        },
        {
            "captured_at": "2025-10-31T02:53:57.981295+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "duration_seconds": 0.22249279997777194,
                "ended_at": "2025-10-31T02:53:57.981295+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/conftest.py",
                    "tests/test_cli_script.py",
                    "tests/test_scaffolder.py",
                    "x_cls_make_cli_scaffolder_x.py"
                ],
                "repo": "x_make_cli_scaffolder_x",
                "repo_hash": "7d0d1c39b2d7688950a11ebb63704b5a9ef9fb92e823250f7d0893bb378a5c56",
                "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "started_at": "2025-10-31T02:53:57.759441+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\conftest.py:3:21\n  |\n1 | from __future__ import annotations\n2 |\n3 | from pathlib import Path\n  |                     ^^^^\n4 |\n5 | import pytest\n  |\nhelp: Move into type-checking block\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_cli_script.py:6:21\n  |\n4 | import subprocess\n5 | import sys\n6 | from pathlib import Path\n  |                     ^^^^\n7 |\n8 | from x_make_cli_scaffolder_x.x_cls_make_cli_scaffolder_x import (\n  |\nhelp: Move into type-checking block\n\nS101 Use of `assert` detected\n  --> tests\\test_cli_script.py:29:5\n   |\n27 |         env=env,\n28 |     )\n29 |     assert \"Hello, Tester!\" in completed.stdout\n   |     ^^^^^^\n   |\n\nTC003 Move standard library import `collections.abc.Mapping` into a type-checking block\n --> tests\\test_scaffolder.py:4:29\n  |\n3 | import json\n4 | from collections.abc import Mapping\n  |                             ^^^^^^^\n5 | from pathlib import Path\n6 | from typing import TYPE_CHECKING\n  |\nhelp: Move into type-checking block\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:33:5\n   |\n31 |         \"project_name\": \"My CLI\",\n32 |     })\n33 |     assert config.package_name == \"my_cli\"\n   |     ^^^^^^\n34 |     assert config.resolved_script_name == \"my-cli\"\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:34:5\n   |\n32 |     })\n33 |     assert config.package_name == \"my_cli\"\n34 |     assert config.resolved_script_name == \"my-cli\"\n   |     ^^^^^^\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n36 |     assert config.include_tests is True\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:35:5\n   |\n33 |     assert config.package_name == \"my_cli\"\n34 |     assert config.resolved_script_name == \"my-cli\"\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n   |     ^^^^^^\n36 |     assert config.include_tests is True\n37 |     assert config.include_license is True\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:36:5\n   |\n34 |     assert config.resolved_script_name == \"my-cli\"\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n36 |     assert config.include_tests is True\n   |     ^^^^^^\n37 |     assert config.include_license is True\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:37:5\n   |\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n36 |     assert config.include_tests is True\n37 |     assert config.include_license is True\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:62:5\n   |\n60 |         \"tests/test_cli.py\",\n61 |     }\n62 |     assert _collect_relative_paths(result.root_path) == expected_files\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:77:5\n   |\n75 |     overwriting = CliScaffolder(overwrite=True)\n76 |     result = overwriting.scaffold(tmp_workspace, config)\n77 |     assert (result.root_path / \"README.md\").read_text(encoding=\"utf-8\").startswith(\"# Overwrite\")\n   |     ^^^^^^\n   |\n\nE501 Line too long (97 > 88)\n  --> tests\\test_scaffolder.py:77:89\n   |\n75 |     overwriting = CliScaffolder(overwrite=True)\n76 |     result = overwriting.scaffold(tmp_workspace, config)\n77 |     assert (result.root_path / \"README.md\").read_text(encoding=\"utf-8\").startswith(\"# Overwrite\")\n   |                                                                                         ^^^^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:88:5\n   |\n86 |     }\n87 |     output = run(payload)\n88 |     assert output[\"status\"] == \"success\"\n   |     ^^^^^^\n89 |     created_raw = output[\"created_files\"]\n90 |     assert isinstance(created_raw, list)\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:90:5\n   |\n88 |     assert output[\"status\"] == \"success\"\n89 |     created_raw = output[\"created_files\"]\n90 |     assert isinstance(created_raw, list)\n   |     ^^^^^^\n91 |     created = {Path(str(path)) for path in created_raw}\n92 |     assert created\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:92:5\n   |\n90 |     assert isinstance(created_raw, list)\n91 |     created = {Path(str(path)) for path in created_raw}\n92 |     assert created\n   |     ^^^^^^\n93 |     root_raw = output[\"root_path\"]\n94 |     assert isinstance(root_raw, str)\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:94:5\n   |\n92 |     assert created\n93 |     root_raw = output[\"root_path\"]\n94 |     assert isinstance(root_raw, str)\n   |     ^^^^^^\n95 |     root_path = Path(root_raw)\n96 |     assert root_path.exists()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:96:5\n   |\n94 |     assert isinstance(root_raw, str)\n95 |     root_path = Path(root_raw)\n96 |     assert root_path.exists()\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n   --> tests\\test_scaffolder.py:108:5\n    |\n106 |     ]\n107 |     exit_code = main(args)\n108 |     assert exit_code == 0\n    |     ^^^^^^\n109 |     output = json.loads(capsys.readouterr().out)\n110 |     assert output[\"status\"] == \"success\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_scaffolder.py:110:5\n    |\n108 |     assert exit_code == 0\n109 |     output = json.loads(capsys.readouterr().out)\n110 |     assert output[\"status\"] == \"success\"\n    |     ^^^^^^\n111 |     assert \"root_path\" in output\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_scaffolder.py:111:5\n    |\n109 |     output = json.loads(capsys.readouterr().out)\n110 |     assert output[\"status\"] == \"success\"\n111 |     assert \"root_path\" in output\n    |     ^^^^^^\n    |\n\nE501 Line too long (95 > 88)\n  --> x_cls_make_cli_scaffolder_x.py:71:89\n   |\n69 |         version = str(payload.get(\"version\", \"0.1.0\") or \"0.1.0\")\n70 |         author_value = payload.get(\"author\")\n71 |         author = str(author_value) if author_value is not None and author_value != \"\" else None\n   |                                                                                         ^^^^^^^\n72 |         python_version = str(payload.get(\"python_version\", \"3.11\") or \"3.11\")\n73 |         include_tests = bool(payload.get(\"include_tests\", True))\n   |\n\nSIM102 Use a single `if` statement instead of nested `if` statements\n   --> x_cls_make_cli_scaffolder_x.py:122:9\n    |\n120 |       def scaffold(self, target_dir: Path, config: ProjectConfig) -> ScaffoldResult:\n121 |           root_path = target_dir / config.project_name\n122 | /         if root_path.exists() and not self._overwrite:\n123 | |             if any(root_path.iterdir()):\n    | |________________________________________^\n124 |                   raise FileExistsError(f\"Directory '{root_path}' is not empty\")\n125 |           root_path.mkdir(parents=True, exist_ok=True)\n    |\nhelp: Combine `if` statements using `and`\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:124:23\n    |\n122 |         if root_path.exists() and not self._overwrite:\n123 |             if any(root_path.iterdir()):\n124 |                 raise FileExistsError(f\"Directory '{root_path}' is not empty\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n125 |         root_path.mkdir(parents=True, exist_ok=True)\n126 |         created: list[Path] = []\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:124:39\n    |\n122 |         if root_path.exists() and not self._overwrite:\n123 |             if any(root_path.iterdir()):\n124 |                 raise FileExistsError(f\"Directory '{root_path}' is not empty\")\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n125 |         root_path.mkdir(parents=True, exist_ok=True)\n126 |         created: list[Path] = []\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:131:23\n    |\n129 |             file_path.parent.mkdir(parents=True, exist_ok=True)\n130 |             if file_path.exists() and not self._overwrite:\n131 |                 raise FileExistsError(f\"File '{file_path}' already exists\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n132 |             file_path.write_text(contents, encoding=\"utf-8\")\n133 |             created.append(file_path)\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:131:39\n    |\n129 |             file_path.parent.mkdir(parents=True, exist_ok=True)\n130 |             if file_path.exists() and not self._overwrite:\n131 |                 raise FileExistsError(f\"File '{file_path}' already exists\")\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n132 |             file_path.write_text(contents, encoding=\"utf-8\")\n133 |             created.append(file_path)\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:137:23\n    |\n135 |             license_path = root_path / \"LICENSE\"\n136 |             if license_path.exists() and not self._overwrite:\n137 |                 raise FileExistsError(f\"File '{license_path}' already exists\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |             license_path.write_text(_render_mit_license(config), encoding=\"utf-8\")\n139 |             created.append(license_path)\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:137:39\n    |\n135 |             license_path = root_path / \"LICENSE\"\n136 |             if license_path.exists() and not self._overwrite:\n137 |                 raise FileExistsError(f\"File '{license_path}' already exists\")\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |             license_path.write_text(_render_mit_license(config), encoding=\"utf-8\")\n139 |             created.append(license_path)\n    |\nhelp: Assign to variable; remove f-string literal\n\nE501 Line too long (122 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:242:89\n    |\n240 |         \"import runpy\\n\"\n241 |         \"import pytest\\n\\n\"\n242 |         \"@pytest.mark.parametrize('argv,expected', [(None, 'Hello, world!'), (['--name', 'Tester'], 'Hello, Tester!')])\\n\"\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n243 |         \"def test_cli_output(argv: list[str] | None, expected: str, capsys: pytest.CaptureFixture[str]) -> None:\\n\"\n244 |         f\"    module = importlib.import_module('{package}.cli')\\n\"\n    |\n\nE501 Line too long (115 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:243:89\n    |\n241 |         \"import pytest\\n\\n\"\n242 |         \"@pytest.mark.parametrize('argv,expected', [(None, 'Hello, world!'), (['--name', 'Tester'], 'Hello, Tester!')])\\n\"\n243 |         \"def test_cli_output(argv: list[str] | None, expected: str, capsys: pytest.CaptureFixture[str]) -> None:\\n\"\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n244 |         f\"    module = importlib.import_module('{package}.cli')\\n\"\n245 |         \"    result = module.main(argv)\\n\"\n    |\n\nDTZ005 `datetime.datetime.now()` called without a `tz` argument\n   --> x_cls_make_cli_scaffolder_x.py:260:12\n    |\n259 | def _render_mit_license(config: ProjectConfig) -> str:\n260 |     year = datetime.now().year\n    |            ^^^^^^^^^^^^^^\n261 |     holder = config.author or \"Author\"\n262 |     body = f\"\"\"\n    |\nhelp: Pass a `datetime.timezone` object to the `tz` parameter\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:291:15\n    |\n289 |     value = payload.get(key)\n290 |     if not isinstance(value, str) or not value.strip():\n291 |         raise ValueError(f\"Parameter '{key}' must be a non-empty string\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n292 |     return value.strip()\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:291:26\n    |\n289 |     value = payload.get(key)\n290 |     if not isinstance(value, str) or not value.strip():\n291 |         raise ValueError(f\"Parameter '{key}' must be a non-empty string\")\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n292 |     return value.strip()\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:298:15\n    |\n296 |     parameters_obj = payload.get(\"parameters\")\n297 |     if not isinstance(parameters_obj, Mapping):\n298 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n299 |     target_dir_obj = parameters_obj.get(\"target_dir\", \".\")\n300 |     target_dir = Path(str(target_dir_obj))\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:298:25\n    |\n296 |     parameters_obj = payload.get(\"parameters\")\n297 |     if not isinstance(parameters_obj, Mapping):\n298 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n299 |     target_dir_obj = parameters_obj.get(\"target_dir\", \".\")\n300 |     target_dir = Path(str(target_dir_obj))\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (104 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:316:89\n    |\n314 |     parser = argparse.ArgumentParser(description=\"Generate a CLI project scaffold\")\n315 |     parser.add_argument(\"--project-name\", required=True, help=\"Project directory name\")\n316 |     parser.add_argument(\"--target-dir\", default=\".\", help=\"Directory where the project will be created\")\n    |                                                                                         ^^^^^^^^^^^^^^^^\n317 |     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n    |\n\nE501 Line too long (92 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:318:89\n    |\n316 |     parser.add_argument(\"--target-dir\", default=\".\", help=\"Directory where the project will be created\")\n317 |     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n    |                                                                                         ^^^^\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n    |\n\nE501 Line too long (96 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:319:89\n    |\n317 |     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n    |                                                                                         ^^^^^^^^\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n    |\n\nE501 Line too long (90 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:320:89\n    |\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n    |                                                                                         ^^\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n    |\n\nE501 Line too long (99 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:321:89\n    |\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n    |                                                                                         ^^^^^^^^^^^\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n    |\n\nE501 Line too long (95 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:322:89\n    |\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n    |                                                                                         ^^^^^^^\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n324 |     parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n    |\n\nE501 Line too long (90 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:324:89\n    |\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n324 |     parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n    |                                                                                         ^^\n325 |     parser.add_argument(\"--json\", action=\"store_true\", help=\"Emit JSON summary instead of text\")\n326 |     args = parser.parse_args(list(argv) if argv is not None else None)\n    |\n\nE501 Line too long (96 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:325:89\n    |\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n324 |     parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n325 |     parser.add_argument(\"--json\", action=\"store_true\", help=\"Emit JSON summary instead of text\")\n    |                                                                                         ^^^^^^^^\n326 |     args = parser.parse_args(list(argv) if argv is not None else None)\n    |\n\nFound 43 errors.\nNo fixes available (8 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_make_cli_scaffolder_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_cli_scaffolder_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T02:53:57.759441+00:00\nduration: 0.222s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\conftest.py:3:21\n  |\n1 | from __future__ import annotations\n2 |\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_cli_scaffolder_x",
            "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\conftest.py:3:21\n  |\n1 | from __future__ import annotations\n2 |\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_make_cli_scaffolder_x (exit 1) cwd: C:\\x_runner_x\\x_make_cli_scaffolder_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version p\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T02:53:55.424336+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "duration_seconds": 0.41755340003874153,
                "ended_at": "2025-10-31T02:53:55.424336+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/conftest.py",
                    "tests/test_cli_script.py",
                    "tests/test_scaffolder.py",
                    "x_cls_make_cli_scaffolder_x.py"
                ],
                "repo": "x_make_cli_scaffolder_x",
                "repo_hash": "7d0d1c39b2d7688950a11ebb63704b5a9ef9fb92e823250f7d0893bb378a5c56",
                "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
                "started_at": "2025-10-31T02:53:55.011264+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\conftest.py:3:21\n  |\n1 | from __future__ import annotations\n2 |\n3 | from pathlib import Path\n  |                     ^^^^\n4 |\n5 | import pytest\n  |\nhelp: Move into type-checking block\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_cli_script.py:6:21\n  |\n4 | import subprocess\n5 | import sys\n6 | from pathlib import Path\n  |                     ^^^^\n7 |\n8 | from x_make_cli_scaffolder_x.x_cls_make_cli_scaffolder_x import (\n  |\nhelp: Move into type-checking block\n\nS101 Use of `assert` detected\n  --> tests\\test_cli_script.py:29:5\n   |\n27 |         env=env,\n28 |     )\n29 |     assert \"Hello, Tester!\" in completed.stdout\n   |     ^^^^^^\n   |\n\nTC003 Move standard library import `collections.abc.Mapping` into a type-checking block\n --> tests\\test_scaffolder.py:4:29\n  |\n3 | import json\n4 | from collections.abc import Mapping\n  |                             ^^^^^^^\n5 | from pathlib import Path\n6 | from typing import TYPE_CHECKING\n  |\nhelp: Move into type-checking block\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:33:5\n   |\n31 |         \"project_name\": \"My CLI\",\n32 |     })\n33 |     assert config.package_name == \"my_cli\"\n   |     ^^^^^^\n34 |     assert config.resolved_script_name == \"my-cli\"\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:34:5\n   |\n32 |     })\n33 |     assert config.package_name == \"my_cli\"\n34 |     assert config.resolved_script_name == \"my-cli\"\n   |     ^^^^^^\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n36 |     assert config.include_tests is True\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:35:5\n   |\n33 |     assert config.package_name == \"my_cli\"\n34 |     assert config.resolved_script_name == \"my-cli\"\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n   |     ^^^^^^\n36 |     assert config.include_tests is True\n37 |     assert config.include_license is True\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:36:5\n   |\n34 |     assert config.resolved_script_name == \"my-cli\"\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n36 |     assert config.include_tests is True\n   |     ^^^^^^\n37 |     assert config.include_license is True\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:37:5\n   |\n35 |     assert config.console_entrypoint == \"my_cli.cli:main\"\n36 |     assert config.include_tests is True\n37 |     assert config.include_license is True\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:62:5\n   |\n60 |         \"tests/test_cli.py\",\n61 |     }\n62 |     assert _collect_relative_paths(result.root_path) == expected_files\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:77:5\n   |\n75 |     overwriting = CliScaffolder(overwrite=True)\n76 |     result = overwriting.scaffold(tmp_workspace, config)\n77 |     assert (result.root_path / \"README.md\").read_text(encoding=\"utf-8\").startswith(\"# Overwrite\")\n   |     ^^^^^^\n   |\n\nE501 Line too long (97 > 88)\n  --> tests\\test_scaffolder.py:77:89\n   |\n75 |     overwriting = CliScaffolder(overwrite=True)\n76 |     result = overwriting.scaffold(tmp_workspace, config)\n77 |     assert (result.root_path / \"README.md\").read_text(encoding=\"utf-8\").startswith(\"# Overwrite\")\n   |                                                                                         ^^^^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:88:5\n   |\n86 |     }\n87 |     output = run(payload)\n88 |     assert output[\"status\"] == \"success\"\n   |     ^^^^^^\n89 |     created_raw = output[\"created_files\"]\n90 |     assert isinstance(created_raw, list)\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:90:5\n   |\n88 |     assert output[\"status\"] == \"success\"\n89 |     created_raw = output[\"created_files\"]\n90 |     assert isinstance(created_raw, list)\n   |     ^^^^^^\n91 |     created = {Path(str(path)) for path in created_raw}\n92 |     assert created\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:92:5\n   |\n90 |     assert isinstance(created_raw, list)\n91 |     created = {Path(str(path)) for path in created_raw}\n92 |     assert created\n   |     ^^^^^^\n93 |     root_raw = output[\"root_path\"]\n94 |     assert isinstance(root_raw, str)\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:94:5\n   |\n92 |     assert created\n93 |     root_raw = output[\"root_path\"]\n94 |     assert isinstance(root_raw, str)\n   |     ^^^^^^\n95 |     root_path = Path(root_raw)\n96 |     assert root_path.exists()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_scaffolder.py:96:5\n   |\n94 |     assert isinstance(root_raw, str)\n95 |     root_path = Path(root_raw)\n96 |     assert root_path.exists()\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n   --> tests\\test_scaffolder.py:108:5\n    |\n106 |     ]\n107 |     exit_code = main(args)\n108 |     assert exit_code == 0\n    |     ^^^^^^\n109 |     output = json.loads(capsys.readouterr().out)\n110 |     assert output[\"status\"] == \"success\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_scaffolder.py:110:5\n    |\n108 |     assert exit_code == 0\n109 |     output = json.loads(capsys.readouterr().out)\n110 |     assert output[\"status\"] == \"success\"\n    |     ^^^^^^\n111 |     assert \"root_path\" in output\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_scaffolder.py:111:5\n    |\n109 |     output = json.loads(capsys.readouterr().out)\n110 |     assert output[\"status\"] == \"success\"\n111 |     assert \"root_path\" in output\n    |     ^^^^^^\n    |\n\nE501 Line too long (95 > 88)\n  --> x_cls_make_cli_scaffolder_x.py:71:89\n   |\n69 |         version = str(payload.get(\"version\", \"0.1.0\") or \"0.1.0\")\n70 |         author_value = payload.get(\"author\")\n71 |         author = str(author_value) if author_value is not None and author_value != \"\" else None\n   |                                                                                         ^^^^^^^\n72 |         python_version = str(payload.get(\"python_version\", \"3.11\") or \"3.11\")\n73 |         include_tests = bool(payload.get(\"include_tests\", True))\n   |\n\nSIM102 Use a single `if` statement instead of nested `if` statements\n   --> x_cls_make_cli_scaffolder_x.py:122:9\n    |\n120 |       def scaffold(self, target_dir: Path, config: ProjectConfig) -> ScaffoldResult:\n121 |           root_path = target_dir / config.project_name\n122 | /         if root_path.exists() and not self._overwrite:\n123 | |             if any(root_path.iterdir()):\n    | |________________________________________^\n124 |                   raise FileExistsError(f\"Directory '{root_path}' is not empty\")\n125 |           root_path.mkdir(parents=True, exist_ok=True)\n    |\nhelp: Combine `if` statements using `and`\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:124:23\n    |\n122 |         if root_path.exists() and not self._overwrite:\n123 |             if any(root_path.iterdir()):\n124 |                 raise FileExistsError(f\"Directory '{root_path}' is not empty\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n125 |         root_path.mkdir(parents=True, exist_ok=True)\n126 |         created: list[Path] = []\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:124:39\n    |\n122 |         if root_path.exists() and not self._overwrite:\n123 |             if any(root_path.iterdir()):\n124 |                 raise FileExistsError(f\"Directory '{root_path}' is not empty\")\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n125 |         root_path.mkdir(parents=True, exist_ok=True)\n126 |         created: list[Path] = []\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:131:23\n    |\n129 |             file_path.parent.mkdir(parents=True, exist_ok=True)\n130 |             if file_path.exists() and not self._overwrite:\n131 |                 raise FileExistsError(f\"File '{file_path}' already exists\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n132 |             file_path.write_text(contents, encoding=\"utf-8\")\n133 |             created.append(file_path)\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:131:39\n    |\n129 |             file_path.parent.mkdir(parents=True, exist_ok=True)\n130 |             if file_path.exists() and not self._overwrite:\n131 |                 raise FileExistsError(f\"File '{file_path}' already exists\")\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n132 |             file_path.write_text(contents, encoding=\"utf-8\")\n133 |             created.append(file_path)\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:137:23\n    |\n135 |             license_path = root_path / \"LICENSE\"\n136 |             if license_path.exists() and not self._overwrite:\n137 |                 raise FileExistsError(f\"File '{license_path}' already exists\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |             license_path.write_text(_render_mit_license(config), encoding=\"utf-8\")\n139 |             created.append(license_path)\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:137:39\n    |\n135 |             license_path = root_path / \"LICENSE\"\n136 |             if license_path.exists() and not self._overwrite:\n137 |                 raise FileExistsError(f\"File '{license_path}' already exists\")\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |             license_path.write_text(_render_mit_license(config), encoding=\"utf-8\")\n139 |             created.append(license_path)\n    |\nhelp: Assign to variable; remove f-string literal\n\nE501 Line too long (122 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:242:89\n    |\n240 |         \"import runpy\\n\"\n241 |         \"import pytest\\n\\n\"\n242 |         \"@pytest.mark.parametrize('argv,expected', [(None, 'Hello, world!'), (['--name', 'Tester'], 'Hello, Tester!')])\\n\"\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n243 |         \"def test_cli_output(argv: list[str] | None, expected: str, capsys: pytest.CaptureFixture[str]) -> None:\\n\"\n244 |         f\"    module = importlib.import_module('{package}.cli')\\n\"\n    |\n\nE501 Line too long (115 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:243:89\n    |\n241 |         \"import pytest\\n\\n\"\n242 |         \"@pytest.mark.parametrize('argv,expected', [(None, 'Hello, world!'), (['--name', 'Tester'], 'Hello, Tester!')])\\n\"\n243 |         \"def test_cli_output(argv: list[str] | None, expected: str, capsys: pytest.CaptureFixture[str]) -> None:\\n\"\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n244 |         f\"    module = importlib.import_module('{package}.cli')\\n\"\n245 |         \"    result = module.main(argv)\\n\"\n    |\n\nDTZ005 `datetime.datetime.now()` called without a `tz` argument\n   --> x_cls_make_cli_scaffolder_x.py:260:12\n    |\n259 | def _render_mit_license(config: ProjectConfig) -> str:\n260 |     year = datetime.now().year\n    |            ^^^^^^^^^^^^^^\n261 |     holder = config.author or \"Author\"\n262 |     body = f\"\"\"\n    |\nhelp: Pass a `datetime.timezone` object to the `tz` parameter\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:291:15\n    |\n289 |     value = payload.get(key)\n290 |     if not isinstance(value, str) or not value.strip():\n291 |         raise ValueError(f\"Parameter '{key}' must be a non-empty string\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n292 |     return value.strip()\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:291:26\n    |\n289 |     value = payload.get(key)\n290 |     if not isinstance(value, str) or not value.strip():\n291 |         raise ValueError(f\"Parameter '{key}' must be a non-empty string\")\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n292 |     return value.strip()\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_cli_scaffolder_x.py:298:15\n    |\n296 |     parameters_obj = payload.get(\"parameters\")\n297 |     if not isinstance(parameters_obj, Mapping):\n298 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n299 |     target_dir_obj = parameters_obj.get(\"target_dir\", \".\")\n300 |     target_dir = Path(str(target_dir_obj))\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_cli_scaffolder_x.py:298:25\n    |\n296 |     parameters_obj = payload.get(\"parameters\")\n297 |     if not isinstance(parameters_obj, Mapping):\n298 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n299 |     target_dir_obj = parameters_obj.get(\"target_dir\", \".\")\n300 |     target_dir = Path(str(target_dir_obj))\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (104 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:316:89\n    |\n314 |     parser = argparse.ArgumentParser(description=\"Generate a CLI project scaffold\")\n315 |     parser.add_argument(\"--project-name\", required=True, help=\"Project directory name\")\n316 |     parser.add_argument(\"--target-dir\", default=\".\", help=\"Directory where the project will be created\")\n    |                                                                                         ^^^^^^^^^^^^^^^^\n317 |     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n    |\n\nE501 Line too long (92 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:318:89\n    |\n316 |     parser.add_argument(\"--target-dir\", default=\".\", help=\"Directory where the project will be created\")\n317 |     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n    |                                                                                         ^^^^\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n    |\n\nE501 Line too long (96 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:319:89\n    |\n317 |     parser.add_argument(\"--description\", default=\"\", help=\"Project description\")\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n    |                                                                                         ^^^^^^^^\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n    |\n\nE501 Line too long (90 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:320:89\n    |\n318 |     parser.add_argument(\"--author\", default=None, help=\"Author name for README and LICENSE\")\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n    |                                                                                         ^^\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n    |\n\nE501 Line too long (99 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:321:89\n    |\n319 |     parser.add_argument(\"--version\", default=\"0.1.0\", help=\"Initial version for pyproject.toml\")\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n    |                                                                                         ^^^^^^^^^^^\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n    |\n\nE501 Line too long (95 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:322:89\n    |\n320 |     parser.add_argument(\"--python-version\", default=\"3.11\", help=\"Minimum Python version\")\n321 |     parser.add_argument(\"--package-name\", default=None, help=\"Override the generated package name\")\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n    |                                                                                         ^^^^^^^\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n324 |     parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n    |\n\nE501 Line too long (90 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:324:89\n    |\n322 |     parser.add_argument(\"--script-name\", default=None, help=\"Override the console script name\")\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n324 |     parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n    |                                                                                         ^^\n325 |     parser.add_argument(\"--json\", action=\"store_true\", help=\"Emit JSON summary instead of text\")\n326 |     args = parser.parse_args(list(argv) if argv is not None else None)\n    |\n\nE501 Line too long (96 > 88)\n   --> x_cls_make_cli_scaffolder_x.py:325:89\n    |\n323 |     parser.add_argument(\"--no-tests\", action=\"store_true\", help=\"Skip pytest scaffold\")\n324 |     parser.add_argument(\"--no-license\", action=\"store_true\", help=\"Skip MIT license stub\")\n325 |     parser.add_argument(\"--json\", action=\"store_true\", help=\"Emit JSON summary instead of text\")\n    |                                                                                         ^^^^^^^^\n326 |     args = parser.parse_args(list(argv) if argv is not None else None)\n    |\n\nFound 43 errors.\nNo fixes available (8 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_make_cli_scaffolder_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_cli_scaffolder_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T02:53:55.011264+00:00\nduration: 0.418s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\conftest.py:3:21\n  |\n1 | from __future__ import annotations\n2 |\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_cli_scaffolder_x",
            "repo_path": "C:\\x_runner_x\\x_make_cli_scaffolder_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\conftest.py:3:21\n  |\n1 | from __future__ import annotations\n2 |\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_make_cli_scaffolder_x (exit 1) cwd: C:\\x_runner_x\\x_make_cli_scaffolder_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-versi\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T02:54:21.949069+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_make_contract_validators_x",
                "duration_seconds": 2.4800095000537112,
                "ended_at": "2025-10-31T02:54:21.949069+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/test_contract_validators.py",
                    "x_cls_make_contract_validators_x.py"
                ],
                "repo": "x_make_contract_validators_x",
                "repo_hash": "e8db2f7cca24a74340066abe9642258fa0fac4b8ed8d1b017f46edde45b07bbf",
                "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
                "started_at": "2025-10-31T02:54:19.471953+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\nwould reformat C:\\x_runner_x\\x_make_contract_validators_x\\x_cls_make_contract_validators_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n2 files would be reformatted, 2 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\t2025-10-30 21:27:14.068087+00:00\n+++ C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\t2025-10-31 02:54:21.502365+00:00\n@@ -74,11 +74,13 @@\n     result = run(payload)\n     assert result[\"status\"] == \"success\"\n     assert result[\"issues\"] == []\n \n \n-def test_run_payload_from_files(sample_schema: dict[str, object], tmp_path: Path) -> None:\n+def test_run_payload_from_files(\n+    sample_schema: dict[str, object], tmp_path: Path\n+) -> None:\n     schema_path = tmp_path / \"schema.json\"\n     payload_path = tmp_path / \"payload.json\"\n     schema_path.write_text(json.dumps(sample_schema), encoding=\"utf-8\")\n     payload_path.write_text(json.dumps({\"name\": \"Ops\", \"age\": 2}), encoding=\"utf-8\")\n     payload = {\n@@ -102,38 +104,46 @@\n     assert result[\"status\"] == \"failure\"\n     assert result[\"error_type\"] == \"payload\"\n     assert result[\"issues\"]\n \n \n-def test_cli_success(sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]) -> None:\n+def test_cli_success(\n+    sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]\n+) -> None:\n     schema_path = tmp_path / \"schema.json\"\n     payload_path = tmp_path / \"payload.json\"\n     schema_path.write_text(json.dumps(sample_schema), encoding=\"utf-8\")\n     payload_path.write_text(json.dumps({\"name\": \"CLI\"}), encoding=\"utf-8\")\n-    exit_code = main([\n-        \"--schema\",\n-        str(schema_path),\n-        \"--payload\",\n-        str(payload_path),\n-        \"--json\",\n-    ])\n+    exit_code = main(\n+        [\n+            \"--schema\",\n+            str(schema_path),\n+            \"--payload\",\n+            str(payload_path),\n+            \"--json\",\n+        ]\n+    )\n     assert exit_code == 0\n     output = json.loads(capsys.readouterr().out)\n     assert output[\"status\"] == \"success\"\n \n \n-def test_cli_failure(sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]) -> None:\n+def test_cli_failure(\n+    sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]\n+) -> None:\n     schema_path = tmp_path / \"schema.json\"\n     payload_path = tmp_path / \"payload.json\"\n     schema_path.write_text(json.dumps(sample_schema), encoding=\"utf-8\")\n     payload_path.write_text(json.dumps({\"age\": 5}), encoding=\"utf-8\")\n-    exit_code = main([\n-        \"--schema\",\n-        str(schema_path),\n-        \"--payload\",\n-        str(payload_path),\n-        \"--json\",\n-    ])\n+    exit_code = main(\n+        [\n+            \"--schema\",\n+            str(schema_path),\n+            \"--payload\",\n+            str(payload_path),\n+            \"--json\",\n+        ]\n+    )\n     assert exit_code == 1\n     output = json.loads(capsys.readouterr().out)\n     assert output[\"status\"] == \"failure\"\n     assert output[\"error_type\"] == \"payload\"\n--- C:\\x_runner_x\\x_make_contract_validators_x\\x_cls_make_contract_validators_x.py\t2025-10-30 21:27:14.089799+00:00\n+++ C:\\x_runner_x\\x_make_contract_validators_x\\x_cls_make_contract_validators_x.py\t2025-10-31 02:54:21.623245+00:00\n@@ -146,11 +146,13 @@\n def _resolve_payload(parameters: Mapping[str, object]) -> object:\n     if \"payload\" in parameters:\n         return parameters[\"payload\"]\n     payload_path_obj = parameters.get(\"payload_path\")\n     if payload_path_obj is None:\n-        raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n+        raise ValueError(\n+            \"Payload data must be provided via 'payload' or 'payload_path'\"\n+        )\n     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n \n \n def _load_json(path: Path, *, expect_mapping: bool) -> Any:\n     with path.open(\"r\", encoding=\"utf-8\") as handle:\n@@ -159,11 +161,13 @@\n         raise TypeError(\"JSON file must contain an object at the root\")\n     return data\n \n \n def main(argv: Sequence[str] | None = None) -> int:\n-    parser = argparse.ArgumentParser(description=\"Validate JSON payloads against a schema\")\n+    parser = argparse.ArgumentParser(\n+        description=\"Validate JSON payloads against a schema\"\n+    )\n     parser.add_argument(\"--schema\", required=True, help=\"Path to JSON schema file\")\n     parser.add_argument(\"--payload\", required=True, help=\"Path to JSON payload file\")\n     parser.add_argument(\"--json\", action=\"store_true\", help=\"Emit JSON summary\")\n     args = parser.parse_args(list(argv) if argv is not None else None)\n \n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_make_contract_validators_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_contract_validators_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T02:54:19.471953+00:00\nduration: 2.480s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\t2025-10-30 21:27:14.068087+00:00\n+++ C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\t2025-10-31 02:54:21.502365+00:00\n@@ -74,11 +74,13 @@\n     result = run(payload)\n     assert result[\"status\"] == \"success\"\n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\nwould reformat C:\\x_runner_x\\x_make_contract_validators_x\\x_cls_make_contract_validators_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n2 files would be reformatted, 2 files would be left unchanged.",
            "repo": "x_make_contract_validators_x",
            "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\nwould reformat C:\\x_runner_x\\x_make_contract_validators_x\\x_cls_make_contract_validators_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n2 files would be reformatted, 2 files would be left unchanged.",
            "stdout_preview": "--- C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\t2025-10-30 21:27:14.068087+00:00\n+++ C:\\x_runner_x\\x_make_contract_validators_x\\tests\\test_contract_validators.py\t2025-10-31 02:54:21.502365+00:00\n@@ -74,11 +74,13 @@\n     result = run(payload)\n     assert result[\"status\"] == \"success\"\n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_make_contract_validators_x (exit 1) cwd: C:\\x_runner_x\\x_make_contract_validators_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-31\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T02:54:23.625505+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_contract_validators_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_make_contract_validators_x",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_contract_validators_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_make_contract_validators_x",
                "duration_seconds": 1.4342120999936014,
                "ended_at": "2025-10-31T02:54:23.625505+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/test_contract_validators.py",
                    "x_cls_make_contract_validators_x.py"
                ],
                "repo": "x_make_contract_validators_x",
                "repo_hash": "e8db2f7cca24a74340066abe9642258fa0fac4b8ed8d1b017f46edde45b07bbf",
                "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
                "started_at": "2025-10-31T02:54:22.192809+00:00",
                "stderr": "",
                "stdout": "x_cls_make_contract_validators_x.py:30: error: Returning Any from function declared to return \"type[_DraftValidatorProtocol]\"  [no-any-return]\nx_cls_make_contract_validators_x.py:30: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:91: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nx_cls_make_contract_validators_x.py:92: error: Expression type contains \"Any\" (has type \"tuple[Any, ...]\")  [misc]\nx_cls_make_contract_validators_x.py:92: error: Expression type contains \"Any\" (has type \"Any | Iterable[Any]\")  [misc]\nx_cls_make_contract_validators_x.py:93: error: Expression type contains \"Any\" (has type \"tuple[Any, ...]\")  [misc]\nx_cls_make_contract_validators_x.py:93: error: Expression type contains \"Any\" (has type \"Any | Iterable[Any]\")  [misc]\nx_cls_make_contract_validators_x.py:94: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nx_cls_make_contract_validators_x.py:94: error: Expression type contains \"Any\" (has type \"tuple[Any, ...]\")  [misc]\nx_cls_make_contract_validators_x.py:142: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:143: error: Returning Any from function declared to return \"Mapping[str, object]\"  [no-any-return]\nx_cls_make_contract_validators_x.py:143: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:152: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:155: error: Explicit \"Any\" is not allowed  [explicit-any]\nx_cls_make_contract_validators_x.py:157: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:158: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:160: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:172: error: Expression type contains \"Any\" (has type \"dict[str, Any]\")  [misc]\nx_cls_make_contract_validators_x.py:173: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:174: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:178: error: Expression has type \"Any\"  [misc]\ntests\\test_contract_validators.py:23: error: Unused \"type: ignore\" comment  [unused-ignore]\ntests\\test_contract_validators.py:83: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\ntests\\test_contract_validators.py:111: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\ntests\\test_contract_validators.py:120: error: Expression has type \"Any\"  [misc]\ntests\\test_contract_validators.py:121: error: Expression has type \"Any\"  [misc]\ntests\\test_contract_validators.py:128: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\ntests\\test_contract_validators.py:137: error: Expression has type \"Any\"  [misc]\ntests\\test_contract_validators.py:138: error: Expression has type \"Any\"  [misc]\ntests\\test_contract_validators.py:139: error: Expression has type \"Any\"  [misc]\nFound 30 errors in 2 files (checked 4 source files)\n",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 1",
            "message": "mypy failed for x_make_contract_validators_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_contract_validators_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_contract_validators_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T02:54:22.192809+00:00\nduration: 1.434s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\nx_cls_make_contract_validators_x.py:30: error: Returning Any from function declared to return \"type[_DraftValidatorProtocol]\"  [no-any-return]\nx_cls_make_contract_validators_x.py:30: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:91: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nx_cls_make_contract_validators_x.py:92: error: Expression type contains \"Any\" (has type \"tuple[Any, ...]\")  [misc]\nx_cls_make_contract_validators_x.py:92: error: Expression type contains \"Any\" (has type \"Any | Iterable[Any]\")  [misc]\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_contract_validators_x",
            "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
            "stderr_preview": null,
            "stdout_preview": "x_cls_make_contract_validators_x.py:30: error: Returning Any from function declared to return \"type[_DraftValidatorProtocol]\"  [no-any-return]\nx_cls_make_contract_validators_x.py:30: error: Expression has type \"Any\"  [misc]\nx_cls_make_contract_validators_x.py:91: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nx_cls_make_contract_validators_x.py:92: error: Expression type contains \"Any\" (has type \"tuple[Any, ...]\")  [misc]\nx_cls_make_contract_validators_x.py:92: error: Expression type contains \"Any\" (has type \"Any | Iterable[Any]\")  [misc]\n\u2026",
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_make_contract_validators_x (exit 1) cwd: C:\\x_runner_x\\x_make_contract_validators_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_contract_validators_x --strict --no-warn-unused-configs --show-e\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        },
        {
            "captured_at": "2025-10-31T02:54:22.187022+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_contract_validators_x",
                "duration_seconds": 0.23254449991509318,
                "ended_at": "2025-10-31T02:54:22.187022+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/test_contract_validators.py",
                    "x_cls_make_contract_validators_x.py"
                ],
                "repo": "x_make_contract_validators_x",
                "repo_hash": "e8db2f7cca24a74340066abe9642258fa0fac4b8ed8d1b017f46edde45b07bbf",
                "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
                "started_at": "2025-10-31T02:54:21.955709+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_contract_validators.py:4:21\n  |\n3 | import json\n4 | from pathlib import Path\n  |                     ^^^^\n5 | from typing import TYPE_CHECKING\n  |\nhelp: Move into type-checking block\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:53:5\n   |\n51 | def test_validate_payload_success(sample_schema: dict[str, object]) -> None:\n52 |     result = validate_payload({\"name\": \"Jess\", \"age\": 33}, sample_schema)\n53 |     assert result.success is True\n   |     ^^^^^^\n54 |     assert result.issues == ()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:54:5\n   |\n52 |     result = validate_payload({\"name\": \"Jess\", \"age\": 33}, sample_schema)\n53 |     assert result.success is True\n54 |     assert result.issues == ()\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:61:5\n   |\n59 |         validate_payload({\"age\": 10}, sample_schema)\n60 |     issues = exc_info.value.issues\n61 |     assert issues\n   |     ^^^^^^\n62 |     first = issues[0]\n63 |     assert \"is a required property\" in first.message\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:63:5\n   |\n61 |     assert issues\n62 |     first = issues[0]\n63 |     assert \"is a required property\" in first.message\n   |     ^^^^^^\n64 |     assert tuple(first.path) == ()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:64:5\n   |\n62 |     first = issues[0]\n63 |     assert \"is a required property\" in first.message\n64 |     assert tuple(first.path) == ()\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:75:5\n   |\n73 |     }\n74 |     result = run(payload)\n75 |     assert result[\"status\"] == \"success\"\n   |     ^^^^^^\n76 |     assert result[\"issues\"] == []\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:76:5\n   |\n74 |     result = run(payload)\n75 |     assert result[\"status\"] == \"success\"\n76 |     assert result[\"issues\"] == []\n   |     ^^^^^^\n   |\n\nE501 Line too long (90 > 88)\n  --> tests\\test_contract_validators.py:79:89\n   |\n79 | def test_run_payload_from_files(sample_schema: dict[str, object], tmp_path: Path) -> None:\n   |                                                                                         ^^\n80 |     schema_path = tmp_path / \"schema.json\"\n81 |     payload_path = tmp_path / \"payload.json\"\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:91:5\n   |\n89 |     }\n90 |     result = run(payload)\n91 |     assert result[\"status\"] == \"success\"\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:102:5\n    |\n100 |     }\n101 |     result = run(payload)\n102 |     assert result[\"status\"] == \"failure\"\n    |     ^^^^^^\n103 |     assert result[\"error_type\"] == \"payload\"\n104 |     assert result[\"issues\"]\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:103:5\n    |\n101 |     result = run(payload)\n102 |     assert result[\"status\"] == \"failure\"\n103 |     assert result[\"error_type\"] == \"payload\"\n    |     ^^^^^^\n104 |     assert result[\"issues\"]\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:104:5\n    |\n102 |     assert result[\"status\"] == \"failure\"\n103 |     assert result[\"error_type\"] == \"payload\"\n104 |     assert result[\"issues\"]\n    |     ^^^^^^\n    |\n\nE501 Line too long (108 > 88)\n   --> tests\\test_contract_validators.py:107:89\n    |\n107 | def test_cli_success(sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]) -> None:\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^\n108 |     schema_path = tmp_path / \"schema.json\"\n109 |     payload_path = tmp_path / \"payload.json\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:119:5\n    |\n117 |         \"--json\",\n118 |     ])\n119 |     assert exit_code == 0\n    |     ^^^^^^\n120 |     output = json.loads(capsys.readouterr().out)\n121 |     assert output[\"status\"] == \"success\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:121:5\n    |\n119 |     assert exit_code == 0\n120 |     output = json.loads(capsys.readouterr().out)\n121 |     assert output[\"status\"] == \"success\"\n    |     ^^^^^^\n    |\n\nE501 Line too long (108 > 88)\n   --> tests\\test_contract_validators.py:124:89\n    |\n124 | def test_cli_failure(sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]) -> None:\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^\n125 |     schema_path = tmp_path / \"schema.json\"\n126 |     payload_path = tmp_path / \"payload.json\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:136:5\n    |\n134 |         \"--json\",\n135 |     ])\n136 |     assert exit_code == 1\n    |     ^^^^^^\n137 |     output = json.loads(capsys.readouterr().out)\n138 |     assert output[\"status\"] == \"failure\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:138:5\n    |\n136 |     assert exit_code == 1\n137 |     output = json.loads(capsys.readouterr().out)\n138 |     assert output[\"status\"] == \"failure\"\n    |     ^^^^^^\n139 |     assert output[\"error_type\"] == \"payload\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:139:5\n    |\n137 |     output = json.loads(capsys.readouterr().out)\n138 |     assert output[\"status\"] == \"failure\"\n139 |     assert output[\"error_type\"] == \"payload\"\n    |     ^^^^^^\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:100:15\n    |\n 98 |     parameters_obj = payload.get(\"parameters\")\n 99 |     if not isinstance(parameters_obj, Mapping):\n100 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n101 |     schema = _resolve_schema(parameters_obj)\n102 |     try:\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:100:25\n    |\n 98 |     parameters_obj = payload.get(\"parameters\")\n 99 |     if not isinstance(parameters_obj, Mapping):\n100 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n101 |     schema = _resolve_schema(parameters_obj)\n102 |     try:\n    |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:137:19\n    |\n135 |         schema_obj = parameters[\"schema\"]\n136 |         if not isinstance(schema_obj, Mapping):\n137 |             raise TypeError(\"Inline schema must be a mapping\")\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |         return schema_obj\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:137:29\n    |\n135 |         schema_obj = parameters[\"schema\"]\n136 |         if not isinstance(schema_obj, Mapping):\n137 |             raise TypeError(\"Inline schema must be a mapping\")\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |         return schema_obj\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n    |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:141:15\n    |\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n140 |     if schema_path_obj is None:\n141 |         raise ValueError(\"Schema data must be provided via 'schema' or 'schema_path'\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n142 |     schema_data = _load_json(Path(str(schema_path_obj)), expect_mapping=True)\n143 |     return schema_data\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:141:26\n    |\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n140 |     if schema_path_obj is None:\n141 |         raise ValueError(\"Schema data must be provided via 'schema' or 'schema_path'\")\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n142 |     schema_data = _load_json(Path(str(schema_path_obj)), expect_mapping=True)\n143 |     return schema_data\n    |\nhelp: Assign to variable; remove string literal\n\nRET504 Unnecessary assignment to `schema_data` before `return` statement\n   --> x_cls_make_contract_validators_x.py:143:12\n    |\n141 |         raise ValueError(\"Schema data must be provided via 'schema' or 'schema_path'\")\n142 |     schema_data = _load_json(Path(str(schema_path_obj)), expect_mapping=True)\n143 |     return schema_data\n    |            ^^^^^^^^^^^\n    |\nhelp: Remove unnecessary assignment\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:151:15\n    |\n149 |     payload_path_obj = parameters.get(\"payload_path\")\n150 |     if payload_path_obj is None:\n151 |         raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n152 |     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:151:26\n    |\n149 |     payload_path_obj = parameters.get(\"payload_path\")\n150 |     if payload_path_obj is None:\n151 |         raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n152 |     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (89 > 88)\n   --> x_cls_make_contract_validators_x.py:151:89\n    |\n149 |     payload_path_obj = parameters.get(\"payload_path\")\n150 |     if payload_path_obj is None:\n151 |         raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n    |                                                                                         ^\n152 |     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `_load_json`\n   --> x_cls_make_contract_validators_x.py:155:56\n    |\n155 | def _load_json(path: Path, *, expect_mapping: bool) -> Any:\n    |                                                        ^^^\n156 |     with path.open(\"r\", encoding=\"utf-8\") as handle:\n157 |         data = json.load(handle)\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:159:15\n    |\n157 |         data = json.load(handle)\n158 |     if expect_mapping and not isinstance(data, Mapping):\n159 |         raise TypeError(\"JSON file must contain an object at the root\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n160 |     return data\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:159:25\n    |\n157 |         data = json.load(handle)\n158 |     if expect_mapping and not isinstance(data, Mapping):\n159 |         raise TypeError(\"JSON file must contain an object at the root\")\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n160 |     return data\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (91 > 88)\n   --> x_cls_make_contract_validators_x.py:164:89\n    |\n163 | def main(argv: Sequence[str] | None = None) -> int:\n164 |     parser = argparse.ArgumentParser(description=\"Validate JSON payloads against a schema\")\n    |                                                                                         ^^^\n165 |     parser.add_argument(\"--schema\", required=True, help=\"Path to JSON schema file\")\n166 |     parser.add_argument(\"--payload\", required=True, help=\"Path to JSON payload file\")\n    |\n\nFound 34 errors.\nNo fixes available (7 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_make_contract_validators_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_contract_validators_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T02:54:21.955709+00:00\nduration: 0.233s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_contract_validators.py:4:21\n  |\n3 | import json\n4 | from pathlib import Path\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_contract_validators_x",
            "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_contract_validators.py:4:21\n  |\n3 | import json\n4 | from pathlib import Path\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_make_contract_validators_x (exit 1) cwd: C:\\x_runner_x\\x_make_contract_validators_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T02:54:19.463622+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_contract_validators_x",
                "duration_seconds": 0.3744305999716744,
                "ended_at": "2025-10-31T02:54:19.463622+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/test_contract_validators.py",
                    "x_cls_make_contract_validators_x.py"
                ],
                "repo": "x_make_contract_validators_x",
                "repo_hash": "e8db2f7cca24a74340066abe9642258fa0fac4b8ed8d1b017f46edde45b07bbf",
                "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
                "started_at": "2025-10-31T02:54:19.089907+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_contract_validators.py:4:21\n  |\n3 | import json\n4 | from pathlib import Path\n  |                     ^^^^\n5 | from typing import TYPE_CHECKING\n  |\nhelp: Move into type-checking block\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:53:5\n   |\n51 | def test_validate_payload_success(sample_schema: dict[str, object]) -> None:\n52 |     result = validate_payload({\"name\": \"Jess\", \"age\": 33}, sample_schema)\n53 |     assert result.success is True\n   |     ^^^^^^\n54 |     assert result.issues == ()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:54:5\n   |\n52 |     result = validate_payload({\"name\": \"Jess\", \"age\": 33}, sample_schema)\n53 |     assert result.success is True\n54 |     assert result.issues == ()\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:61:5\n   |\n59 |         validate_payload({\"age\": 10}, sample_schema)\n60 |     issues = exc_info.value.issues\n61 |     assert issues\n   |     ^^^^^^\n62 |     first = issues[0]\n63 |     assert \"is a required property\" in first.message\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:63:5\n   |\n61 |     assert issues\n62 |     first = issues[0]\n63 |     assert \"is a required property\" in first.message\n   |     ^^^^^^\n64 |     assert tuple(first.path) == ()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:64:5\n   |\n62 |     first = issues[0]\n63 |     assert \"is a required property\" in first.message\n64 |     assert tuple(first.path) == ()\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:75:5\n   |\n73 |     }\n74 |     result = run(payload)\n75 |     assert result[\"status\"] == \"success\"\n   |     ^^^^^^\n76 |     assert result[\"issues\"] == []\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:76:5\n   |\n74 |     result = run(payload)\n75 |     assert result[\"status\"] == \"success\"\n76 |     assert result[\"issues\"] == []\n   |     ^^^^^^\n   |\n\nE501 Line too long (90 > 88)\n  --> tests\\test_contract_validators.py:79:89\n   |\n79 | def test_run_payload_from_files(sample_schema: dict[str, object], tmp_path: Path) -> None:\n   |                                                                                         ^^\n80 |     schema_path = tmp_path / \"schema.json\"\n81 |     payload_path = tmp_path / \"payload.json\"\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_contract_validators.py:91:5\n   |\n89 |     }\n90 |     result = run(payload)\n91 |     assert result[\"status\"] == \"success\"\n   |     ^^^^^^\n   |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:102:5\n    |\n100 |     }\n101 |     result = run(payload)\n102 |     assert result[\"status\"] == \"failure\"\n    |     ^^^^^^\n103 |     assert result[\"error_type\"] == \"payload\"\n104 |     assert result[\"issues\"]\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:103:5\n    |\n101 |     result = run(payload)\n102 |     assert result[\"status\"] == \"failure\"\n103 |     assert result[\"error_type\"] == \"payload\"\n    |     ^^^^^^\n104 |     assert result[\"issues\"]\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:104:5\n    |\n102 |     assert result[\"status\"] == \"failure\"\n103 |     assert result[\"error_type\"] == \"payload\"\n104 |     assert result[\"issues\"]\n    |     ^^^^^^\n    |\n\nE501 Line too long (108 > 88)\n   --> tests\\test_contract_validators.py:107:89\n    |\n107 | def test_cli_success(sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]) -> None:\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^\n108 |     schema_path = tmp_path / \"schema.json\"\n109 |     payload_path = tmp_path / \"payload.json\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:119:5\n    |\n117 |         \"--json\",\n118 |     ])\n119 |     assert exit_code == 0\n    |     ^^^^^^\n120 |     output = json.loads(capsys.readouterr().out)\n121 |     assert output[\"status\"] == \"success\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:121:5\n    |\n119 |     assert exit_code == 0\n120 |     output = json.loads(capsys.readouterr().out)\n121 |     assert output[\"status\"] == \"success\"\n    |     ^^^^^^\n    |\n\nE501 Line too long (108 > 88)\n   --> tests\\test_contract_validators.py:124:89\n    |\n124 | def test_cli_failure(sample_schema: dict[str, object], tmp_path: Path, capsys: CaptureFixture[str]) -> None:\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^\n125 |     schema_path = tmp_path / \"schema.json\"\n126 |     payload_path = tmp_path / \"payload.json\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:136:5\n    |\n134 |         \"--json\",\n135 |     ])\n136 |     assert exit_code == 1\n    |     ^^^^^^\n137 |     output = json.loads(capsys.readouterr().out)\n138 |     assert output[\"status\"] == \"failure\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:138:5\n    |\n136 |     assert exit_code == 1\n137 |     output = json.loads(capsys.readouterr().out)\n138 |     assert output[\"status\"] == \"failure\"\n    |     ^^^^^^\n139 |     assert output[\"error_type\"] == \"payload\"\n    |\n\nS101 Use of `assert` detected\n   --> tests\\test_contract_validators.py:139:5\n    |\n137 |     output = json.loads(capsys.readouterr().out)\n138 |     assert output[\"status\"] == \"failure\"\n139 |     assert output[\"error_type\"] == \"payload\"\n    |     ^^^^^^\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:100:15\n    |\n 98 |     parameters_obj = payload.get(\"parameters\")\n 99 |     if not isinstance(parameters_obj, Mapping):\n100 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n101 |     schema = _resolve_schema(parameters_obj)\n102 |     try:\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:100:25\n    |\n 98 |     parameters_obj = payload.get(\"parameters\")\n 99 |     if not isinstance(parameters_obj, Mapping):\n100 |         raise TypeError(\"Payload parameters must be a mapping\")\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n101 |     schema = _resolve_schema(parameters_obj)\n102 |     try:\n    |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:137:19\n    |\n135 |         schema_obj = parameters[\"schema\"]\n136 |         if not isinstance(schema_obj, Mapping):\n137 |             raise TypeError(\"Inline schema must be a mapping\")\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |         return schema_obj\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:137:29\n    |\n135 |         schema_obj = parameters[\"schema\"]\n136 |         if not isinstance(schema_obj, Mapping):\n137 |             raise TypeError(\"Inline schema must be a mapping\")\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n138 |         return schema_obj\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n    |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:141:15\n    |\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n140 |     if schema_path_obj is None:\n141 |         raise ValueError(\"Schema data must be provided via 'schema' or 'schema_path'\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n142 |     schema_data = _load_json(Path(str(schema_path_obj)), expect_mapping=True)\n143 |     return schema_data\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:141:26\n    |\n139 |     schema_path_obj = parameters.get(\"schema_path\")\n140 |     if schema_path_obj is None:\n141 |         raise ValueError(\"Schema data must be provided via 'schema' or 'schema_path'\")\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n142 |     schema_data = _load_json(Path(str(schema_path_obj)), expect_mapping=True)\n143 |     return schema_data\n    |\nhelp: Assign to variable; remove string literal\n\nRET504 Unnecessary assignment to `schema_data` before `return` statement\n   --> x_cls_make_contract_validators_x.py:143:12\n    |\n141 |         raise ValueError(\"Schema data must be provided via 'schema' or 'schema_path'\")\n142 |     schema_data = _load_json(Path(str(schema_path_obj)), expect_mapping=True)\n143 |     return schema_data\n    |            ^^^^^^^^^^^\n    |\nhelp: Remove unnecessary assignment\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:151:15\n    |\n149 |     payload_path_obj = parameters.get(\"payload_path\")\n150 |     if payload_path_obj is None:\n151 |         raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n152 |     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:151:26\n    |\n149 |     payload_path_obj = parameters.get(\"payload_path\")\n150 |     if payload_path_obj is None:\n151 |         raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n152 |     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (89 > 88)\n   --> x_cls_make_contract_validators_x.py:151:89\n    |\n149 |     payload_path_obj = parameters.get(\"payload_path\")\n150 |     if payload_path_obj is None:\n151 |         raise ValueError(\"Payload data must be provided via 'payload' or 'payload_path'\")\n    |                                                                                         ^\n152 |     return _load_json(Path(str(payload_path_obj)), expect_mapping=False)\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `_load_json`\n   --> x_cls_make_contract_validators_x.py:155:56\n    |\n155 | def _load_json(path: Path, *, expect_mapping: bool) -> Any:\n    |                                                        ^^^\n156 |     with path.open(\"r\", encoding=\"utf-8\") as handle:\n157 |         data = json.load(handle)\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_contract_validators_x.py:159:15\n    |\n157 |         data = json.load(handle)\n158 |     if expect_mapping and not isinstance(data, Mapping):\n159 |         raise TypeError(\"JSON file must contain an object at the root\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n160 |     return data\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_contract_validators_x.py:159:25\n    |\n157 |         data = json.load(handle)\n158 |     if expect_mapping and not isinstance(data, Mapping):\n159 |         raise TypeError(\"JSON file must contain an object at the root\")\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n160 |     return data\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (91 > 88)\n   --> x_cls_make_contract_validators_x.py:164:89\n    |\n163 | def main(argv: Sequence[str] | None = None) -> int:\n164 |     parser = argparse.ArgumentParser(description=\"Validate JSON payloads against a schema\")\n    |                                                                                         ^^^\n165 |     parser.add_argument(\"--schema\", required=True, help=\"Path to JSON schema file\")\n166 |     parser.add_argument(\"--payload\", required=True, help=\"Path to JSON payload file\")\n    |\n\nFound 34 errors.\nNo fixes available (7 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_make_contract_validators_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_contract_validators_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T02:54:19.089907+00:00\nduration: 0.374s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_contract_validators.py:4:21\n  |\n3 | import json\n4 | from pathlib import Path\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_contract_validators_x",
            "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_contract_validators.py:4:21\n  |\n3 | import json\n4 | from pathlib import Path\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_make_contract_validators_x (exit 1) cwd: C:\\x_runner_x\\x_make_contract_validators_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --ta\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:02:59.145210+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 2.0275482999859378,
                "ended_at": "2025-10-31T03:02:59.145210+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "44c8d291ab70b33c6407574cf202a754dd0dea7dcbd24954afc1453bc3b6ec75",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:02:57.117260+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_make_progress_board_x\\cli.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 4 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-30 21:29:12.888265+00:00\n+++ C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-31 03:02:58.762503+00:00\n@@ -25,11 +25,13 @@\n     return stages\n \n \n def main(argv: Sequence[str] | None = None) -> int:\n     parser = argparse.ArgumentParser(description=\"Launch the PySide6 progress board\")\n-    parser.add_argument(\"--snapshot\", required=True, help=\"Path to progress snapshot JSON\")\n+    parser.add_argument(\n+        \"--snapshot\", required=True, help=\"Path to progress snapshot JSON\"\n+    )\n     args = parser.parse_args(list(argv) if argv is not None else None)\n \n     snapshot_path = Path(args.snapshot).resolve()\n     definitions = _current_stage_layout(snapshot_path)\n     if not definitions:\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T03:02:57.117260+00:00\nduration: 2.028s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-30 21:29:12.888265+00:00\n+++ C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-31 03:02:58.762503+00:00\n@@ -25,11 +25,13 @@\n     return stages\n \n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_make_progress_board_x\\cli.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 4 files would be left unchanged.",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_make_progress_board_x\\cli.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 4 files would be left unchanged.",
            "stdout_preview": "--- C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-30 21:29:12.888265+00:00\n+++ C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-31 03:02:58.762503+00:00\n@@ -25,11 +25,13 @@\n     return stages\n \n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-31T03:02:57.\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T03:03:01.171417+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_make_progress_board_x",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 1.5964372999733314,
                "ended_at": "2025-10-31T03:03:01.171417+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "44c8d291ab70b33c6407574cf202a754dd0dea7dcbd24954afc1453bc3b6ec75",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:02:59.576399+00:00",
                "stderr": "",
                "stdout": "progress_board_widget.py:21: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:21: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:22: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:22: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:23: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:23: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:25: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:26: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:27: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:51: error: Class cannot subclass \"QWidget\" (has type \"Any\")  [misc]\nprogress_board_widget.py:51: note: Error code \"misc\" not covered by \"type: ignore\" comment\nprogress_board_widget.py:54: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:76: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:77: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:78: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:79: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:82: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:84: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:85: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:86: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:87: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:88: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:90: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:91: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:93: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:94: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:95: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:97: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:98: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:99: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:100: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:102: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:103: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:104: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:106: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:108: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:109: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:110: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:112: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:113: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:114: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:115: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:117: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:118: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:119: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:122: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:123: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:124: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:126: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:127: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:129: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:130: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:132: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:133: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:135: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:136: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:137: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:140: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:141: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:142: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:143: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:144: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:145: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:148: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:149: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:150: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:151: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:152: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:158: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:163: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:167: error: Expression type contains \"Any\" (has type \"Any | dict[Never, Never]\")  [misc]\nprogress_board_widget.py:167: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:167: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\nprogress_board_widget.py:169: error: Expression type contains \"Any\" (has type \"Any | tuple[Any, Any]\")  [misc]\nprogress_board_widget.py:169: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:169: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:169: error: Expression type contains \"Any\" (has type \"Any | dict_items[Any, Any]\")  [misc]\nprogress_board_widget.py:170: error: Expression type contains \"Any\" (has type \"Any | None\")  [misc]\nprogress_board_widget.py:170: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:171: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:176: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:177: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:178: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:179: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:180: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:181: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:182: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:191: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:192: error: Expression type contains \"Any\" (has type \"Any | tuple[()]\")  [misc]\nprogress_board_widget.py:193: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:193: error: Expression type contains \"Any\" (has type \"Any | tuple[()]\")  [misc]\nprogress_board_widget.py:201: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:205: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:228: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:229: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:231: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:237: error: Expression type contains \"Any\" (has type \"Any | dict[Never, Never]\")  [misc]\nprogress_board_widget.py:237: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:237: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\nprogress_board_widget.py:238: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:247: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:249: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:254: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:259: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:262: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:263: error: Expression type contains \"Any\" (has type \"tuple[int, Any]\")  [misc]\nprogress_board_widget.py:263: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:263: error: Expression type contains \"Any\" (has type \"enumerate[Any]\")  [misc]\nprogress_board_widget.py:264: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:264: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:265: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:265: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:266: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:266: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:267: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:268: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:273: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:273: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:275: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:276: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:277: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:278: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:279: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:280: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:281: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:282: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:284: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:290: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:291: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:294: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:309: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:311: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:313: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:314: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:374: error: Returning Any from function declared to return \"dict[str, object] | None\"  [no-any-return]\nprogress_board_widget.py:374: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:383: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\nprogress_board_widget.py:392: error: Expression type contains \"Any\" (has type \"dict[str, object] | Any | bool | None\")  [misc]\nprogress_board_widget.py:392: error: Expression type contains \"Any\" (has type \"Any | bool\")  [misc]\nprogress_board_widget.py:392: error: Expression type contains \"Any\" (has type \"Any | None\")  [misc]\nprogress_board_widget.py:401: error: Expression type contains \"Any\" (has type \"tuple[str, Any | None]\")  [misc]\nprogress_board_widget.py:401: error: Expression type contains \"Any\" (has type \"Any | None\")  [misc]\nprogress_board_widget.py:423: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:425: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:426: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:429: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:430: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:437: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:438: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:441: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:443: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:445: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:448: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:449: error: Expression has type \"Any\"  [misc]\ncli.py:20: error: Expression has type \"Any\"  [misc]\ncli.py:20: error: Expression type contains \"Any\" (has type \"Any | dict[Never, Never]\")  [misc]\ncli.py:20: error: Expression type contains \"Any\" (has type \"Any | dict_values[Never, Never]\")  [misc]\ncli.py:21: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\ncli.py:21: error: Expression has type \"Any\"  [misc]\ncli.py:22: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\ncli.py:22: error: Expression has type \"Any\"  [misc]\ncli.py:33: error: Expression has type \"Any\"  [misc]\ntests\\test_progress_board.py:23: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]\ntests\\test_progress_board.py:30: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\ntests\\test_progress_board.py:30: error: Expression has type \"Any\"  [misc]\ntests\\test_progress_board.py:33: error: Expression type contains \"Any\" (has type \"Callable[[NamedArg(Path, 'snapshot_path'), NamedArg(Any, 'stage_definitions'), NamedArg(Event, 'worker_done_event')], None]\")  [misc]\ntests\\test_progress_board.py:67: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]\ntests\\test_progress_board.py:74: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\ntests\\test_progress_board.py:74: error: Expression has type \"Any\"  [misc]\ntests\\test_progress_board.py:78: error: Expression type contains \"Any\" (has type \"Callable[[NamedArg(Path, 'snapshot_path'), NamedArg(Any, 'stage_definitions'), NamedArg(Event, 'worker_done_event')], None]\")  [misc]\nFound 169 errors in 3 files (checked 6 source files)\n",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 1",
            "message": "mypy failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T03:02:59.576399+00:00\nduration: 1.596s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\nprogress_board_widget.py:21: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:21: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:22: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:22: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:23: error: Explicit \"Any\" is not allowed  [explicit-any]\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": null,
            "stdout_preview": "progress_board_widget.py:21: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:21: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:22: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:22: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:23: error: Explicit \"Any\" is not allowed  [explicit-any]\n\u2026",
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --wa\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        },
        {
            "captured_at": "2025-10-31T03:02:59.562081+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 0.42028510000091046,
                "ended_at": "2025-10-31T03:02:59.562081+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "44c8d291ab70b33c6407574cf202a754dd0dea7dcbd24954afc1453bc3b6ec75",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:02:59.150971+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n7 | from collections.abc import Sequence\n  |                             ^^^^^^^^\n8 | from pathlib import Path\n  |\nhelp: Move into type-checking block\n\nE501 Line too long (91 > 88)\n  --> cli.py:30:89\n   |\n28 | def main(argv: Sequence[str] | None = None) -> int:\n29 |     parser = argparse.ArgumentParser(description=\"Launch the PySide6 progress board\")\n30 |     parser.add_argument(\"--snapshot\", required=True, help=\"Path to progress snapshot JSON\")\n   |                                                                                         ^^^\n31 |     args = parser.parse_args(list(argv) if argv is not None else None)\n   |\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n  --> controller.py:8:21\n   |\n 6 | from collections.abc import Callable, Sequence\n 7 | from dataclasses import dataclass\n 8 | from pathlib import Path\n   |                     ^^^^\n 9 |\n10 | from x_make_progress_board_x.progress_board_widget import run_progress_board\n   |\nhelp: Move into type-checking block\n\nN802 Function name `setText` should be lowercase\n  --> progress_board_widget.py:42:9\n   |\n41 | class _ChecklistItem(Protocol):\n42 |     def setText(self, text: str) -> None: ...\n   |         ^^^^^^^\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |\n\nN802 Function name `setCheckState` should be lowercase\n  --> progress_board_widget.py:44:9\n   |\n42 |     def setText(self, text: str) -> None: ...\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |         ^^^^^^^^^^^^^\n   |\n\nINP001 File `tests\\test_progress_board.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> tests\\test_progress_board.py:1:1\n\nTC003 Move standard library import `threading` into a type-checking block\n --> tests\\test_progress_board.py:4:8\n  |\n3 | import json\n4 | import threading\n  |        ^^^^^^^^^\n5 | from pathlib import Path\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_progress_board.py:5:21\n  |\n3 | import json\n4 | import threading\n5 | from pathlib import Path\n  |                     ^^^^\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:26:9\n   |\n24 |         *,\n25 |         snapshot_path: Path,\n26 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n27 |         worker_done_event: threading.Event,\n28 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:39:9\n   |\n37 |     def worker(event: threading.Event) -> None:\n38 |         worker_called.append(True)\n39 |         assert event.is_set() is False\n   |         ^^^^^^\n40 |         event.set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:48:5\n   |\n46 |     )\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n   |     ^^^^^^\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:49:5\n   |\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n   |     ^^^^^^\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:50:5\n   |\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:51:5\n   |\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n   |\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:70:9\n   |\n68 |         *,\n69 |         snapshot_path: Path,\n70 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n71 |         worker_done_event: threading.Event,\n72 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:81:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n   |     ^^^^^^\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:82:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:83:5\n   |\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:85:5\n   |\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |     ^^^^^^\n   |\n\nFound 19 errors.\nNo fixes available (4 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:02:59.150971+00:00\nduration: 0.420s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version p\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:02:57.105110+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 0.38090609991922975,
                "ended_at": "2025-10-31T03:02:57.105110+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "44c8d291ab70b33c6407574cf202a754dd0dea7dcbd24954afc1453bc3b6ec75",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:02:56.730077+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n7 | from collections.abc import Sequence\n  |                             ^^^^^^^^\n8 | from pathlib import Path\n  |\nhelp: Move into type-checking block\n\nE501 Line too long (91 > 88)\n  --> cli.py:30:89\n   |\n28 | def main(argv: Sequence[str] | None = None) -> int:\n29 |     parser = argparse.ArgumentParser(description=\"Launch the PySide6 progress board\")\n30 |     parser.add_argument(\"--snapshot\", required=True, help=\"Path to progress snapshot JSON\")\n   |                                                                                         ^^^\n31 |     args = parser.parse_args(list(argv) if argv is not None else None)\n   |\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n  --> controller.py:8:21\n   |\n 6 | from collections.abc import Callable, Sequence\n 7 | from dataclasses import dataclass\n 8 | from pathlib import Path\n   |                     ^^^^\n 9 |\n10 | from x_make_progress_board_x.progress_board_widget import run_progress_board\n   |\nhelp: Move into type-checking block\n\nN802 Function name `setText` should be lowercase\n  --> progress_board_widget.py:42:9\n   |\n41 | class _ChecklistItem(Protocol):\n42 |     def setText(self, text: str) -> None: ...\n   |         ^^^^^^^\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |\n\nN802 Function name `setCheckState` should be lowercase\n  --> progress_board_widget.py:44:9\n   |\n42 |     def setText(self, text: str) -> None: ...\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |         ^^^^^^^^^^^^^\n   |\n\nINP001 File `tests\\test_progress_board.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> tests\\test_progress_board.py:1:1\n\nTC003 Move standard library import `threading` into a type-checking block\n --> tests\\test_progress_board.py:4:8\n  |\n3 | import json\n4 | import threading\n  |        ^^^^^^^^^\n5 | from pathlib import Path\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_progress_board.py:5:21\n  |\n3 | import json\n4 | import threading\n5 | from pathlib import Path\n  |                     ^^^^\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:26:9\n   |\n24 |         *,\n25 |         snapshot_path: Path,\n26 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n27 |         worker_done_event: threading.Event,\n28 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:39:9\n   |\n37 |     def worker(event: threading.Event) -> None:\n38 |         worker_called.append(True)\n39 |         assert event.is_set() is False\n   |         ^^^^^^\n40 |         event.set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:48:5\n   |\n46 |     )\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n   |     ^^^^^^\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:49:5\n   |\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n   |     ^^^^^^\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:50:5\n   |\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:51:5\n   |\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n   |\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:70:9\n   |\n68 |         *,\n69 |         snapshot_path: Path,\n70 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n71 |         worker_done_event: threading.Event,\n72 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:81:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n   |     ^^^^^^\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:82:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:83:5\n   |\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:85:5\n   |\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |     ^^^^^^\n   |\n\nFound 19 errors.\nNo fixes available (4 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:02:56.730077+00:00\nduration: 0.381s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-versi\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:04:39.009269+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "duration_seconds": 2.3009638999355957,
                "ended_at": "2025-10-31T03:04:39.009269+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "__main__.py",
                    "json_contracts/__init__.py",
                    "tests/__init__.py",
                    "tests/test_json_contracts.py",
                    "tests/test_slack_dump_and_reset.py",
                    "x_cls_make_slack_dump_and_reset_x.py"
                ],
                "repo": "x_make_slack_dump_and_reset_z",
                "repo_hash": "97c89faae21deeb00d1aaaba2dbb5c82c1a407289dee8b53b96c3fb57fdf350f",
                "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "started_at": "2025-10-31T03:04:36.708275+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 6 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-30 18:16:19.336325+00:00\n+++ C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-31 03:04:38.696267+00:00\n@@ -886,11 +886,11 @@\n             raise RuntimeError(message)\n         return Path(archive_root_raw).expanduser().resolve()\n \n     @staticmethod\n     def _parse_channels(\n-        parameters_raw: Mapping[str, object]\n+        parameters_raw: Mapping[str, object],\n     ) -> list[str | Mapping[str, object]]:\n         channels_raw = parameters_raw.get(\"channels\")\n         if (\n             not isinstance(channels_raw, Sequence)\n             or isinstance(channels_raw, (str, bytes))\n@@ -947,13 +947,11 @@\n         if not archive_root.exists():\n             message = f\"Archive root does not exist: {archive_root}\"\n             raise FileNotFoundError(message)\n         subdirectories = [item for item in archive_root.iterdir() if item.is_dir()]\n         if not subdirectories:\n-            message = (\n-                f\"Archive root {archive_root} has no subdirectories to target\"\n-            )\n+            message = f\"Archive root {archive_root} has no subdirectories to target\"\n             raise FileNotFoundError(message)\n         return max(subdirectories, key=lambda item: item.stat().st_mtime)\n \n     @staticmethod\n     def _normalise_channel_identifier(\n@@ -1038,12 +1036,11 @@\n     if bool(parameters_obj.get(\"dry_run\", False)):\n         return\n \n     while True:\n         prompt = (\n-            \"Archive captured. Delete Slack messages and files after export?\"\n-            \" [y/N]: \"\n+            \"Archive captured. Delete Slack messages and files after export?\" \" [y/N]: \"\n         )\n         response = input(prompt).strip().lower()\n         if response in {\"y\", \"yes\"}:\n             print(\n                 \"Confirmed. Slack source will be purged post-export.\", file=sys.stderr\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_make_slack_dump_and_reset_z (exit 1)\ncwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T03:04:36.708275+00:00\nduration: 2.301s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-30 18:16:19.336325+00:00\n+++ C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-31 03:04:38.696267+00:00\n@@ -886,11 +886,11 @@\n             raise RuntimeError(message)\n         return Path(archive_root_raw).expanduser().resolve()\n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 6 files would be left unchanged.",
            "repo": "x_make_slack_dump_and_reset_z",
            "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 6 files would be left unchanged.",
            "stdout_preview": "--- C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-30 18:16:19.336325+00:00\n+++ C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-31 03:04:38.696267+00:00\n@@ -886,11 +886,11 @@\n             raise RuntimeError(message)\n         return Path(archive_root_raw).expanduser().resolve()\n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_make_slack_dump_and_reset_z (exit 1) cwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T03:04:40.574254+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_make_slack_dump_and_reset_z",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "duration_seconds": 1.4356089000357315,
                "ended_at": "2025-10-31T03:04:40.574254+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "__main__.py",
                    "json_contracts/__init__.py",
                    "tests/__init__.py",
                    "tests/test_json_contracts.py",
                    "tests/test_slack_dump_and_reset.py",
                    "x_cls_make_slack_dump_and_reset_x.py"
                ],
                "repo": "x_make_slack_dump_and_reset_z",
                "repo_hash": "97c89faae21deeb00d1aaaba2dbb5c82c1a407289dee8b53b96c3fb57fdf350f",
                "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "started_at": "2025-10-31T03:04:39.138612+00:00",
                "stderr": "",
                "stdout": "x_cls_make_slack_dump_and_reset_x.py:120: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_slack_dump_and_reset_x.py:676: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression type contains \"Any\" (has type \"Callable[[Any], Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1074: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1087: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1088: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1093: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1094: error: Expression has type \"Any\"  [misc]\nFound 9 errors in 1 file (checked 7 source files)\n",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 1",
            "message": "mypy failed for x_make_slack_dump_and_reset_z (exit 1)\ncwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T03:04:39.138612+00:00\nduration: 1.436s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\nx_cls_make_slack_dump_and_reset_x.py:120: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_slack_dump_and_reset_x.py:676: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression type contains \"Any\" (has type \"Callable[[Any], Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1074: error: Expression has type \"Any\"  [misc]\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_slack_dump_and_reset_z",
            "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
            "stderr_preview": null,
            "stdout_preview": "x_cls_make_slack_dump_and_reset_x.py:120: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_slack_dump_and_reset_x.py:676: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression type contains \"Any\" (has type \"Callable[[Any], Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1074: error: Expression has type \"Any\"  [misc]\n\u2026",
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_make_slack_dump_and_reset_z (exit 1) cwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --sho\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        }
    ],
    "generated_at": "2025-10-31T03:04:46.908890+00:00",
    "runtime": {
        "environment": {
            "PATH": "C:\\windows\\system32;C:\\windows;C:\\windows\\System32\\Wbem;C:\\windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\windows\\System32\\OpenSSH\\;C:\\Program Files\\Git\\cmd;C:\\Program Files\\HP\\HP One Agent;C:\\Users\\eye43\\AppData\\Local\\Programs\\Python\\Launcher\\;C:\\Users\\eye43\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\x_runner_x\\tools\\node-v20.11.1-win-x64\\node-v20.11.1-win-x64;C:\\x_runner_x\\tools\\node-v20.11.1-win-x64\\node-v20.11.1-win-x64\\node_modules\\npm\\bin;C:\\Users\\eye43\\AppData\\Local\\Programs\\Python\\Python314\\Scripts;c:\\Users\\eye43\\.vscode\\extensions\\ms-python.debugpy-2025.14.1-win32-x64\\bundled\\scripts\\noConfigScripts;c:\\Users\\eye43\\AppData\\Roaming\\Code\\User\\globalStorage\\github.copilot-chat\\debugCommand"
        },
        "platform": "Windows-11-10.0.26100-SP0",
        "python_executable": "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
        "python_version": "3.12.6 (main, Sep  9 2024, 20:50:27) [MSC v.1929 64 bit (AMD64)]",
        "run_completed_at": "2025-10-31T03:04:46.908170+00:00",
        "run_started_at": "2025-10-31T02:50:08.079026+00:00",
        "workspace_root": "C:\\x_runner_x"
    },
    "schema_version": "1.0",
    "summary": {
        "overall_stats": {
            "cache_hits": 47,
            "cache_misses": 63,
            "failed_tools": 19,
            "had_failures": true,
            "total_tools_run": 110
        },
        "repos": {
            "x_0_make_all_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "3d08f2892292a11d9213075756089aad00151833789b1437bb61c457ef33c63d",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_0_make_ppnw_dot_ai_venvs_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "aab97556cecaa26d836e8f909d66208e47f10f98842760b68016079475cac8d7",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_0_make_ppnw_dot_ai_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "c1b566a56a1c883224faad8ec588d3747af3502ecb10cd2db8ce4377014230f9",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_legatus_acta_schedae_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "4b065b576a3d07791a9f9b3b90b25b50e1d03a13616ff9b0de9342708c8bd753",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_legatus_capsula_calculus_x": {
                "cached": 2,
                "failed": 0,
                "repo_hash": "4bcde11d4f4e764c44772232ee06cc7ffdb5de7d70358d4235b11375078a4a33",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_legatus_tactica_impetus_x": {
                "cached": 0,
                "failed": 5,
                "repo_hash": "db602e95828154e4c20192d7beb007d0453c618584a7e426ebbab2abd8401e37",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 2,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_cli_scaffolder_x": {
                "cached": 0,
                "failed": 4,
                "repo_hash": "7d0d1c39b2d7688950a11ebb63704b5a9ef9fb92e823250f7d0893bb378a5c56",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_common_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "36370f984177f8c11806f6dbdb63b91a88a9ff45ee453ba8de86f58dfcf7ad68",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_contract_validators_x": {
                "cached": 0,
                "failed": 4,
                "repo_hash": "e8db2f7cca24a74340066abe9642258fa0fac4b8ed8d1b017f46edde45b07bbf",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_github_clones_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "bdf6dbbcebbebb05082069f6300ac9c904b4b0df12e8a7a870901c2ba4b12048",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_github_visitor_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "5708a35ed07d51fc98b586ded54f33893b992fc550601cd5c5833e08d58b59c8",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_graphviz_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "11f50bd2173049d7ebe9b1f6b91ff25cf63c1d4edf531c7f098e1fbbbd380810",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_markdown_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "ebfb021d8e9336f67c244fec5511d7e8321f46946d6865decf8c992288ffe0a7",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_mermaid_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "f0ad607723e8bb9f766b3a622bdc4c6fb4861e178d4df508223b7ac7e32716ab",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_persistent_env_var_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "a2d989a79377c86db138b35d6a6a5431d51f6f852333e86663a30620b4be14cd",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_pip_updates_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "64a99ee601c763d080b5d86f2fdaf067717eacdd1f5638799677812a7b08a2c1",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_progress_board_x": {
                "cached": 0,
                "failed": 4,
                "repo_hash": "44c8d291ab70b33c6407574cf202a754dd0dea7dcbd24954afc1453bc3b6ec75",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_py_mod_sideload_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "e73d5c6b1f833a1bc453d3ce7914f2327f8f19e000001b529b78501356825512",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_py_venv_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "b6cdc9357da6d257d5d6c635b287d0f70d57a3b72c937661963eb18bcadcb68d",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_pypi_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "0fb54933876253b89a5658d648d0b28c08279ed24c4e1563898e221c9befaa94",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_slack_dump_and_reset_z": {
                "cached": 0,
                "failed": 2,
                "repo_hash": "97c89faae21deeb00d1aaaba2dbb5c82c1a407289dee8b53b96c3fb57fdf350f",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_yahw_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "33756efd77e902ab6182399ad7985b466cbfbc76fdc267da9a54f7b892e944f2",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            }
        },
        "timestamp": "2025-10-31T03:04:46.908890+00:00",
        "total_repos": 22
    },
    "tool_versions": {
        "black": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6",
        "mypy": "mypy 1.18.2 (compiled: yes)",
        "pyright": "pyright 1.1.407",
        "ruff": "ruff 0.14.3"
    },
    "workspace_root": "C:\\x_runner_x"
}