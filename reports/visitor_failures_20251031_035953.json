{
    "failures": [
        {
            "captured_at": "2025-10-31T03:56:07.490157+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 1.8194705999922007,
                "ended_at": "2025-10-31T03:56:07.490157+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "60eec4632cb4ef6a48af31080c4315fd7e6ad7cb201d6276fedd8ae3bba43311",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T03:56:05.674670+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\main.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n6 files would be reformatted, 10 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:27:57.459385+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 03:56:06.999979+00:00\n@@ -12,11 +12,13 @@\n \n     def update_orientation(self, gravity, forward_axis):\n         self.gravity = gravity\n         self.forward_axis = features.normalize(forward_axis)\n         self.up_axis = features.normalize(tuple(-g for g in gravity))\n-        self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n+        self.lateral_axis = features.normalize(\n+            features.cross(self.up_axis, self.forward_axis)\n+        )\n \n     def classify(self, event):\n         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n \n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\t2025-10-31 02:27:57.463157+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\t2025-10-31 03:56:07.015278+00:00\n@@ -2,11 +2,21 @@\n \n from . import x_cls_features_imu_x as features\n \n \n class CalibrationResult:\n-    def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n+    def __init__(\n+        self,\n+        gravity,\n+        accel_noise,\n+        jerk_noise,\n+        omega_noise,\n+        forward_axis,\n+        accel_samples,\n+        jerk_samples,\n+        omega_samples,\n+    ):\n         self.gravity = gravity\n         self.accel_noise = accel_noise\n         self.jerk_noise = jerk_noise\n         self.omega_noise = omega_noise\n         self.forward_axis = forward_axis\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\t2025-10-31 02:53:40.820806+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\t2025-10-31 03:56:07.053425+00:00\n@@ -12,10 +12,11 @@\n \n \n if hasattr(time, \"sleep_ms\"):\n     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n else:  # pragma: no cover - CPython tooling\n+\n     def sleep_ms(ms: int) -> None:\n         time.sleep(ms / 1000.0)\n \n \n _DEFAULT_ADDR = 0x28\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\t2025-10-31 02:53:40.795012+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\t2025-10-31 03:56:07.075960+00:00\n@@ -72,15 +72,11 @@\n             if time.ticks_diff(ts_ms, self._last_event_ms) >= self.cfg[\"refractory_ms\"]:\n                 self._state = \"idle\"\n             else:\n                 return None\n \n-        trigger = (\n-            accel_mag >= a_thresh\n-            or jerk >= j_thresh\n-            or omega_mag >= o_thresh\n-        )\n+        trigger = accel_mag >= a_thresh or jerk >= j_thresh or omega_mag >= o_thresh\n \n         if self._state == \"idle\":\n             if trigger:\n                 self._candidate = {\n                     \"start_ms\": ts_ms,\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\t2025-10-31 02:53:40.813088+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\t2025-10-31 03:56:07.095308+00:00\n@@ -22,11 +22,13 @@\n class Display:\n     def __init__(self):\n         self.available = bool(st7789)\n         if not self.available:\n             return\n-        spi = SPI(1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19))\n+        spi = SPI(\n+            1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19)\n+        )\n         self._tft = st7789.ST7789(\n             spi,\n             135,\n             240,\n             reset=Pin(23, Pin.OUT),\n@@ -61,11 +63,13 @@\n         self._draw_text(font_big, 10, 10, f\"{int(counts):03d}\", _COLOR_GREEN)\n         self._draw_text(font_small, 140, 16, f\"{last_type.upper():>8}\", _COLOR_WHITE)\n         self._draw_text(font_small, 140, 40, f\"Conf {confidence:>4.2f}\", _COLOR_WHITE)\n         self._tft.fill_rect(0, 80, 240, 40, _COLOR_BLACK)\n         self._draw_text(font_small, 10, 86, f\"SPM {spm:>5.1f}\", _COLOR_YELLOW)\n-        self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n+        self._draw_text(\n+            font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW\n+        )\n \n     def show_status(self, message, success=True):\n         if not self.available:\n             return\n         color = _COLOR_GREEN if success else _COLOR_RED\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\main.py\t2025-10-31 02:53:40.801319+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\main.py\t2025-10-31 03:56:07.204928+00:00\n@@ -9,27 +9,30 @@\n \n \n if hasattr(time, \"sleep_ms\"):\n     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n else:  # pragma: no cover - CPython tooling\n+\n     def sleep_ms(ms):\n         time.sleep(ms / 1000.0)\n \n \n if hasattr(time, \"ticks_ms\"):\n     ticks_ms = time.ticks_ms  # type: ignore[attr-defined]\n     ticks_add = time.ticks_add  # type: ignore[attr-defined]\n     ticks_diff = time.ticks_diff  # type: ignore[attr-defined]\n else:  # pragma: no cover - CPython tooling\n+\n     def ticks_ms():\n         return int(time.time() * 1000)\n \n     def ticks_add(value, delta):\n         return value + delta\n \n     def ticks_diff(a, b):\n         return a - b\n+\n \n from lib import x_cls_cfg_x as cfg_mod\n from lib import x_cls_features_imu_x as features\n from lib.x_cls_calibrate_x import Calibrator\n from lib.x_cls_combo_segmenter_x import ComboSegmenter\n@@ -115,12 +118,20 @@\n \n     # Seed detector baselines with calibration samples\n     limit = len(calibrator.accel_samples)\n     for idx in range(limit):\n         accel = calibrator.accel_samples[idx]\n-        jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n-        omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n+        jerk = (\n+            calibrator.jerk_samples[idx]\n+            if idx < len(calibrator.jerk_samples)\n+            else jerk_noise\n+        )\n+        omega = (\n+            calibrator.omega_samples[idx]\n+            if idx < len(calibrator.omega_samples)\n+            else omega_noise\n+        )\n         detector.ingest_idle(accel, jerk, omega)\n \n     running = False\n     session_id = 0\n     log_timer = SimpleTimer(2000)\n@@ -151,11 +162,13 @@\n         dt_s = dt_ms / 1000.0 if dt_ms > 0 else sample_period / 1000.0\n         jerk = features.jerk(last_accel, linear, dt_s)\n         last_accel = linear\n \n         if not running:\n-            detector.ingest_idle(features.magnitude(linear), jerk, features.magnitude(gyro))\n+            detector.ingest_idle(\n+                features.magnitude(linear), jerk, features.magnitude(gyro)\n+            )\n \n         if start_button.pressed():\n             running = not running\n             if running:\n                 session_id += 1\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T03:56:05.674670+00:00\nduration: 1.819s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:27:57.459385+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 03:56:06.999979+00:00\n@@ -12,11 +12,13 @@\n \n     def update_orientation(self, gravity, forward_axis):\n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\n\u2026",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_calibrate_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_sensor_bno055_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\nwould reformat C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\n\u2026",
            "stdout_preview": "--- C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 02:27:57.459385+00:00\n+++ C:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_classifier_x.py\t2025-10-31 03:56:06.999979+00:00\n@@ -12,11 +12,13 @@\n \n     def update_orientation(self, gravity, forward_axis):\n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-31T0\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T03:56:08.181502+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_legatus_tactica_impetus_x",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 0.5083193000173196,
                "ended_at": "2025-10-31T03:56:08.181502+00:00",
                "exit": 2,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "60eec4632cb4ef6a48af31080c4315fd7e6ad7cb201d6276fedd8ae3bba43311",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T03:56:07.673441+00:00",
                "stderr": "Package 'x_legatus_tactica_impetus_x' cannot be type checked due to missing py.typed marker. See https://mypy.readthedocs.io/en/stable/installed_packages.html for more details\n",
                "stdout": "",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 2",
            "message": "mypy failed for x_legatus_tactica_impetus_x (exit 2)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T03:56:07.673441+00:00\nduration: 0.508s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\n<empty>\nstderr:\nPackage 'x_legatus_tactica_impetus_x' cannot be type checked due to missing py.typed marker. See https://mypy.readthedocs.io/en/stable/installed_packages.html for more details",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": "Package 'x_legatus_tactica_impetus_x' cannot be type checked due to missing py.typed marker. See https://mypy.readthedocs.io/en/stable/installed_packages.html for more details",
            "stdout_preview": null,
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_legatus_tactica_impetus_x (exit 2) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_legatus_tactica_impetus_x --strict --no-warn-unused-configs --show-erro\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        },
        {
            "captured_at": "2025-10-31T03:56:11.675414+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "pyright",
                    ".",
                    "--level",
                    "error"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 3.490840599988587,
                "ended_at": "2025-10-31T03:56:11.675414+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "60eec4632cb4ef6a48af31080c4315fd7e6ad7cb201d6276fedd8ae3bba43311",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T03:56:08.184545+00:00",
                "stderr": "",
                "stdout": "c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:21 - error: \"ticks_add\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:36 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:43 - error: \"ticks_diff\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:69 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:37:14 - error: \"sleep_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:44:10 - error: \"sleep_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_comm_uart_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_comm_uart_x.py:22:17 - error: \"stdout\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_comm_uart_x.py:23:17 - error: \"stdout\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:27:15 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:27:68 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:27:82 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:28:28 - error: \"ST7789\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:32:19 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:32:31 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:33:16 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:33:28 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:34:16 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:34:27 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:37:9 - error: Object of type \"None\" cannot be called (reportOptionalCall)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_display_tft_x.py:37:20 - error: \"OUT\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:90:20 - error: \"ticks_ms\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:92:31 - error: \"ticks_add\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:94:17 - error: \"ticks_diff\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_filters_x.py:95:31 - error: \"ticks_add\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py:72:21 - error: \"ticks_diff\" is not a known attribute of module \"time\" (reportAttributeAccessIssue)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py:105:58 - error: Argument of type \"complex | float\" cannot be assigned to parameter \"arg2\" of type \"SupportsRichComparisonT@max\" in function \"max\"\n  \u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderLT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__lt__\" is not present\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderGT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__gt__\" is not present (reportArgumentType)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\lib\\x_cls_punch_detector_x.py:106:58 - error: Argument of type \"complex | float\" cannot be assigned to parameter \"arg2\" of type \"SupportsRichComparisonT@max\" in function \"max\"\n  \u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex | float\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0Type \"complex\" is not assignable to type \"SupportsRichComparison\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderLT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__lt__\" is not present\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"complex\" is incompatible with protocol \"SupportsDunderGT[Any]\"\n  \u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\u00c2\u00a0\"__gt__\" is not present (reportArgumentType)\n27 errors, 0 warnings, 0 informations\n",
                "tool": "pyright",
                "tool_module": "pyright",
                "tool_version": "pyright 1.1.407"
            },
            "exit": "exit 1",
            "message": "pyright failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error\nstarted_at: 2025-10-31T03:56:08.184545+00:00\nduration: 3.491s\ntool_version: pyright 1.1.407\nstdout:\nc:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:21 - error: \"ticks_add\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:36 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:43 - error: \"ticks_diff\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:69 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n\u2026\nstderr:\n<empty>",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": null,
            "stdout_preview": "c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:21 - error: \"ticks_add\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:35:36 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:43 - error: \"ticks_diff\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n  c:\\x_runner_x\\x_legatus_tactica_impetus_x\\firmware\\boot.py:36:69 - error: \"ticks_ms\" is not a known attribute of \"None\" (reportOptionalMemberAccess)\n\u2026",
            "suggested_action": "Investigate",
            "summary": "pyright failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m pyright . --level error started_at: 2025-10-31T03:56:08.184545+00:00 duration: 3.491s\u2026",
            "tool": "pyright",
            "tool_version": "pyright 1.1.407"
        },
        {
            "captured_at": "2025-10-31T03:56:07.644868+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 0.1512036999920383,
                "ended_at": "2025-10-31T03:56:07.644868+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "60eec4632cb4ef6a48af31080c4315fd7e6ad7cb201d6276fedd8ae3bba43311",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T03:56:07.501057+00:00",
                "stderr": "",
                "stdout": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:9:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:10:27\n   |\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |                           ^^^^^^^^^^^^^^\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:12:21\n   |\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:13:21\n   |\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:14:18\n   |\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n15 |\n16 | SAFE_MODE_PIN = 0  # Button B (GPIO0) used to skip Wi-Fi when held\n   |\n\nPLC0415 `import` should be at the top-level of a file\n  --> firmware\\boot.py:24:9\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:24:45\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |                                             ^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:25:12\n   |\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n25 |     except Exception:  # secrets missing; stay offline\n   |            ^^^^^^^^^\n26 |         return\n   |\n\nFBT003 Boolean positional value in function call\n  --> firmware\\boot.py:30:21\n   |\n28 |     wlan = network.WLAN(network.STA_IF)\n29 |     if not wlan.active():\n30 |         wlan.active(True)\n   |                     ^^^^\n31 |     if wlan.isconnected():\n32 |         return\n   |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n  --> firmware\\boot.py:49:5\n   |\n48 |   if machine is not None:\n49 | /     try:\n50 | |         machine.freq(240_000_000)\n51 | |     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\boot.py:51:5\n   |\n49 |       try:\n50 |           machine.freq(240_000_000)\n51 | /     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:51:12\n   |\n49 |     try:\n50 |         machine.freq(240_000_000)\n51 |     except Exception:\n   |            ^^^^^^^^^\n52 |         pass\n   |\n\nPLR0913 Too many arguments in function definition (8 > 5)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:24\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                        ^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:33\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                 ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:46\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                              ^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:58\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                          ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `forward_axis`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:71\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                       ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:85\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                     ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nE501 Line too long (128 > 88)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:89\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:100\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                    ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:114\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                                  ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:9\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |         ^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `sample_target`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:24\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |                        ^^^^^^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\n\nANN201 Missing return type annotation for public function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:9\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |         ^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:19\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                   ^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:26\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                          ^^^^^^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:40\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                        ^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:49\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                                 ^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:53:38\n   |\n51 |         self._jerk_stats.add(jerk)\n52 |         self._omega_stats.add(omega_mag)\n53 |         if len(self.accel_samples) < 512:\n   |                                      ^^^\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:55:37\n   |\n53 |         if len(self.accel_samples) < 512:\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |                                     ^^^\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:57:38\n   |\n55 |         if len(self.jerk_samples) < 512:\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |                                      ^^^\n58 |             self.omega_samples.append(omega_mag)\n   |\n\nANN201 Missing return type annotation for public function `done`\n  --> firmware\\lib\\x_cls_calibrate_x.py:60:9\n   |\n58 |             self.omega_samples.append(omega_mag)\n59 |\n60 |     def done(self):\n   |         ^^^^\n61 |         return self._count >= self._target\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `result`\n  --> firmware\\lib\\x_cls_calibrate_x.py:63:9\n   |\n61 |         return self._count >= self._target\n62 |\n63 |     def result(self):\n   |         ^^^^^^\n64 |         if self._count == 0:\n65 |             return None\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:85:9\n   |\n84 | class _RunningStats:\n85 |     def __init__(self):\n   |         ^^^^^^^^\n86 |         self.count = 0\n87 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:9\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |         ^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:19\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |                   ^^^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_calibrate_x.py:96:9\n   |\n94 |         self.ssq += delta * (value - self.mean)\n95 |\n96 |     def std(self):\n   |         ^^^\n97 |         if self.count < 2:\n98 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:97:25\n   |\n96 |     def std(self):\n97 |         if self.count < 2:\n   |                         ^\n98 |             return 0.0\n99 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_cfg_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_cfg_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover - CPython tooling\n11 |     import os\n   |\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:38:14\n   |\n36 |     cfg = DEFAULT_CFG.copy()\n37 |     try:\n38 |         with open(_CFG_PATH) as handle:\n   |              ^^^^\n39 |             user_cfg = json.load(handle)\n40 |         if isinstance(user_cfg, dict):\n   |\nhelp: Replace with `Path.open()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:52:14\n   |\n50 |     try:\n51 |         tmp_path = _CFG_PATH + \".tmp\"\n52 |         with open(tmp_path, \"w\") as handle:\n   |              ^^^^\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |\nhelp: Replace with `Path.open()`\n\nPTH104 `os.rename()` should be replaced by `Path.rename()`\n  --> firmware\\lib\\x_cls_cfg_x.py:54:9\n   |\n52 |         with open(tmp_path, \"w\") as handle:\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |         ^^^^^^^^^\n55 |     except OSError:\n56 |         pass\n   |\nhelp: Replace with `Path(...).rename(...)`\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:9\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |         ^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `combo_gap_ms`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:24\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |                        ^^^^^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:9:9\n   |\n 7 |         self.reset()\n 8 |\n 9 |     def reset(self):\n   |         ^^^^^\n10 |         self._current_combo_id = 0\n11 |         self._last_ts = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `assign`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:9\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |         ^^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:22\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |                      ^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_comm_uart_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_comm_uart_x.py:11:17\n   |\n 9 |     import sys\n10 | except ImportError:  # pragma: no cover\n11 |     sys = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:9\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |         ^^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\nhelp: Add return type annotation: `None`\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN001 Missing type annotation for function argument `enabled`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN201 Missing return type annotation for public function `emit`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:9\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |         ^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `payload`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:20\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |                    ^^^^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:9\n   |\n22 |               sys.stdout.write(json.dumps(payload))\n23 |               sys.stdout.write(\"\\n\")\n24 | /         except Exception:\n25 | |             pass\n   | |________________^\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:16\n   |\n22 |             sys.stdout.write(json.dumps(payload))\n23 |             sys.stdout.write(\"\\n\")\n24 |         except Exception:\n   |                ^^^^^^^^^\n25 |             pass\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_datalogger_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:11:16\n   |\n 9 |     import uos as os  # type: ignore\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |                ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:9\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |         ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `root_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:24\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |                        ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\n\nANN202 Missing return type annotation for private function `_ensure_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:21:9\n   |\n19 |         self._session_path = None\n20 |\n21 |     def _ensure_dir(self):\n   |         ^^^^^^^^^^^\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |\nhelp: Add return type annotation: `None`\n\nSIM105 Use `contextlib.suppress(OSError)` instead of `try`-`except`-`pass`\n  --> firmware\\lib\\x_cls_datalogger_x.py:22:9\n   |\n21 |       def _ensure_dir(self):\n22 | /         try:\n23 | |             os.mkdir(self.root_dir)\n24 | |         except OSError:\n25 | |             pass\n   | |________________^\n26 |\n27 |       def start_session(self, session_id):\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError): ...`\n\nPTH102 `os.mkdir()` should be replaced by `Path.mkdir()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:23:13\n   |\n21 |     def _ensure_dir(self):\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |             ^^^^^^^^\n24 |         except OSError:\n25 |             pass\n   |\nhelp: Replace with `Path(...).mkdir()`\n\nANN201 Missing return type annotation for public function `start_session`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:9\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |         ^^^^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `session_id`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:29\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |                             ^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\n\nUP031 Use format specifiers instead of percent format\n  --> firmware\\lib\\x_cls_datalogger_x.py:28:30\n   |\n27 |     def start_session(self, session_id):\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n29 |         self._buffer = []\n   |\nhelp: Replace with format specifiers\n\nANN201 Missing return type annotation for public function `append`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:9\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |         ^^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:22\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |                      ^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `256` with a constant variable\n  --> firmware\\lib\\x_cls_datalogger_x.py:32:32\n   |\n31 |     def append(self, event):\n32 |         if len(self._buffer) > 256:\n   |                                ^^^\n33 |             self.flush()\n34 |         self._buffer.append(event)\n   |\n\nANN201 Missing return type annotation for public function `flush`\n  --> firmware\\lib\\x_cls_datalogger_x.py:36:9\n   |\n34 |         self._buffer.append(event)\n35 |\n36 |     def flush(self):\n   |         ^^^^^\n37 |         if not self._buffer or self._session_path is None:\n38 |             return\n   |\nhelp: Add return type annotation: `None`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:40:18\n   |\n38 |             return\n39 |         try:\n40 |             with open(self._session_path, \"a\") as handle:\n   |                  ^^^^\n41 |                 for item in self._buffer:\n42 |                     handle.write(json.dumps(item))\n   |\nhelp: Replace with `Path.open()`\n\nANN201 Missing return type annotation for public function `close`\n  --> firmware\\lib\\x_cls_datalogger_x.py:48:9\n   |\n46 |         self._buffer = []\n47 |\n48 |     def close(self):\n   |         ^^^^^\n49 |         self.flush()\n50 |         self._session_path = None\n   |\nhelp: Add return type annotation: `None`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:4:20\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n  |                    ^^^^^^^^^^^^^^\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:5:36\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:6:36\n  |\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n7 |     from machine import SPI, Pin  # type: ignore\n8 | except ImportError:  # pragma: no cover - running under CPython\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:7:35\n  |\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |                                   ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - running under CPython\n9 |     st7789 = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:9:20\n   |\n 7 |     from machine import SPI, Pin  # type: ignore\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:10:24\n   |\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n   |                        ^^^^^^^^^^^^^^\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:11:22\n   |\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |                      ^^^^^^^^^^^^^^\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:12:17\n   |\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:13:17\n   |\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n14 |\n15 | _COLOR_BLACK = 0x0000\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_display_tft_x.py:23:9\n   |\n22 | class Display:\n23 |     def __init__(self):\n   |         ^^^^^^^^\n24 |         self.available = bool(st7789)\n25 |         if not self.available:\n   |\nhelp: Add return type annotation: `None`\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:27:89\n   |\n25 |         if not self.available:\n26 |             return\n27 |         spi = SPI(1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19))\n   |                                                                                         ^\n28 |         self._tft = st7789.ST7789(\n29 |             spi,\n   |\n\nANN201 Missing return type annotation for public function `clear`\n  --> firmware\\lib\\x_cls_display_tft_x.py:45:9\n   |\n43 |         self._punch_count = 0\n44 |\n45 |     def clear(self):\n   |         ^^^^^\n46 |         if not self.available:\n47 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `show_idle`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:9\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |         ^^^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:25\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |                         ^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\n\nANN201 Missing return type annotation for public function `show_session`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:9\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |         ^^^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `counts`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:31\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                               ^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `last_type`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:39\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                       ^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `confidence`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:50\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                  ^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `spm`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:62\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                              ^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `peak`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:67\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                                   ^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:66:89\n   |\n64 |         self._tft.fill_rect(0, 80, 240, 40, _COLOR_BLACK)\n65 |         self._draw_text(font_small, 10, 86, f\"SPM {spm:>5.1f}\", _COLOR_YELLOW)\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n   |                                                                                         ^\n67 |\n68 |     def show_status(self, message, success=True):\n   |\n\nANN201 Missing return type annotation for public function `show_status`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:9\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |         ^^^^^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:27\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                           ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN001 Missing type annotation for function argument `success`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN202 Missing return type annotation for private function `_draw_text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:9\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |         ^^^^^^^^^^\n76 |         if not self.available:\n77 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `font`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:26\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                          ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `x`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:32\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `y`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:35\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                   ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:38\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                      ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `color`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:44\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                            ^^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_features_imu_x.py:6:27\n  |\n4 |     import math\n5 | except ImportError:  # pragma: no cover - MicroPython bundles math\n6 |     import cmath as math  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `magnitude`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:5\n   |\n 9 | def magnitude(vector):\n   |     ^^^^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:15\n   |\n 9 | def magnitude(vector):\n   |               ^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\n\nANN201 Missing return type annotation for public function `dot`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:5\n   |\n14 | def dot(a, b):\n   |     ^^^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:9\n   |\n14 | def dot(a, b):\n   |         ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:12\n   |\n14 | def dot(a, b):\n   |            ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN201 Missing return type annotation for public function `subtract`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:5\n   |\n18 | def subtract(a, b):\n   |     ^^^^^^^^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:14\n   |\n18 | def subtract(a, b):\n   |              ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:17\n   |\n18 | def subtract(a, b):\n   |                 ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN201 Missing return type annotation for public function `cross`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:5\n   |\n22 | def cross(a, b):\n   |     ^^^^^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:11\n   |\n22 | def cross(a, b):\n   |           ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:14\n   |\n22 | def cross(a, b):\n   |              ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN201 Missing return type annotation for public function `jerk`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:5\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |     ^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `prev_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:10\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |          ^^^^^^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:22\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                      ^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `dt`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:29\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                             ^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN201 Missing return type annotation for public function `projection_onto`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:5\n   |\n37 | def projection_onto(vector, axis):\n   |     ^^^^^^^^^^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:21\n   |\n37 | def projection_onto(vector, axis):\n   |                     ^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN001 Missing type annotation for function argument `axis`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:29\n   |\n37 | def projection_onto(vector, axis):\n   |                             ^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `normalize`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:5\n   |\n44 | def normalize(vector):\n   |     ^^^^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:15\n   |\n44 | def normalize(vector):\n   |               ^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `gravity_aligned_components`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:5\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:32\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                ^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:46\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                              ^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN201 Missing return type annotation for public function `angular_rate_features`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:5\n   |\n61 | def angular_rate_features(gyro):\n   |     ^^^^^^^^^^^^^^^^^^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:27\n   |\n61 | def angular_rate_features(gyro):\n   |                           ^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:12:9\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:12:24\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |                        ^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:17:9\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |         ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:17:21\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |                     ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:21:9\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |         ^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:21:20\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |                    ^^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:33:9\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:33:24\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |                        ^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:39:9\n   |\n37 |         self._initialized = False\n38 |\n39 |     def reset(self):\n   |         ^^^^^\n40 |         self._prev_input = 0.0\n41 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:44:9\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |         ^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:44:20\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |                    ^^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:57:9\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |         ^^^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `window`\n  --> firmware\\lib\\x_cls_filters_x.py:57:24\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |                        ^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:63:9\n   |\n61 |         self._count = 0\n62 |\n63 |     def reset(self):\n   |         ^^^^^\n64 |         self._values = [0.0] * self._window\n65 |         self._idx = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:68:9\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |         ^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:68:20\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |                    ^^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:82:9\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |         ^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `period_ms`\n  --> firmware\\lib\\x_cls_filters_x.py:82:24\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |                        ^^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:86:9\n   |\n84 |         self._next = 0\n85 |\n86 |     def reset(self):\n   |         ^^^^^\n87 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ready`\n  --> firmware\\lib\\x_cls_filters_x.py:89:9\n   |\n87 |         self._next = 0\n88 |\n89 |     def ready(self):\n   |         ^^^^^\n90 |         now = time.ticks_ms()\n91 |         if self._next == 0:\n   |\nhelp: Add return type annotation: `bool`\n\nSIM105 Use `contextlib.suppress(ImportError)` instead of `try`-`except`-`pass`\n --> firmware\\lib\\x_cls_metrics_x.py:3:1\n  |\n1 |   \"\"\"Session metrics aggregation.\"\"\"\n2 |\n3 | / try:\n4 | |     import utime as time  # type: ignore\n5 | | except ImportError:  # pragma: no cover - CPython tooling\n6 | |     pass  # type: ignore\n  | |________^\n  |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(ImportError): ...`\n\nF401 `utime` imported but unused; consider using `importlib.util.find_spec` to test for availability\n --> firmware\\lib\\x_cls_metrics_x.py:4:21\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                     ^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\nhelp: Remove unused import: `utime`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:6:11\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |           ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_metrics_x.py:10:9\n   |\n 9 | class MetricsTracker:\n10 |     def __init__(self):\n   |         ^^^^^^^^\n11 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_metrics_x.py:13:9\n   |\n11 |         self.reset()\n12 |\n13 |     def reset(self):\n   |         ^^^^^\n14 |         self.count = 0\n15 |         self.start_ms = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `begin`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:9\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |         ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:21\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |                     ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\n\nANN201 Missing return type annotation for public function `register`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:9\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |         ^^^^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:24\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |                        ^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\n\nANN201 Missing return type annotation for public function `strokes_per_minute`\n  --> firmware\\lib\\x_cls_metrics_x.py:33:9\n   |\n31 |         self.peaks.append(event.get(\"peak_accel\", 0.0))\n32 |\n33 |     def strokes_per_minute(self):\n   |         ^^^^^^^^^^^^^^^^^^\n34 |         if self.start_ms is None or self.last_ms is None:\n35 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `peak_accel`\n  --> firmware\\lib\\x_cls_metrics_x.py:42:9\n   |\n40 |         return self.count / minutes if minutes else 0.0\n41 |\n42 |     def peak_accel(self):\n   |         ^^^^^^^^^^\n43 |         if not self.peaks:\n44 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_punch_classifier_x.py:7:9\n  |\n6 | class PunchClassifier:\n7 |     def __init__(self):\n  |         ^^^^^^^^\n8 |         self.gravity = (0.0, 0.0, -9.81)\n9 |         self.forward_axis = (1.0, 0.0, 0.0)\n  |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `update_orientation`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:9\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |         ^^^^^^^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:34\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                  ^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nANN001 Missing type annotation for function argument `forward_axis`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:43\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                           ^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nE501 Line too long (95 > 88)\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:17:89\n   |\n15 |         self.forward_axis = features.normalize(forward_axis)\n16 |         self.up_axis = features.normalize(tuple(-g for g in gravity))\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n   |                                                                                         ^^^^^^^\n18 |\n19 |     def classify(self, event):\n   |\n\nANN201 Missing return type annotation for public function `classify`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:9\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |         ^^^^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:24\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |                        ^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n7 |\n8 | from . import x_cls_features_imu_x as features\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:14:9\n   |\n12 |     \"\"\"Unbiased running mean/variance for baseline estimation.\"\"\"\n13 |\n14 |     def __init__(self):\n   |         ^^^^^^^^\n15 |         self.count = 0\n16 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:9\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |         ^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:19\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |                   ^^^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:25:9\n   |\n23 |         self.ssq += delta * (value - self.mean)\n24 |\n25 |     def std(self):\n   |         ^^^\n26 |         if self.count < 2:\n27 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_punch_detector_x.py:26:25\n   |\n25 |     def std(self):\n26 |         if self.count < 2:\n   |                         ^\n27 |             return 0.0\n28 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:9\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |         ^^^^^^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:24\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |                        ^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:38:9\n   |\n36 |         self.reset()\n37 |\n38 |     def reset(self):\n   |         ^^^^^\n39 |         self._state = \"idle\"\n40 |         self._last_event_ms = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ingest_idle`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:9\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |         ^^^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `accel_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:27\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                           ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `jerk_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:38\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                      ^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `omega_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:48\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                                ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN201 Missing return type annotation for public function `thresholds`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:51:9\n   |\n49 |         self._omega_stats.add(omega_mag)\n50 |\n51 |     def thresholds(self):\n   |         ^^^^^^^^^^\n52 |         a = max(\n53 |             self.cfg[\"accel_thresh_min\"],\n   |\nhelp: Add return type annotation\n\nPLR0911 Too many return statements (7 > 6)\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN201 Missing return type annotation for public function `update`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:25\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                         ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:32\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                ^^^^^^^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:46\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                              ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `jerk`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:52\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                    ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `dt_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:58\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                          ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `40` with a constant variable\n   --> firmware\\lib\\x_cls_punch_detector_x.py:112:42\n    |\n111 |             if not trigger:\n112 |                 if cand[\"duration_ms\"] < 40:\n    |                                          ^^\n113 |                     self._state = \"idle\"\n114 |                     self._candidate = None\n    |\n\nANN202 Missing return type annotation for private function `_emit_event`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:9\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |         ^^^^^^^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:27\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |                           ^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:6:21\n  |\n4 |     import struct\n5 |\n6 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n7 |     import utime as time  # type: ignore\n8 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:7:27\n  |\n6 |     import machine  # type: ignore\n7 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - CPython tooling\n9 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:9:21\n   |\n 7 |     import utime as time  # type: ignore\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:10:20\n   |\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:11:18\n   |\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:9\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |         ^^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `i2c`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:24\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                        ^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN001 Missing type annotation for function argument `address`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:29\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                             ^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN201 Missing return type annotation for public function `initialize`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:57:9\n   |\n55 |         self._mode = _MODE_CONFIG\n56 |\n57 |     def initialize(self):\n   |         ^^^^^^^^^^\n58 |         self._write8(_REG_OPR_MODE, _MODE_CONFIG)\n59 |         sleep_ms(25)\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `set_mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:9\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |         ^^^^^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:24\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |                        ^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\n\nANN201 Missing return type annotation for public function `read_linear_accel`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:75:9\n   |\n73 |         self._mode = mode\n74 |\n75 |     def read_linear_accel(self):\n   |         ^^^^^^^^^^^^^^^^^\n76 |         x, y, z = self._read_vector(_LINEAR_ACCEL_DATA_X_LSB)\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gravity`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:79:9\n   |\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n78 |\n79 |     def read_gravity(self):\n   |         ^^^^^^^^^^^^\n80 |         x, y, z = self._read_vector(_GRAVITY_DATA_X_LSB)\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gyro`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:83:9\n   |\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n82 |\n83 |     def read_gyro(self):\n   |         ^^^^^^^^^\n84 |         x, y, z = self._read_vector(_GYRO_DATA_X_LSB)\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_euler`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:87:9\n   |\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n86 |\n87 |     def read_euler(self):\n   |         ^^^^^^^^^^\n88 |         heading, roll, pitch = self._read_vector(_EULER_H_LSB)\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_temperature`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:91:9\n   |\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n90 |\n91 |     def read_temperature(self):\n   |         ^^^^^^^^^^^^^^^^\n92 |         buf = self._read_bytes(_REG_TEMP, 1)\n93 |         return float(struct.unpack(\"b\", buf)[0])\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_read_vector`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:9\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |         ^^^^^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:28\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |                            ^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\n\nANN202 Missing return type annotation for private function `_write8`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:9\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |         ^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:23\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                       ^^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN001 Missing type annotation for function argument `value`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:33\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                                 ^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN202 Missing return type annotation for private function `_read_bytes`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:9\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |         ^^^^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:27\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                           ^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nANN001 Missing type annotation for function argument `length`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:37\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                                     ^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nINP001 File `firmware\\main.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\main.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:4:21\n  |\n3 | try:\n4 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:5:27\n  |\n3 | try:\n4 |     import machine  # type: ignore\n5 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:7:21\n  |\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n8 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:8:18\n  |\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n8 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `sleep_ms`\n  --> firmware\\main.py:14:9\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |         ^^^^^^^^\n15 |         time.sleep(ms / 1000.0)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ms`\n  --> firmware\\main.py:14:18\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |                  ^^\n15 |         time.sleep(ms / 1000.0)\n   |\n\nANN201 Missing return type annotation for public function `ticks_ms`\n  --> firmware\\main.py:23:9\n   |\n21 |     ticks_diff = time.ticks_diff  # type: ignore[attr-defined]\n22 | else:  # pragma: no cover - CPython tooling\n23 |     def ticks_ms():\n   |         ^^^^^^^^\n24 |         return int(time.time() * 1000)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `ticks_add`\n  --> firmware\\main.py:26:9\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |         ^^^^^^^^^\n27 |         return value + delta\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\main.py:26:19\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                   ^^^^^\n27 |         return value + delta\n   |\n\nANN001 Missing type annotation for function argument `delta`\n  --> firmware\\main.py:26:26\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                          ^^^^^\n27 |         return value + delta\n   |\n\nANN201 Missing return type annotation for public function `ticks_diff`\n  --> firmware\\main.py:29:9\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |         ^^^^^^^^^^\n30 |         return a - b\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\main.py:29:20\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                    ^\n30 |         return a - b\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\main.py:29:23\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                       ^\n30 |         return a - b\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\main.py:47:9\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |         ^^^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `pin_no`\n  --> firmware\\main.py:47:24\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |                        ^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\n\nANN201 Missing return type annotation for public function `pressed`\n  --> firmware\\main.py:54:9\n   |\n52 |         self._last = 1\n53 |\n54 |     def pressed(self):\n   |         ^^^^^^^\n55 |         if self._pin is None:\n56 |             return False\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_init_sensor`\n  --> firmware\\main.py:63:5\n   |\n63 | def _init_sensor():\n   |     ^^^^^^^^^^^^\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |\nhelp: Add return type annotation\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:65:15\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:65:28\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\nhelp: Assign to variable; remove string literal\n\nANN202 Missing return type annotation for private function `_run_calibration`\n  --> firmware\\main.py:72:5\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |     ^^^^^^^^^^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `sensor`\n  --> firmware\\main.py:72:22\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                      ^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\main.py:72:30\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                              ^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `display`\n  --> firmware\\main.py:72:35\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                                   ^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nC901 `main` is too complex (14 > 10)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0912 Too many branches (15 > 12)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0915 Too many statements (83 > 50)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nANN201 Missing return type annotation for public function `main`\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\nhelp: Add return type annotation: `None`\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:93:15\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:93:28\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> firmware\\main.py:110:15\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> firmware\\main.py:110:28\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |                            ^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (97 > 88)\n   --> firmware\\main.py:120:89\n    |\n118 |     for idx in range(limit):\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n    |                                                                                         ^^^^^^^^^\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nE501 Line too long (101 > 88)\n   --> firmware\\main.py:121:89\n    |\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n    |                                                                                         ^^^^^^^^^^^^^\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nSIM108 Use ternary operator `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)` instead of `if`-`else`-block\n   --> firmware\\main.py:145:9\n    |\n143 |           classifier.update_orientation(gravity, forward_axis)\n144 |\n145 | /         if last_ts is None:\n146 | |             dt_ms = sample_period\n147 | |         else:\n148 | |             dt_ms = ticks_diff(now, last_ts)\n    | |____________________________________________^\n149 |           last_ts = now\n    |\nhelp: Replace `if`-`else`-block with `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)`\n\nE501 Line too long (92 > 88)\n   --> firmware\\main.py:156:89\n    |\n155 |         if not running:\n156 |             detector.ingest_idle(features.magnitude(linear), jerk, features.magnitude(gyro))\n    |                                                                                         ^^^^\n157 |\n158 |         if start_button.pressed():\n    |\n\nINP001 File `firmware\\secrets_template.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\secrets_template.py:1:1\n\nS105 Possible hardcoded password assigned to: \"PASSWORD\"\n --> firmware\\secrets_template.py:8:12\n  |\n7 | SSID = \"YourNetwork\"\n8 | PASSWORD = \"SuperSecret\"\n  |            ^^^^^^^^^^^^^\n  |\n\nFound 263 errors.\nNo fixes available (55 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:56:07.501057+00:00\nduration: 0.151s\ntool_version: ruff 0.14.3\nstdout:\nINP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026\nstderr:\n<empty>",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": null,
            "stdout_preview": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-v\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:56:05.639232+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "duration_seconds": 0.19241669995244592,
                "ended_at": "2025-10-31T03:56:05.639232+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "firmware/boot.py",
                    "firmware/lib/__init__.py",
                    "firmware/lib/x_cls_calibrate_x.py",
                    "firmware/lib/x_cls_cfg_x.py",
                    "firmware/lib/x_cls_combo_segmenter_x.py",
                    "firmware/lib/x_cls_comm_uart_x.py",
                    "firmware/lib/x_cls_datalogger_x.py",
                    "firmware/lib/x_cls_display_tft_x.py",
                    "firmware/lib/x_cls_features_imu_x.py",
                    "firmware/lib/x_cls_filters_x.py",
                    "firmware/lib/x_cls_metrics_x.py",
                    "firmware/lib/x_cls_punch_classifier_x.py",
                    "firmware/lib/x_cls_punch_detector_x.py",
                    "firmware/lib/x_cls_sensor_bno055_x.py",
                    "firmware/main.py",
                    "firmware/secrets_template.py"
                ],
                "repo": "x_legatus_tactica_impetus_x",
                "repo_hash": "60eec4632cb4ef6a48af31080c4315fd7e6ad7cb201d6276fedd8ae3bba43311",
                "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
                "started_at": "2025-10-31T03:56:05.455838+00:00",
                "stderr": "",
                "stdout": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:9:21\n   |\n 7 | try:\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:10:27\n   |\n 8 |     import machine  # type: ignore\n 9 |     import network  # type: ignore\n10 |     import utime as time  # type: ignore\n   |                           ^^^^^^^^^^^^^^\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:12:21\n   |\n10 |     import utime as time  # type: ignore\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:13:21\n   |\n11 | except ImportError:  # pragma: no cover - running in CPython for lint\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n14 |     time = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:14:18\n   |\n12 |     machine = None  # type: ignore\n13 |     network = None  # type: ignore\n14 |     time = None  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n15 |\n16 | SAFE_MODE_PIN = 0  # Button B (GPIO0) used to skip Wi-Fi when held\n   |\n\nPLC0415 `import` should be at the top-level of a file\n  --> firmware\\boot.py:24:9\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:24:45\n   |\n22 |         return\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n   |                                             ^^^^^^^^^^^^^^\n25 |     except Exception:  # secrets missing; stay offline\n26 |         return\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:25:12\n   |\n23 |     try:\n24 |         from secrets import PASSWORD, SSID  # type: ignore\n25 |     except Exception:  # secrets missing; stay offline\n   |            ^^^^^^^^^\n26 |         return\n   |\n\nFBT003 Boolean positional value in function call\n  --> firmware\\boot.py:30:21\n   |\n28 |     wlan = network.WLAN(network.STA_IF)\n29 |     if not wlan.active():\n30 |         wlan.active(True)\n   |                     ^^^^\n31 |     if wlan.isconnected():\n32 |         return\n   |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n  --> firmware\\boot.py:49:5\n   |\n48 |   if machine is not None:\n49 | /     try:\n50 | |         machine.freq(240_000_000)\n51 | |     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\boot.py:51:5\n   |\n49 |       try:\n50 |           machine.freq(240_000_000)\n51 | /     except Exception:\n52 | |         pass\n   | |____________^\n53 |\n54 |   if not _should_skip_wifi():\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\boot.py:51:12\n   |\n49 |     try:\n50 |         machine.freq(240_000_000)\n51 |     except Exception:\n   |            ^^^^^^^^^\n52 |         pass\n   |\n\nPLR0913 Too many arguments in function definition (8 > 5)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:9\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |         ^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:24\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                        ^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:33\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                 ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:46\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                              ^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_noise`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:58\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                          ^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `forward_axis`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:71\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                       ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `accel_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:85\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                     ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nE501 Line too long (128 > 88)\n --> firmware\\lib\\x_cls_calibrate_x.py:7:89\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `jerk_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:100\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                    ^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN001 Missing type annotation for function argument `omega_samples`\n --> firmware\\lib\\x_cls_calibrate_x.py:7:114\n  |\n6 | class CalibrationResult:\n7 |     def __init__(self, gravity, accel_noise, jerk_noise, omega_noise, forward_axis, accel_samples, jerk_samples, omega_samples):\n  |                                                                                                                  ^^^^^^^^^^^^^\n8 |         self.gravity = gravity\n9 |         self.accel_noise = accel_noise\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:9\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |         ^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `sample_target`\n  --> firmware\\lib\\x_cls_calibrate_x.py:21:24\n   |\n19 |     \"\"\"Collects idle samples and produces baseline statistics.\"\"\"\n20 |\n21 |     def __init__(self, sample_target):\n   |                        ^^^^^^^^^^^^^\n22 |         self._target = sample_target\n23 |         self._count = 0\n   |\n\nANN201 Missing return type annotation for public function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:9\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |         ^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:19\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                   ^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:26\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                          ^^^^^^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:40\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                        ^^^^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_calibrate_x.py:34:49\n   |\n32 |         self.omega_samples = []\n33 |\n34 |     def add(self, ts_ms, linear_accel, gravity, gyro):\n   |                                                 ^^^^\n35 |         self._count += 1\n36 |         self._sum_g[0] += gravity[0]\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:53:38\n   |\n51 |         self._jerk_stats.add(jerk)\n52 |         self._omega_stats.add(omega_mag)\n53 |         if len(self.accel_samples) < 512:\n   |                                      ^^^\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:55:37\n   |\n53 |         if len(self.accel_samples) < 512:\n54 |             self.accel_samples.append(accel_mag)\n55 |         if len(self.jerk_samples) < 512:\n   |                                     ^^^\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `512` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:57:38\n   |\n55 |         if len(self.jerk_samples) < 512:\n56 |             self.jerk_samples.append(jerk)\n57 |         if len(self.omega_samples) < 512:\n   |                                      ^^^\n58 |             self.omega_samples.append(omega_mag)\n   |\n\nANN201 Missing return type annotation for public function `done`\n  --> firmware\\lib\\x_cls_calibrate_x.py:60:9\n   |\n58 |             self.omega_samples.append(omega_mag)\n59 |\n60 |     def done(self):\n   |         ^^^^\n61 |         return self._count >= self._target\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `result`\n  --> firmware\\lib\\x_cls_calibrate_x.py:63:9\n   |\n61 |         return self._count >= self._target\n62 |\n63 |     def result(self):\n   |         ^^^^^^\n64 |         if self._count == 0:\n65 |             return None\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_calibrate_x.py:85:9\n   |\n84 | class _RunningStats:\n85 |     def __init__(self):\n   |         ^^^^^^^^\n86 |         self.count = 0\n87 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:9\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |         ^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_calibrate_x.py:90:19\n   |\n88 |         self.ssq = 0.0\n89 |\n90 |     def add(self, value):\n   |                   ^^^^^\n91 |         self.count += 1\n92 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_calibrate_x.py:96:9\n   |\n94 |         self.ssq += delta * (value - self.mean)\n95 |\n96 |     def std(self):\n   |         ^^^\n97 |         if self.count < 2:\n98 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_calibrate_x.py:97:25\n   |\n96 |     def std(self):\n97 |         if self.count < 2:\n   |                         ^\n98 |             return 0.0\n99 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_cfg_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_cfg_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover - CPython tooling\n11 |     import os\n   |\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:38:14\n   |\n36 |     cfg = DEFAULT_CFG.copy()\n37 |     try:\n38 |         with open(_CFG_PATH) as handle:\n   |              ^^^^\n39 |             user_cfg = json.load(handle)\n40 |         if isinstance(user_cfg, dict):\n   |\nhelp: Replace with `Path.open()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_cfg_x.py:52:14\n   |\n50 |     try:\n51 |         tmp_path = _CFG_PATH + \".tmp\"\n52 |         with open(tmp_path, \"w\") as handle:\n   |              ^^^^\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |\nhelp: Replace with `Path.open()`\n\nPTH104 `os.rename()` should be replaced by `Path.rename()`\n  --> firmware\\lib\\x_cls_cfg_x.py:54:9\n   |\n52 |         with open(tmp_path, \"w\") as handle:\n53 |             json.dump(cfg, handle)\n54 |         os.rename(tmp_path, _CFG_PATH)\n   |         ^^^^^^^^^\n55 |     except OSError:\n56 |         pass\n   |\nhelp: Replace with `Path(...).rename(...)`\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:9\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |         ^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `combo_gap_ms`\n --> firmware\\lib\\x_cls_combo_segmenter_x.py:5:24\n  |\n4 | class ComboSegmenter:\n5 |     def __init__(self, combo_gap_ms):\n  |                        ^^^^^^^^^^^^\n6 |         self.combo_gap_ms = combo_gap_ms\n7 |         self.reset()\n  |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:9:9\n   |\n 7 |         self.reset()\n 8 |\n 9 |     def reset(self):\n   |         ^^^^^\n10 |         self._current_combo_id = 0\n11 |         self._last_ts = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `assign`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:9\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |         ^^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_combo_segmenter_x.py:13:22\n   |\n11 |         self._last_ts = None\n12 |\n13 |     def assign(self, event):\n   |                      ^^^^^\n14 |         ts_ms = event.get(\"start_ms\", 0)\n15 |         if self._last_ts is None or ts_ms - self._last_ts > self.combo_gap_ms:\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_comm_uart_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_comm_uart_x.py:11:17\n   |\n 9 |     import sys\n10 | except ImportError:  # pragma: no cover\n11 |     sys = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:9\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |         ^^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\nhelp: Add return type annotation: `None`\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN001 Missing type annotation for function argument `enabled`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:15:24\n   |\n14 | class UartStreamer:\n15 |     def __init__(self, enabled=True):\n   |                        ^^^^^^^\n16 |         self.enabled = enabled and sys is not None\n   |\n\nANN201 Missing return type annotation for public function `emit`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:9\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |         ^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `payload`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:18:20\n   |\n16 |         self.enabled = enabled and sys is not None\n17 |\n18 |     def emit(self, payload):\n   |                    ^^^^^^^\n19 |         if not self.enabled:\n20 |             return\n   |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:9\n   |\n22 |               sys.stdout.write(json.dumps(payload))\n23 |               sys.stdout.write(\"\\n\")\n24 | /         except Exception:\n25 | |             pass\n   | |________________^\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> firmware\\lib\\x_cls_comm_uart_x.py:24:16\n   |\n22 |             sys.stdout.write(json.dumps(payload))\n23 |             sys.stdout.write(\"\\n\")\n24 |         except Exception:\n   |                ^^^^^^^^^\n25 |             pass\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_datalogger_x.py:4:27\n  |\n3 | try:\n4 |     import ujson as json  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import json\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:9:23\n   |\n 8 | try:\n 9 |     import uos as os  # type: ignore\n   |                       ^^^^^^^^^^^^^^\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_datalogger_x.py:11:16\n   |\n 9 |     import uos as os  # type: ignore\n10 | except ImportError:  # pragma: no cover\n11 |     import os  # type: ignore\n   |                ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:9\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |         ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `root_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:15:24\n   |\n14 | class DataLogger:\n15 |     def __init__(self, root_dir):\n   |                        ^^^^^^^^\n16 |         self.root_dir = root_dir\n17 |         self._buffer = []\n   |\n\nANN202 Missing return type annotation for private function `_ensure_dir`\n  --> firmware\\lib\\x_cls_datalogger_x.py:21:9\n   |\n19 |         self._session_path = None\n20 |\n21 |     def _ensure_dir(self):\n   |         ^^^^^^^^^^^\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |\nhelp: Add return type annotation: `None`\n\nSIM105 Use `contextlib.suppress(OSError)` instead of `try`-`except`-`pass`\n  --> firmware\\lib\\x_cls_datalogger_x.py:22:9\n   |\n21 |       def _ensure_dir(self):\n22 | /         try:\n23 | |             os.mkdir(self.root_dir)\n24 | |         except OSError:\n25 | |             pass\n   | |________________^\n26 |\n27 |       def start_session(self, session_id):\n   |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(OSError): ...`\n\nPTH102 `os.mkdir()` should be replaced by `Path.mkdir()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:23:13\n   |\n21 |     def _ensure_dir(self):\n22 |         try:\n23 |             os.mkdir(self.root_dir)\n   |             ^^^^^^^^\n24 |         except OSError:\n25 |             pass\n   |\nhelp: Replace with `Path(...).mkdir()`\n\nANN201 Missing return type annotation for public function `start_session`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:9\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |         ^^^^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `session_id`\n  --> firmware\\lib\\x_cls_datalogger_x.py:27:29\n   |\n25 |             pass\n26 |\n27 |     def start_session(self, session_id):\n   |                             ^^^^^^^^^^\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n29 |         self._buffer = []\n   |\n\nUP031 Use format specifiers instead of percent format\n  --> firmware\\lib\\x_cls_datalogger_x.py:28:30\n   |\n27 |     def start_session(self, session_id):\n28 |         self._session_path = \"%s/session_%s.jsonl\" % (self.root_dir, session_id)\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n29 |         self._buffer = []\n   |\nhelp: Replace with format specifiers\n\nANN201 Missing return type annotation for public function `append`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:9\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |         ^^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_datalogger_x.py:31:22\n   |\n29 |         self._buffer = []\n30 |\n31 |     def append(self, event):\n   |                      ^^^^^\n32 |         if len(self._buffer) > 256:\n33 |             self.flush()\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `256` with a constant variable\n  --> firmware\\lib\\x_cls_datalogger_x.py:32:32\n   |\n31 |     def append(self, event):\n32 |         if len(self._buffer) > 256:\n   |                                ^^^\n33 |             self.flush()\n34 |         self._buffer.append(event)\n   |\n\nANN201 Missing return type annotation for public function `flush`\n  --> firmware\\lib\\x_cls_datalogger_x.py:36:9\n   |\n34 |         self._buffer.append(event)\n35 |\n36 |     def flush(self):\n   |         ^^^^^\n37 |         if not self._buffer or self._session_path is None:\n38 |             return\n   |\nhelp: Add return type annotation: `None`\n\nPTH123 `open()` should be replaced by `Path.open()`\n  --> firmware\\lib\\x_cls_datalogger_x.py:40:18\n   |\n38 |             return\n39 |         try:\n40 |             with open(self._session_path, \"a\") as handle:\n   |                  ^^^^\n41 |                 for item in self._buffer:\n42 |                     handle.write(json.dumps(item))\n   |\nhelp: Replace with `Path.open()`\n\nANN201 Missing return type annotation for public function `close`\n  --> firmware\\lib\\x_cls_datalogger_x.py:48:9\n   |\n46 |         self._buffer = []\n47 |\n48 |     def close(self):\n   |         ^^^^^\n49 |         self.flush()\n50 |         self._session_path = None\n   |\nhelp: Add return type annotation: `None`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:4:20\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n  |                    ^^^^^^^^^^^^^^\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:5:36\n  |\n3 | try:\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:6:36\n  |\n4 |     import st7789  # type: ignore\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n  |                                    ^^^^^^^^^^^^^^\n7 |     from machine import SPI, Pin  # type: ignore\n8 | except ImportError:  # pragma: no cover - running under CPython\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_display_tft_x.py:7:35\n  |\n5 |     import vga1_8x8 as font_small  # type: ignore\n6 |     import vga2_16x32 as font_big  # type: ignore\n7 |     from machine import SPI, Pin  # type: ignore\n  |                                   ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - running under CPython\n9 |     st7789 = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:9:20\n   |\n 7 |     from machine import SPI, Pin  # type: ignore\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:10:24\n   |\n 8 | except ImportError:  # pragma: no cover - running under CPython\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n   |                        ^^^^^^^^^^^^^^\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:11:22\n   |\n 9 |     st7789 = None  # type: ignore\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n   |                      ^^^^^^^^^^^^^^\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:12:17\n   |\n10 |     font_small = None  # type: ignore\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n13 |     SPI = None  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_display_tft_x.py:13:17\n   |\n11 |     font_big = None  # type: ignore\n12 |     Pin = None  # type: ignore\n13 |     SPI = None  # type: ignore\n   |                 ^^^^^^^^^^^^^^\n14 |\n15 | _COLOR_BLACK = 0x0000\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_display_tft_x.py:23:9\n   |\n22 | class Display:\n23 |     def __init__(self):\n   |         ^^^^^^^^\n24 |         self.available = bool(st7789)\n25 |         if not self.available:\n   |\nhelp: Add return type annotation: `None`\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:27:89\n   |\n25 |         if not self.available:\n26 |             return\n27 |         spi = SPI(1, baudrate=40_000_000, polarity=1, phase=1, sck=Pin(18), mosi=Pin(19))\n   |                                                                                         ^\n28 |         self._tft = st7789.ST7789(\n29 |             spi,\n   |\n\nANN201 Missing return type annotation for public function `clear`\n  --> firmware\\lib\\x_cls_display_tft_x.py:45:9\n   |\n43 |         self._punch_count = 0\n44 |\n45 |     def clear(self):\n   |         ^^^^^\n46 |         if not self.available:\n47 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `show_idle`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:9\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |         ^^^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:50:25\n   |\n48 |         self._tft.fill(_COLOR_BLACK)\n49 |\n50 |     def show_idle(self, message=\"Hold still for calibration\"):\n   |                         ^^^^^^^\n51 |         if not self.available:\n52 |             return\n   |\n\nANN201 Missing return type annotation for public function `show_session`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:9\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |         ^^^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `counts`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:31\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                               ^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `last_type`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:39\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                       ^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `confidence`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:50\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                  ^^^^^^^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `spm`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:62\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                              ^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nANN001 Missing type annotation for function argument `peak`\n  --> firmware\\lib\\x_cls_display_tft_x.py:57:67\n   |\n55 |         self._draw_text(font_small, 10, 90, message, _COLOR_WHITE)\n56 |\n57 |     def show_session(self, *, counts, last_type, confidence, spm, peak):\n   |                                                                   ^^^^\n58 |         if not self.available:\n59 |             return\n   |\n\nE501 Line too long (89 > 88)\n  --> firmware\\lib\\x_cls_display_tft_x.py:66:89\n   |\n64 |         self._tft.fill_rect(0, 80, 240, 40, _COLOR_BLACK)\n65 |         self._draw_text(font_small, 10, 86, f\"SPM {spm:>5.1f}\", _COLOR_YELLOW)\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n   |                                                                                         ^\n67 |\n68 |     def show_status(self, message, success=True):\n   |\n\nANN201 Missing return type annotation for public function `show_status`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:9\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |         ^^^^^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `message`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:27\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                           ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nFBT002 Boolean default positional argument in function definition\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN001 Missing type annotation for function argument `success`\n  --> firmware\\lib\\x_cls_display_tft_x.py:68:36\n   |\n66 |         self._draw_text(font_small, 10, 106, f\"Peak {peak / 9.81:>5.2f}g\", _COLOR_YELLOW)\n67 |\n68 |     def show_status(self, message, success=True):\n   |                                    ^^^^^^^\n69 |         if not self.available:\n70 |             return\n   |\n\nANN202 Missing return type annotation for private function `_draw_text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:9\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |         ^^^^^^^^^^\n76 |         if not self.available:\n77 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `font`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:26\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                          ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `x`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:32\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `y`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:35\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                   ^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `text`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:38\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                      ^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nANN001 Missing type annotation for function argument `color`\n  --> firmware\\lib\\x_cls_display_tft_x.py:75:44\n   |\n73 |         self._draw_text(font_small, 10, 126, message[:26], color)\n74 |\n75 |     def _draw_text(self, font, x, y, text, color):\n   |                                            ^^^^^\n76 |         if not self.available:\n77 |             return\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_features_imu_x.py:6:27\n  |\n4 |     import math\n5 | except ImportError:  # pragma: no cover - MicroPython bundles math\n6 |     import cmath as math  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `magnitude`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:5\n   |\n 9 | def magnitude(vector):\n   |     ^^^^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:9:15\n   |\n 9 | def magnitude(vector):\n   |               ^^^^^^\n10 |     x, y, z = vector\n11 |     return math.sqrt(x * x + y * y + z * z)\n   |\n\nANN201 Missing return type annotation for public function `dot`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:5\n   |\n14 | def dot(a, b):\n   |     ^^^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:9\n   |\n14 | def dot(a, b):\n   |         ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:14:12\n   |\n14 | def dot(a, b):\n   |            ^\n15 |     return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n   |\n\nANN201 Missing return type annotation for public function `subtract`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:5\n   |\n18 | def subtract(a, b):\n   |     ^^^^^^^^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:14\n   |\n18 | def subtract(a, b):\n   |              ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:18:17\n   |\n18 | def subtract(a, b):\n   |                 ^\n19 |     return (a[0] - b[0], a[1] - b[1], a[2] - b[2])\n   |\n\nANN201 Missing return type annotation for public function `cross`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:5\n   |\n22 | def cross(a, b):\n   |     ^^^^^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:11\n   |\n22 | def cross(a, b):\n   |           ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\lib\\x_cls_features_imu_x.py:22:14\n   |\n22 | def cross(a, b):\n   |              ^\n23 |     return (\n24 |         a[1] * b[2] - a[2] * b[1],\n   |\n\nANN201 Missing return type annotation for public function `jerk`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:5\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |     ^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `prev_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:10\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |          ^^^^^^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:22\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                      ^^^^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN001 Missing type annotation for function argument `dt`\n  --> firmware\\lib\\x_cls_features_imu_x.py:30:29\n   |\n30 | def jerk(prev_accel, accel, dt):\n   |                             ^^\n31 |     if dt <= 0:\n32 |         return 0.0\n   |\n\nANN201 Missing return type annotation for public function `projection_onto`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:5\n   |\n37 | def projection_onto(vector, axis):\n   |     ^^^^^^^^^^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:21\n   |\n37 | def projection_onto(vector, axis):\n   |                     ^^^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN001 Missing type annotation for function argument `axis`\n  --> firmware\\lib\\x_cls_features_imu_x.py:37:29\n   |\n37 | def projection_onto(vector, axis):\n   |                             ^^^^\n38 |     axis_mag = magnitude(axis)\n39 |     if axis_mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `normalize`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:5\n   |\n44 | def normalize(vector):\n   |     ^^^^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `vector`\n  --> firmware\\lib\\x_cls_features_imu_x.py:44:15\n   |\n44 | def normalize(vector):\n   |               ^^^^^^\n45 |     mag = magnitude(vector)\n46 |     if mag == 0:\n   |\n\nANN201 Missing return type annotation for public function `gravity_aligned_components`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:5\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:32\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                ^^^^^^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_features_imu_x.py:51:46\n   |\n51 | def gravity_aligned_components(linear_accel, gravity):\n   |                                              ^^^^^^^\n52 |     g_unit = normalize(gravity)\n53 |     # component along gravity\n   |\n\nANN201 Missing return type annotation for public function `angular_rate_features`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:5\n   |\n61 | def angular_rate_features(gyro):\n   |     ^^^^^^^^^^^^^^^^^^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_features_imu_x.py:61:27\n   |\n61 | def angular_rate_features(gyro):\n   |                           ^^^^\n62 |     gx, gy, gz = gyro\n63 |     abs_x = abs(gx)\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_filters_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:12:9\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:12:24\n   |\n10 |     \"\"\"Simple IIR low-pass filter (one pole).\"\"\"\n11 |\n12 |     def __init__(self, alpha):\n   |                        ^^^^^\n13 |         self._alpha = alpha\n14 |         self._state = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:17:9\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |         ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:17:21\n   |\n15 |         self._initialized = False\n16 |\n17 |     def reset(self, value=0.0):\n   |                     ^^^^^\n18 |         self._state = value\n19 |         self._initialized = False\n   |\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:21:9\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |         ^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:21:20\n   |\n19 |         self._initialized = False\n20 |\n21 |     def push(self, value):\n   |                    ^^^^^\n22 |         if not self._initialized:\n23 |             self._state = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:33:9\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |         ^^^^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `alpha`\n  --> firmware\\lib\\x_cls_filters_x.py:33:24\n   |\n31 |     \"\"\"Simple one-pole high-pass filter.\"\"\"\n32 |\n33 |     def __init__(self, alpha):\n   |                        ^^^^^\n34 |         self._alpha = alpha\n35 |         self._prev_input = 0.0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:39:9\n   |\n37 |         self._initialized = False\n38 |\n39 |     def reset(self):\n   |         ^^^^^\n40 |         self._prev_input = 0.0\n41 |         self._state = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:44:9\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |         ^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:44:20\n   |\n42 |         self._initialized = False\n43 |\n44 |     def push(self, value):\n   |                    ^^^^^\n45 |         if not self._initialized:\n46 |             self._prev_input = value\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:57:9\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |         ^^^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `window`\n  --> firmware\\lib\\x_cls_filters_x.py:57:24\n   |\n55 |     \"\"\"Fixed-size moving average without imports from collections.\"\"\"\n56 |\n57 |     def __init__(self, window):\n   |                        ^^^^^^\n58 |         self._window = int(window)\n59 |         self._values = [0.0] * self._window\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:63:9\n   |\n61 |         self._count = 0\n62 |\n63 |     def reset(self):\n   |         ^^^^^\n64 |         self._values = [0.0] * self._window\n65 |         self._idx = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `push`\n  --> firmware\\lib\\x_cls_filters_x.py:68:9\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |         ^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_filters_x.py:68:20\n   |\n66 |         self._count = 0\n67 |\n68 |     def push(self, value):\n   |                    ^^^^^\n69 |         self._values[self._idx] = value\n70 |         self._idx = (self._idx + 1) % self._window\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_filters_x.py:82:9\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |         ^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `period_ms`\n  --> firmware\\lib\\x_cls_filters_x.py:82:24\n   |\n80 |     \"\"\"Lightweight periodic timer helper.\"\"\"\n81 |\n82 |     def __init__(self, period_ms):\n   |                        ^^^^^^^^^\n83 |         self._period = int(period_ms)\n84 |         self._next = 0\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_filters_x.py:86:9\n   |\n84 |         self._next = 0\n85 |\n86 |     def reset(self):\n   |         ^^^^^\n87 |         self._next = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ready`\n  --> firmware\\lib\\x_cls_filters_x.py:89:9\n   |\n87 |         self._next = 0\n88 |\n89 |     def ready(self):\n   |         ^^^^^\n90 |         now = time.ticks_ms()\n91 |         if self._next == 0:\n   |\nhelp: Add return type annotation: `bool`\n\nSIM105 Use `contextlib.suppress(ImportError)` instead of `try`-`except`-`pass`\n --> firmware\\lib\\x_cls_metrics_x.py:3:1\n  |\n1 |   \"\"\"Session metrics aggregation.\"\"\"\n2 |\n3 | / try:\n4 | |     import utime as time  # type: ignore\n5 | | except ImportError:  # pragma: no cover - CPython tooling\n6 | |     pass  # type: ignore\n  | |________^\n  |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(ImportError): ...`\n\nF401 `utime` imported but unused; consider using `importlib.util.find_spec` to test for availability\n --> firmware\\lib\\x_cls_metrics_x.py:4:21\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                     ^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\nhelp: Remove unused import: `utime`\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_metrics_x.py:6:11\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     pass  # type: ignore\n  |           ^^^^^^^^^^^^^^\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_metrics_x.py:10:9\n   |\n 9 | class MetricsTracker:\n10 |     def __init__(self):\n   |         ^^^^^^^^\n11 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_metrics_x.py:13:9\n   |\n11 |         self.reset()\n12 |\n13 |     def reset(self):\n   |         ^^^^^\n14 |         self.count = 0\n15 |         self.start_ms = None\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `begin`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:9\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |         ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_metrics_x.py:19:21\n   |\n17 |         self.peaks = []\n18 |\n19 |     def begin(self, ts_ms):\n   |                     ^^^^^\n20 |         self.start_ms = ts_ms\n21 |         self.last_ms = ts_ms\n   |\n\nANN201 Missing return type annotation for public function `register`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:9\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |         ^^^^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_metrics_x.py:25:24\n   |\n23 |         self.peaks = []\n24 |\n25 |     def register(self, event):\n   |                        ^^^^^\n26 |         ts_ms = event.get(\"ts_ms\")\n27 |         if self.start_ms is None:\n   |\n\nANN201 Missing return type annotation for public function `strokes_per_minute`\n  --> firmware\\lib\\x_cls_metrics_x.py:33:9\n   |\n31 |         self.peaks.append(event.get(\"peak_accel\", 0.0))\n32 |\n33 |     def strokes_per_minute(self):\n   |         ^^^^^^^^^^^^^^^^^^\n34 |         if self.start_ms is None or self.last_ms is None:\n35 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `peak_accel`\n  --> firmware\\lib\\x_cls_metrics_x.py:42:9\n   |\n40 |         return self.count / minutes if minutes else 0.0\n41 |\n42 |     def peak_accel(self):\n   |         ^^^^^^^^^^\n43 |         if not self.peaks:\n44 |             return 0.0\n   |\nhelp: Add return type annotation\n\nANN204 Missing return type annotation for special method `__init__`\n --> firmware\\lib\\x_cls_punch_classifier_x.py:7:9\n  |\n6 | class PunchClassifier:\n7 |     def __init__(self):\n  |         ^^^^^^^^\n8 |         self.gravity = (0.0, 0.0, -9.81)\n9 |         self.forward_axis = (1.0, 0.0, 0.0)\n  |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `update_orientation`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:9\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |         ^^^^^^^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `gravity`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:34\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                  ^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nANN001 Missing type annotation for function argument `forward_axis`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:13:43\n   |\n11 |         self.up_axis = (0.0, 0.0, 1.0)\n12 |\n13 |     def update_orientation(self, gravity, forward_axis):\n   |                                           ^^^^^^^^^^^^\n14 |         self.gravity = gravity\n15 |         self.forward_axis = features.normalize(forward_axis)\n   |\n\nE501 Line too long (95 > 88)\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:17:89\n   |\n15 |         self.forward_axis = features.normalize(forward_axis)\n16 |         self.up_axis = features.normalize(tuple(-g for g in gravity))\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n   |                                                                                         ^^^^^^^\n18 |\n19 |     def classify(self, event):\n   |\n\nANN201 Missing return type annotation for public function `classify`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:9\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |         ^^^^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `event`\n  --> firmware\\lib\\x_cls_punch_classifier_x.py:19:24\n   |\n17 |         self.lateral_axis = features.normalize(features.cross(self.up_axis, self.forward_axis))\n18 |\n19 |     def classify(self, event):\n   |                        ^^^^^\n20 |         linear = event.get(\"linear_accel\", (0.0, 0.0, 0.0))\n21 |         gyro = event.get(\"gyro\", (0.0, 0.0, 0.0))\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:4:27\n  |\n3 | try:\n4 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_punch_detector_x.py:6:18\n  |\n4 |     import utime as time  # type: ignore\n5 | except ImportError:  # pragma: no cover - CPython tooling\n6 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n7 |\n8 | from . import x_cls_features_imu_x as features\n  |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:14:9\n   |\n12 |     \"\"\"Unbiased running mean/variance for baseline estimation.\"\"\"\n13 |\n14 |     def __init__(self):\n   |         ^^^^^^^^\n15 |         self.count = 0\n16 |         self.mean = 0.0\n   |\nhelp: Add return type annotation: `None`\n\nANN202 Missing return type annotation for private function `add`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:9\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |         ^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:19:19\n   |\n17 |         self.ssq = 0.0\n18 |\n19 |     def add(self, value):\n   |                   ^^^^^\n20 |         self.count += 1\n21 |         delta = value - self.mean\n   |\n\nANN202 Missing return type annotation for private function `std`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:25:9\n   |\n23 |         self.ssq += delta * (value - self.mean)\n24 |\n25 |     def std(self):\n   |         ^^^\n26 |         if self.count < 2:\n27 |             return 0.0\n   |\nhelp: Add return type annotation\n\nPLR2004 Magic value used in comparison, consider replacing `2` with a constant variable\n  --> firmware\\lib\\x_cls_punch_detector_x.py:26:25\n   |\n25 |     def std(self):\n26 |         if self.count < 2:\n   |                         ^\n27 |             return 0.0\n28 |         return (self.ssq / (self.count - 1)) ** 0.5\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:9\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |         ^^^^^^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:34:24\n   |\n32 |     \"\"\"Detects punches from linear acceleration + gyro features.\"\"\"\n33 |\n34 |     def __init__(self, cfg):\n   |                        ^^^\n35 |         self.cfg = cfg\n36 |         self.reset()\n   |\n\nANN201 Missing return type annotation for public function `reset`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:38:9\n   |\n36 |         self.reset()\n37 |\n38 |     def reset(self):\n   |         ^^^^^\n39 |         self._state = \"idle\"\n40 |         self._last_event_ms = 0\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `ingest_idle`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:9\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |         ^^^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `accel_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:27\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                           ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `jerk_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:38\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                      ^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN001 Missing type annotation for function argument `omega_mag`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:46:48\n   |\n44 |         self._omega_stats = _RunningStats()\n45 |\n46 |     def ingest_idle(self, accel_mag, jerk_mag, omega_mag):\n   |                                                ^^^^^^^^^\n47 |         self._accel_stats.add(accel_mag)\n48 |         self._jerk_stats.add(jerk_mag)\n   |\n\nANN201 Missing return type annotation for public function `thresholds`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:51:9\n   |\n49 |         self._omega_stats.add(omega_mag)\n50 |\n51 |     def thresholds(self):\n   |         ^^^^^^^^^^\n52 |         a = max(\n53 |             self.cfg[\"accel_thresh_min\"],\n   |\nhelp: Add return type annotation\n\nPLR0911 Too many return statements (7 > 6)\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN201 Missing return type annotation for public function `update`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:9\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |         ^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:25\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                         ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `linear_accel`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:32\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                ^^^^^^^^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `gyro`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:46\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                              ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `jerk`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:52\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                    ^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nANN001 Missing type annotation for function argument `dt_ms`\n  --> firmware\\lib\\x_cls_punch_detector_x.py:66:58\n   |\n64 |         return a, j, o\n65 |\n66 |     def update(self, *, ts_ms, linear_accel, gyro, jerk, dt_ms):\n   |                                                          ^^^^^\n67 |         accel_mag = features.magnitude(linear_accel)\n68 |         omega_mag = features.magnitude(gyro)\n   |\n\nPLR2004 Magic value used in comparison, consider replacing `40` with a constant variable\n   --> firmware\\lib\\x_cls_punch_detector_x.py:112:42\n    |\n111 |             if not trigger:\n112 |                 if cand[\"duration_ms\"] < 40:\n    |                                          ^^\n113 |                     self._state = \"idle\"\n114 |                     self._candidate = None\n    |\n\nANN202 Missing return type annotation for private function `_emit_event`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:9\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |         ^^^^^^^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `ts_ms`\n   --> firmware\\lib\\x_cls_punch_detector_x.py:123:27\n    |\n121 |         return None\n122 |\n123 |     def _emit_event(self, ts_ms):\n    |                           ^^^^^\n124 |         cand = self._candidate\n125 |         if cand is None:\n    |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:6:21\n  |\n4 |     import struct\n5 |\n6 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n7 |     import utime as time  # type: ignore\n8 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\lib\\x_cls_sensor_bno055_x.py:7:27\n  |\n6 |     import machine  # type: ignore\n7 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n8 | except ImportError:  # pragma: no cover - CPython tooling\n9 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:9:21\n   |\n 7 |     import utime as time  # type: ignore\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n   |                     ^^^^^^^^^^^^^^\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:10:20\n   |\n 8 | except ImportError:  # pragma: no cover - CPython tooling\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n   |                    ^^^^^^^^^^^^^^\n11 |     import time  # type: ignore\n   |\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:11:18\n   |\n 9 |     machine = None  # type: ignore\n10 |     import struct  # type: ignore\n11 |     import time  # type: ignore\n   |                  ^^^^^^^^^^^^^^\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:9\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |         ^^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `i2c`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:24\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                        ^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN001 Missing type annotation for function argument `address`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:52:29\n   |\n50 |     \"\"\"Lightweight interface to the BNO055 sensor.\"\"\"\n51 |\n52 |     def __init__(self, i2c, address=_DEFAULT_ADDR):\n   |                             ^^^^^^^\n53 |         self._i2c = i2c\n54 |         self._addr = address\n   |\n\nANN201 Missing return type annotation for public function `initialize`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:57:9\n   |\n55 |         self._mode = _MODE_CONFIG\n56 |\n57 |     def initialize(self):\n   |         ^^^^^^^^^^\n58 |         self._write8(_REG_OPR_MODE, _MODE_CONFIG)\n59 |         sleep_ms(25)\n   |\nhelp: Add return type annotation: `None`\n\nANN201 Missing return type annotation for public function `set_mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:9\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |         ^^^^^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `mode`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:68:24\n   |\n66 |         self.set_mode(_MODE_NDOF)\n67 |\n68 |     def set_mode(self, mode):\n   |                        ^^^^\n69 |         if mode == self._mode:\n70 |             return\n   |\n\nANN201 Missing return type annotation for public function `read_linear_accel`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:75:9\n   |\n73 |         self._mode = mode\n74 |\n75 |     def read_linear_accel(self):\n   |         ^^^^^^^^^^^^^^^^^\n76 |         x, y, z = self._read_vector(_LINEAR_ACCEL_DATA_X_LSB)\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gravity`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:79:9\n   |\n77 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n78 |\n79 |     def read_gravity(self):\n   |         ^^^^^^^^^^^^\n80 |         x, y, z = self._read_vector(_GRAVITY_DATA_X_LSB)\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_gyro`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:83:9\n   |\n81 |         return (x * _SCALE_ACC, y * _SCALE_ACC, z * _SCALE_ACC)\n82 |\n83 |     def read_gyro(self):\n   |         ^^^^^^^^^\n84 |         x, y, z = self._read_vector(_GYRO_DATA_X_LSB)\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_euler`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:87:9\n   |\n85 |         return (x * _SCALE_GYR, y * _SCALE_GYR, z * _SCALE_GYR)\n86 |\n87 |     def read_euler(self):\n   |         ^^^^^^^^^^\n88 |         heading, roll, pitch = self._read_vector(_EULER_H_LSB)\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `read_temperature`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:91:9\n   |\n89 |         return (heading * _SCALE_EUL, roll * _SCALE_EUL, pitch * _SCALE_EUL)\n90 |\n91 |     def read_temperature(self):\n   |         ^^^^^^^^^^^^^^^^\n92 |         buf = self._read_bytes(_REG_TEMP, 1)\n93 |         return float(struct.unpack(\"b\", buf)[0])\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_read_vector`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:9\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |         ^^^^^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n  --> firmware\\lib\\x_cls_sensor_bno055_x.py:95:28\n   |\n93 |         return float(struct.unpack(\"b\", buf)[0])\n94 |\n95 |     def _read_vector(self, register):\n   |                            ^^^^^^^^\n96 |         buf = self._read_bytes(register, 6)\n97 |         x, y, z = struct.unpack(\"<hhh\", buf)\n   |\n\nANN202 Missing return type annotation for private function `_write8`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:9\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |         ^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:23\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                       ^^^^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN001 Missing type annotation for function argument `value`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:100:33\n    |\n 98 |         return x, y, z\n 99 |\n100 |     def _write8(self, register, value):\n    |                                 ^^^^^\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n    |\n\nANN202 Missing return type annotation for private function `_read_bytes`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:9\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |         ^^^^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `register`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:27\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                           ^^^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nANN001 Missing type annotation for function argument `length`\n   --> firmware\\lib\\x_cls_sensor_bno055_x.py:103:37\n    |\n101 |         self._i2c.writeto_mem(self._addr, register, bytes((value & 0xFF,)))\n102 |\n103 |     def _read_bytes(self, register, length):\n    |                                     ^^^^^^\n104 |         return self._i2c.readfrom_mem(self._addr, register, length)\n    |\n\nINP001 File `firmware\\main.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\main.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:4:21\n  |\n3 | try:\n4 |     import machine  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:5:27\n  |\n3 | try:\n4 |     import machine  # type: ignore\n5 |     import utime as time  # type: ignore\n  |                           ^^^^^^^^^^^^^^\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:7:21\n  |\n5 |     import utime as time  # type: ignore\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n  |                     ^^^^^^^^^^^^^^\n8 |     import time  # type: ignore\n  |\n\nPGH003 Use specific rule codes when ignoring type issues\n --> firmware\\main.py:8:18\n  |\n6 | except ImportError:  # pragma: no cover - CPython tooling\n7 |     machine = None  # type: ignore\n8 |     import time  # type: ignore\n  |                  ^^^^^^^^^^^^^^\n  |\n\nANN201 Missing return type annotation for public function `sleep_ms`\n  --> firmware\\main.py:14:9\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |         ^^^^^^^^\n15 |         time.sleep(ms / 1000.0)\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `ms`\n  --> firmware\\main.py:14:18\n   |\n12 |     sleep_ms = time.sleep_ms  # type: ignore[arg-type]\n13 | else:  # pragma: no cover - CPython tooling\n14 |     def sleep_ms(ms):\n   |                  ^^\n15 |         time.sleep(ms / 1000.0)\n   |\n\nANN201 Missing return type annotation for public function `ticks_ms`\n  --> firmware\\main.py:23:9\n   |\n21 |     ticks_diff = time.ticks_diff  # type: ignore[attr-defined]\n22 | else:  # pragma: no cover - CPython tooling\n23 |     def ticks_ms():\n   |         ^^^^^^^^\n24 |         return int(time.time() * 1000)\n   |\nhelp: Add return type annotation\n\nANN201 Missing return type annotation for public function `ticks_add`\n  --> firmware\\main.py:26:9\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |         ^^^^^^^^^\n27 |         return value + delta\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `value`\n  --> firmware\\main.py:26:19\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                   ^^^^^\n27 |         return value + delta\n   |\n\nANN001 Missing type annotation for function argument `delta`\n  --> firmware\\main.py:26:26\n   |\n24 |         return int(time.time() * 1000)\n25 |\n26 |     def ticks_add(value, delta):\n   |                          ^^^^^\n27 |         return value + delta\n   |\n\nANN201 Missing return type annotation for public function `ticks_diff`\n  --> firmware\\main.py:29:9\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |         ^^^^^^^^^^\n30 |         return a - b\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `a`\n  --> firmware\\main.py:29:20\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                    ^\n30 |         return a - b\n   |\n\nANN001 Missing type annotation for function argument `b`\n  --> firmware\\main.py:29:23\n   |\n27 |         return value + delta\n28 |\n29 |     def ticks_diff(a, b):\n   |                       ^\n30 |         return a - b\n   |\n\nANN204 Missing return type annotation for special method `__init__`\n  --> firmware\\main.py:47:9\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |         ^^^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\nhelp: Add return type annotation: `None`\n\nANN001 Missing type annotation for function argument `pin_no`\n  --> firmware\\main.py:47:24\n   |\n46 | class Button:\n47 |     def __init__(self, pin_no):\n   |                        ^^^^^^\n48 |         if machine is None:\n49 |             self._pin = None\n   |\n\nANN201 Missing return type annotation for public function `pressed`\n  --> firmware\\main.py:54:9\n   |\n52 |         self._last = 1\n53 |\n54 |     def pressed(self):\n   |         ^^^^^^^\n55 |         if self._pin is None:\n56 |             return False\n   |\nhelp: Add return type annotation\n\nANN202 Missing return type annotation for private function `_init_sensor`\n  --> firmware\\main.py:63:5\n   |\n63 | def _init_sensor():\n   |     ^^^^^^^^^^^^\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |\nhelp: Add return type annotation\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:65:15\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:65:28\n   |\n63 | def _init_sensor():\n64 |     if machine is None:\n65 |         raise RuntimeError(\"machine module unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n66 |     i2c = machine.I2C(0, scl=machine.Pin(22), sda=machine.Pin(21), freq=400000)\n67 |     sensor = BNO055(i2c)\n   |\nhelp: Assign to variable; remove string literal\n\nANN202 Missing return type annotation for private function `_run_calibration`\n  --> firmware\\main.py:72:5\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |     ^^^^^^^^^^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\nhelp: Add return type annotation\n\nANN001 Missing type annotation for function argument `sensor`\n  --> firmware\\main.py:72:22\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                      ^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `cfg`\n  --> firmware\\main.py:72:30\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                              ^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nANN001 Missing type annotation for function argument `display`\n  --> firmware\\main.py:72:35\n   |\n72 | def _run_calibration(sensor, cfg, display):\n   |                                   ^^^^^^^\n73 |     sample_target = cfg[\"baseline_window\"]\n74 |     calibrator = Calibrator(sample_target)\n   |\n\nC901 `main` is too complex (14 > 10)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0912 Too many branches (15 > 12)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nPLR0915 Too many statements (83 > 50)\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\n\nANN201 Missing return type annotation for public function `main`\n  --> firmware\\main.py:91:5\n   |\n91 | def main():\n   |     ^^^^\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |\nhelp: Add return type annotation: `None`\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> firmware\\main.py:93:15\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\n\nEM101 Exception must not use a string literal, assign to variable first\n  --> firmware\\main.py:93:28\n   |\n91 | def main():\n92 |     if machine is None:\n93 |         raise RuntimeError(\"MicroPython hardware modules unavailable\")\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n94 |\n95 |     cfg = cfg_mod.load_cfg()\n   |\nhelp: Assign to variable; remove string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> firmware\\main.py:110:15\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> firmware\\main.py:110:28\n    |\n108 |     calibrator, cal_result = _run_calibration(sensor, cfg, display)\n109 |     if cal_result is None:\n110 |         raise RuntimeError(\"Calibration failed\")\n    |                            ^^^^^^^^^^^^^^^^^^^^\n111 |     forward_axis = cal_result.forward_axis\n112 |     jerk_noise = cal_result.jerk_noise\n    |\nhelp: Assign to variable; remove string literal\n\nE501 Line too long (97 > 88)\n   --> firmware\\main.py:120:89\n    |\n118 |     for idx in range(limit):\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n    |                                                                                         ^^^^^^^^^\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nE501 Line too long (101 > 88)\n   --> firmware\\main.py:121:89\n    |\n119 |         accel = calibrator.accel_samples[idx]\n120 |         jerk = calibrator.jerk_samples[idx] if idx < len(calibrator.jerk_samples) else jerk_noise\n121 |         omega = calibrator.omega_samples[idx] if idx < len(calibrator.omega_samples) else omega_noise\n    |                                                                                         ^^^^^^^^^^^^^\n122 |         detector.ingest_idle(accel, jerk, omega)\n    |\n\nSIM108 Use ternary operator `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)` instead of `if`-`else`-block\n   --> firmware\\main.py:145:9\n    |\n143 |           classifier.update_orientation(gravity, forward_axis)\n144 |\n145 | /         if last_ts is None:\n146 | |             dt_ms = sample_period\n147 | |         else:\n148 | |             dt_ms = ticks_diff(now, last_ts)\n    | |____________________________________________^\n149 |           last_ts = now\n    |\nhelp: Replace `if`-`else`-block with `dt_ms = sample_period if last_ts is None else ticks_diff(now, last_ts)`\n\nE501 Line too long (92 > 88)\n   --> firmware\\main.py:156:89\n    |\n155 |         if not running:\n156 |             detector.ingest_idle(features.magnitude(linear), jerk, features.magnitude(gyro))\n    |                                                                                         ^^^^\n157 |\n158 |         if start_button.pressed():\n    |\n\nINP001 File `firmware\\secrets_template.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\secrets_template.py:1:1\n\nS105 Possible hardcoded password assigned to: \"PASSWORD\"\n --> firmware\\secrets_template.py:8:12\n  |\n7 | SSID = \"YourNetwork\"\n8 | PASSWORD = \"SuperSecret\"\n  |            ^^^^^^^^^^^^^\n  |\n\nFound 263 errors.\nNo fixes available (55 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_legatus_tactica_impetus_x (exit 1)\ncwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:56:05.455838+00:00\nduration: 0.192s\ntool_version: ruff 0.14.3\nstdout:\nINP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026\nstderr:\n<empty>",
            "repo": "x_legatus_tactica_impetus_x",
            "repo_path": "C:\\x_runner_x\\x_legatus_tactica_impetus_x",
            "stderr_preview": null,
            "stdout_preview": "INP001 File `firmware\\boot.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> firmware\\boot.py:1:1\n\nPGH003 Use specific rule codes when ignoring type issues\n  --> firmware\\boot.py:8:21\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_legatus_tactica_impetus_x (exit 1) cwd: C:\\x_runner_x\\x_legatus_tactica_impetus_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --targ\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:56:30.646360+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_contract_validators_x",
                "duration_seconds": 0.13042509998194873,
                "ended_at": "2025-10-31T03:56:30.646360+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/test_contract_validators.py",
                    "x_cls_make_contract_validators_x.py"
                ],
                "repo": "x_make_contract_validators_x",
                "repo_hash": "cd9f8a9233fa98729305165e2296fe3b58283a12cfcb0d6a3c754adb6ab84622",
                "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
                "started_at": "2025-10-31T03:56:30.521539+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `pathlib` into a type-checking block\n --> tests\\test_contract_validators.py:5:8\n  |\n3 | # ruff: noqa: S101\n4 | import json\n5 | import pathlib\n  |        ^^^^^^^\n6 | from typing import TYPE_CHECKING, cast\n  |\nhelp: Move into type-checking block\n\nPLC0415 `import` should be at the top-level of a file\n  --> x_cls_make_contract_validators_x.py:47:9\n   |\n45 | def _load_validator() -> type[_DraftValidatorProtocol]:\n46 |     try:\n47 |         from jsonschema.validators import Draft202012Validator\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n48 |     except ImportError as exc:  # pragma: no cover - dependency missing\n49 |         message = \"jsonschema Draft202012Validator is unavailable\"\n   |\n\nFound 2 errors.\nNo fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_make_contract_validators_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_contract_validators_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:56:30.521539+00:00\nduration: 0.130s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `pathlib` into a type-checking block\n --> tests\\test_contract_validators.py:5:8\n  |\n3 | # ruff: noqa: S101\n4 | import json\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_contract_validators_x",
            "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `pathlib` into a type-checking block\n --> tests\\test_contract_validators.py:5:8\n  |\n3 | # ruff: noqa: S101\n4 | import json\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_make_contract_validators_x (exit 1) cwd: C:\\x_runner_x\\x_make_contract_validators_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:56:28.018118+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_contract_validators_x",
                "duration_seconds": 0.28137650003191084,
                "ended_at": "2025-10-31T03:56:28.018118+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "tests/__init__.py",
                    "tests/test_contract_validators.py",
                    "x_cls_make_contract_validators_x.py"
                ],
                "repo": "x_make_contract_validators_x",
                "repo_hash": "cd9f8a9233fa98729305165e2296fe3b58283a12cfcb0d6a3c754adb6ab84622",
                "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
                "started_at": "2025-10-31T03:56:27.737998+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `pathlib` into a type-checking block\n --> tests\\test_contract_validators.py:5:8\n  |\n3 | # ruff: noqa: S101\n4 | import json\n5 | import pathlib\n  |        ^^^^^^^\n6 | from typing import TYPE_CHECKING, cast\n  |\nhelp: Move into type-checking block\n\nPLC0415 `import` should be at the top-level of a file\n  --> x_cls_make_contract_validators_x.py:47:9\n   |\n45 | def _load_validator() -> type[_DraftValidatorProtocol]:\n46 |     try:\n47 |         from jsonschema.validators import Draft202012Validator\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n48 |     except ImportError as exc:  # pragma: no cover - dependency missing\n49 |         message = \"jsonschema Draft202012Validator is unavailable\"\n   |\n\nFound 5 errors (3 fixed, 2 remaining).\nNo fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_make_contract_validators_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_contract_validators_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:56:27.737998+00:00\nduration: 0.281s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `pathlib` into a type-checking block\n --> tests\\test_contract_validators.py:5:8\n  |\n3 | # ruff: noqa: S101\n4 | import json\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_contract_validators_x",
            "repo_path": "C:\\x_runner_x\\x_make_contract_validators_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `pathlib` into a type-checking block\n --> tests\\test_contract_validators.py:5:8\n  |\n3 | # ruff: noqa: S101\n4 | import json\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_make_contract_validators_x (exit 1) cwd: C:\\x_runner_x\\x_make_contract_validators_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --ta\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:58:43.801000+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 1.2756927999434993,
                "ended_at": "2025-10-31T03:58:43.801000+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "f99b4f3b6d9335be0324d2251299a8c81f08bb31aa7cbd5471e8c8d41a732d3f",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:58:42.525086+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_make_progress_board_x\\cli.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 4 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-30 21:29:12.888265+00:00\n+++ C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-31 03:58:43.629943+00:00\n@@ -25,11 +25,13 @@\n     return stages\n \n \n def main(argv: Sequence[str] | None = None) -> int:\n     parser = argparse.ArgumentParser(description=\"Launch the PySide6 progress board\")\n-    parser.add_argument(\"--snapshot\", required=True, help=\"Path to progress snapshot JSON\")\n+    parser.add_argument(\n+        \"--snapshot\", required=True, help=\"Path to progress snapshot JSON\"\n+    )\n     args = parser.parse_args(list(argv) if argv is not None else None)\n \n     snapshot_path = Path(args.snapshot).resolve()\n     definitions = _current_stage_layout(snapshot_path)\n     if not definitions:\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T03:58:42.525086+00:00\nduration: 1.276s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-30 21:29:12.888265+00:00\n+++ C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-31 03:58:43.629943+00:00\n@@ -25,11 +25,13 @@\n     return stages\n \n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_make_progress_board_x\\cli.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 4 files would be left unchanged.",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_make_progress_board_x\\cli.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 4 files would be left unchanged.",
            "stdout_preview": "--- C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-30 21:29:12.888265+00:00\n+++ C:\\x_runner_x\\x_make_progress_board_x\\cli.py\t2025-10-31 03:58:43.629943+00:00\n@@ -25,11 +25,13 @@\n     return stages\n \n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-31T03:58:42.\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T03:58:44.819796+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_make_progress_board_x",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 0.8818290000781417,
                "ended_at": "2025-10-31T03:58:44.819796+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "f99b4f3b6d9335be0324d2251299a8c81f08bb31aa7cbd5471e8c8d41a732d3f",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:58:43.947976+00:00",
                "stderr": "",
                "stdout": "progress_board_widget.py:21: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:21: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:22: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:22: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:23: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:23: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:25: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:26: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:27: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:51: error: Class cannot subclass \"QWidget\" (has type \"Any\")  [misc]\nprogress_board_widget.py:51: note: Error code \"misc\" not covered by \"type: ignore\" comment\nprogress_board_widget.py:54: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:76: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:77: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:78: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:79: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:82: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:84: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:85: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:86: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:87: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:88: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:90: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:91: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:93: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:94: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:95: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:97: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:98: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:99: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:100: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:102: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:103: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:104: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:106: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:108: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:109: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:110: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:112: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:113: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:114: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:115: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:117: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:118: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:119: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:122: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:123: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:124: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:126: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:127: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:129: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:130: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:132: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:133: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:135: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:136: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:137: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:140: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:141: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:142: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:143: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:144: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:145: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:148: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:149: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:150: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:151: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:152: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:158: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:163: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:167: error: Expression type contains \"Any\" (has type \"Any | dict[Never, Never]\")  [misc]\nprogress_board_widget.py:167: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:167: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\nprogress_board_widget.py:169: error: Expression type contains \"Any\" (has type \"Any | tuple[Any, Any]\")  [misc]\nprogress_board_widget.py:169: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:169: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:169: error: Expression type contains \"Any\" (has type \"Any | dict_items[Any, Any]\")  [misc]\nprogress_board_widget.py:170: error: Expression type contains \"Any\" (has type \"Any | None\")  [misc]\nprogress_board_widget.py:170: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:171: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:176: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:177: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:178: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:179: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:180: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:181: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:182: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:191: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:192: error: Expression type contains \"Any\" (has type \"Any | tuple[()]\")  [misc]\nprogress_board_widget.py:193: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:193: error: Expression type contains \"Any\" (has type \"Any | tuple[()]\")  [misc]\nprogress_board_widget.py:201: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:205: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:228: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:229: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:231: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:237: error: Expression type contains \"Any\" (has type \"Any | dict[Never, Never]\")  [misc]\nprogress_board_widget.py:237: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:237: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\nprogress_board_widget.py:238: error: Expression type contains \"Any\" (has type \"Any | dict[Any, Any]\")  [misc]\nprogress_board_widget.py:247: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:249: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:254: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:259: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:262: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:263: error: Expression type contains \"Any\" (has type \"tuple[int, Any]\")  [misc]\nprogress_board_widget.py:263: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:263: error: Expression type contains \"Any\" (has type \"enumerate[Any]\")  [misc]\nprogress_board_widget.py:264: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:264: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:265: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:265: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:266: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:266: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:267: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:268: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:273: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:273: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\nprogress_board_widget.py:275: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:276: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:277: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:278: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:279: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:280: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:281: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:282: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:284: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:290: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:291: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:294: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:309: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:311: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:313: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:314: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:374: error: Returning Any from function declared to return \"dict[str, object] | None\"  [no-any-return]\nprogress_board_widget.py:374: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:383: error: Expression type contains \"Any\" (has type \"dict[Any, Any]\")  [misc]\nprogress_board_widget.py:392: error: Expression type contains \"Any\" (has type \"dict[str, object] | Any | bool | None\")  [misc]\nprogress_board_widget.py:392: error: Expression type contains \"Any\" (has type \"Any | bool\")  [misc]\nprogress_board_widget.py:392: error: Expression type contains \"Any\" (has type \"Any | None\")  [misc]\nprogress_board_widget.py:401: error: Expression type contains \"Any\" (has type \"tuple[str, Any | None]\")  [misc]\nprogress_board_widget.py:401: error: Expression type contains \"Any\" (has type \"Any | None\")  [misc]\nprogress_board_widget.py:423: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:425: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:426: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:429: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:430: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:437: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:438: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:441: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:443: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:445: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:448: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:449: error: Expression has type \"Any\"  [misc]\ncli.py:20: error: Expression has type \"Any\"  [misc]\ncli.py:20: error: Expression type contains \"Any\" (has type \"Any | dict[Never, Never]\")  [misc]\ncli.py:20: error: Expression type contains \"Any\" (has type \"Any | dict_values[Never, Never]\")  [misc]\ncli.py:21: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\ncli.py:21: error: Expression has type \"Any\"  [misc]\ncli.py:22: error: Expression type contains \"Any\" (has type \"Any | str\")  [misc]\ncli.py:22: error: Expression has type \"Any\"  [misc]\ncli.py:33: error: Expression has type \"Any\"  [misc]\ntests\\test_progress_board.py:23: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]\ntests\\test_progress_board.py:30: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\ntests\\test_progress_board.py:30: error: Expression has type \"Any\"  [misc]\ntests\\test_progress_board.py:33: error: Expression type contains \"Any\" (has type \"Callable[[NamedArg(Path, 'snapshot_path'), NamedArg(Any, 'stage_definitions'), NamedArg(Event, 'worker_done_event')], None]\")  [misc]\ntests\\test_progress_board.py:67: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]\ntests\\test_progress_board.py:74: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\ntests\\test_progress_board.py:74: error: Expression has type \"Any\"  [misc]\ntests\\test_progress_board.py:78: error: Expression type contains \"Any\" (has type \"Callable[[NamedArg(Path, 'snapshot_path'), NamedArg(Any, 'stage_definitions'), NamedArg(Event, 'worker_done_event')], None]\")  [misc]\nFound 169 errors in 3 files (checked 6 source files)\n",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 1",
            "message": "mypy failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T03:58:43.947976+00:00\nduration: 0.882s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\nprogress_board_widget.py:21: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:21: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:22: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:22: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:23: error: Explicit \"Any\" is not allowed  [explicit-any]\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": null,
            "stdout_preview": "progress_board_widget.py:21: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:21: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:22: error: Explicit \"Any\" is not allowed  [explicit-any]\nprogress_board_widget.py:22: error: Expression has type \"Any\"  [misc]\nprogress_board_widget.py:23: error: Explicit \"Any\" is not allowed  [explicit-any]\n\u2026",
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_progress_board_x --strict --no-warn-unused-configs --show-error-codes --wa\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        },
        {
            "captured_at": "2025-10-31T03:58:43.939404+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 0.14115379995200783,
                "ended_at": "2025-10-31T03:58:43.939404+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "f99b4f3b6d9335be0324d2251299a8c81f08bb31aa7cbd5471e8c8d41a732d3f",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:58:43.803664+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n7 | from collections.abc import Sequence\n  |                             ^^^^^^^^\n8 | from pathlib import Path\n  |\nhelp: Move into type-checking block\n\nE501 Line too long (91 > 88)\n  --> cli.py:30:89\n   |\n28 | def main(argv: Sequence[str] | None = None) -> int:\n29 |     parser = argparse.ArgumentParser(description=\"Launch the PySide6 progress board\")\n30 |     parser.add_argument(\"--snapshot\", required=True, help=\"Path to progress snapshot JSON\")\n   |                                                                                         ^^^\n31 |     args = parser.parse_args(list(argv) if argv is not None else None)\n   |\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n  --> controller.py:8:21\n   |\n 6 | from collections.abc import Callable, Sequence\n 7 | from dataclasses import dataclass\n 8 | from pathlib import Path\n   |                     ^^^^\n 9 |\n10 | from x_make_progress_board_x.progress_board_widget import run_progress_board\n   |\nhelp: Move into type-checking block\n\nN802 Function name `setText` should be lowercase\n  --> progress_board_widget.py:42:9\n   |\n41 | class _ChecklistItem(Protocol):\n42 |     def setText(self, text: str) -> None: ...\n   |         ^^^^^^^\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |\n\nN802 Function name `setCheckState` should be lowercase\n  --> progress_board_widget.py:44:9\n   |\n42 |     def setText(self, text: str) -> None: ...\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |         ^^^^^^^^^^^^^\n   |\n\nINP001 File `tests\\test_progress_board.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> tests\\test_progress_board.py:1:1\n\nTC003 Move standard library import `threading` into a type-checking block\n --> tests\\test_progress_board.py:4:8\n  |\n3 | import json\n4 | import threading\n  |        ^^^^^^^^^\n5 | from pathlib import Path\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_progress_board.py:5:21\n  |\n3 | import json\n4 | import threading\n5 | from pathlib import Path\n  |                     ^^^^\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:26:9\n   |\n24 |         *,\n25 |         snapshot_path: Path,\n26 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n27 |         worker_done_event: threading.Event,\n28 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:39:9\n   |\n37 |     def worker(event: threading.Event) -> None:\n38 |         worker_called.append(True)\n39 |         assert event.is_set() is False\n   |         ^^^^^^\n40 |         event.set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:48:5\n   |\n46 |     )\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n   |     ^^^^^^\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:49:5\n   |\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n   |     ^^^^^^\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:50:5\n   |\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:51:5\n   |\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n   |\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:70:9\n   |\n68 |         *,\n69 |         snapshot_path: Path,\n70 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n71 |         worker_done_event: threading.Event,\n72 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:81:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n   |     ^^^^^^\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:82:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:83:5\n   |\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:85:5\n   |\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |     ^^^^^^\n   |\n\nFound 19 errors.\nNo fixes available (4 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_check",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_check failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:58:43.803664+00:00\nduration: 0.141s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_check failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version p\u2026",
            "tool": "ruff_check",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:58:42.520265+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "ruff",
                    "check",
                    ".",
                    "--fix",
                    "--select",
                    "ALL",
                    "--ignore",
                    "D,COM812,ISC001,T20",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311",
                "cwd": "C:\\x_runner_x\\x_make_progress_board_x",
                "duration_seconds": 0.15148350002709776,
                "ended_at": "2025-10-31T03:58:42.520265+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "cli.py",
                    "controller.py",
                    "progress_board_widget.py",
                    "tests/test_progress_board.py"
                ],
                "repo": "x_make_progress_board_x",
                "repo_hash": "f99b4f3b6d9335be0324d2251299a8c81f08bb31aa7cbd5471e8c8d41a732d3f",
                "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
                "started_at": "2025-10-31T03:58:42.369549+00:00",
                "stderr": "",
                "stdout": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n7 | from collections.abc import Sequence\n  |                             ^^^^^^^^\n8 | from pathlib import Path\n  |\nhelp: Move into type-checking block\n\nE501 Line too long (91 > 88)\n  --> cli.py:30:89\n   |\n28 | def main(argv: Sequence[str] | None = None) -> int:\n29 |     parser = argparse.ArgumentParser(description=\"Launch the PySide6 progress board\")\n30 |     parser.add_argument(\"--snapshot\", required=True, help=\"Path to progress snapshot JSON\")\n   |                                                                                         ^^^\n31 |     args = parser.parse_args(list(argv) if argv is not None else None)\n   |\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n  --> controller.py:8:21\n   |\n 6 | from collections.abc import Callable, Sequence\n 7 | from dataclasses import dataclass\n 8 | from pathlib import Path\n   |                     ^^^^\n 9 |\n10 | from x_make_progress_board_x.progress_board_widget import run_progress_board\n   |\nhelp: Move into type-checking block\n\nN802 Function name `setText` should be lowercase\n  --> progress_board_widget.py:42:9\n   |\n41 | class _ChecklistItem(Protocol):\n42 |     def setText(self, text: str) -> None: ...\n   |         ^^^^^^^\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |\n\nN802 Function name `setCheckState` should be lowercase\n  --> progress_board_widget.py:44:9\n   |\n42 |     def setText(self, text: str) -> None: ...\n43 |\n44 |     def setCheckState(self, state: object) -> None: ...\n   |         ^^^^^^^^^^^^^\n   |\n\nINP001 File `tests\\test_progress_board.py` is part of an implicit namespace package. Add an `__init__.py`.\n--> tests\\test_progress_board.py:1:1\n\nTC003 Move standard library import `threading` into a type-checking block\n --> tests\\test_progress_board.py:4:8\n  |\n3 | import json\n4 | import threading\n  |        ^^^^^^^^^\n5 | from pathlib import Path\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nTC003 Move standard library import `pathlib.Path` into a type-checking block\n --> tests\\test_progress_board.py:5:21\n  |\n3 | import json\n4 | import threading\n5 | from pathlib import Path\n  |                     ^^^^\n6 | from typing import cast\n  |\nhelp: Move into type-checking block\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:26:9\n   |\n24 |         *,\n25 |         snapshot_path: Path,\n26 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n27 |         worker_done_event: threading.Event,\n28 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:39:9\n   |\n37 |     def worker(event: threading.Event) -> None:\n38 |         worker_called.append(True)\n39 |         assert event.is_set() is False\n   |         ^^^^^^\n40 |         event.set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:48:5\n   |\n46 |     )\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n   |     ^^^^^^\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:49:5\n   |\n47 |     result.thread.join(timeout=1)\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n   |     ^^^^^^\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:50:5\n   |\n48 |     assert result.done_event.is_set() is True\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:51:5\n   |\n49 |     assert worker_called\n50 |     assert observed[\"snapshot_path\"] == snapshot_path\n51 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n   |\n\nANN001 Missing type annotation for function argument `stage_definitions`\n  --> tests\\test_progress_board.py:70:9\n   |\n68 |         *,\n69 |         snapshot_path: Path,\n70 |         stage_definitions,\n   |         ^^^^^^^^^^^^^^^^^\n71 |         worker_done_event: threading.Event,\n72 |     ) -> None:\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:81:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n   |     ^^^^^^\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:82:5\n   |\n80 |     exit_code = cli.main([\"--snapshot\", str(snapshot_path)])\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n   |     ^^^^^^\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:83:5\n   |\n81 |     assert exit_code == 0\n82 |     assert observed[\"snapshot_path\"] == snapshot_path\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n   |     ^^^^^^\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |\n\nS101 Use of `assert` detected\n  --> tests\\test_progress_board.py:85:5\n   |\n83 |     assert observed[\"stage_definitions\"] == [(\"env\", \"Environment\")]\n84 |     event = cast(\"threading.Event\", observed[\"event\"])\n85 |     assert event.is_set()\n   |     ^^^^^^\n   |\n\nFound 19 errors.\nNo fixes available (4 hidden fixes can be enabled with the `--unsafe-fixes` option).\n",
                "tool": "ruff_fix",
                "tool_module": "ruff",
                "tool_version": "ruff 0.14.3"
            },
            "exit": "exit 1",
            "message": "ruff_fix failed for x_make_progress_board_x (exit 1)\ncwd: C:\\x_runner_x\\x_make_progress_board_x\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-version py311\nstarted_at: 2025-10-31T03:58:42.369549+00:00\nduration: 0.151s\ntool_version: ruff 0.14.3\nstdout:\nTC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_progress_board_x",
            "repo_path": "C:\\x_runner_x\\x_make_progress_board_x",
            "stderr_preview": null,
            "stdout_preview": "TC003 Move standard library import `collections.abc.Sequence` into a type-checking block\n --> cli.py:7:29\n  |\n5 | import argparse\n6 | import threading\n\u2026",
            "suggested_action": "Investigate",
            "summary": "ruff_fix failed for x_make_progress_board_x (exit 1) cwd: C:\\x_runner_x\\x_make_progress_board_x command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m ruff check . --fix --select ALL --ignore D,COM812,ISC001,T20 --line-length 88 --target-versi\u2026",
            "tool": "ruff_fix",
            "tool_version": "ruff 0.14.3"
        },
        {
            "captured_at": "2025-10-31T03:59:46.277717+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "black",
                    ".",
                    "--line-length",
                    "88",
                    "--target-version",
                    "py311",
                    "--check",
                    "--diff"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff",
                "cwd": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "duration_seconds": 2.0989708000561222,
                "ended_at": "2025-10-31T03:59:46.277717+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "__main__.py",
                    "json_contracts/__init__.py",
                    "tests/__init__.py",
                    "tests/test_json_contracts.py",
                    "tests/test_slack_dump_and_reset.py",
                    "x_cls_make_slack_dump_and_reset_x.py"
                ],
                "repo": "x_make_slack_dump_and_reset_z",
                "repo_hash": "23d9bac4eefdfbd15ae230877dd10f39c521e6d1ffc09c999ab280583774c39b",
                "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "started_at": "2025-10-31T03:59:44.190306+00:00",
                "stderr": "would reformat C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 6 files would be left unchanged.\n",
                "stdout": "--- C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-30 18:16:19.336325+00:00\n+++ C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-31 03:59:46.109013+00:00\n@@ -886,11 +886,11 @@\n             raise RuntimeError(message)\n         return Path(archive_root_raw).expanduser().resolve()\n \n     @staticmethod\n     def _parse_channels(\n-        parameters_raw: Mapping[str, object]\n+        parameters_raw: Mapping[str, object],\n     ) -> list[str | Mapping[str, object]]:\n         channels_raw = parameters_raw.get(\"channels\")\n         if (\n             not isinstance(channels_raw, Sequence)\n             or isinstance(channels_raw, (str, bytes))\n@@ -947,13 +947,11 @@\n         if not archive_root.exists():\n             message = f\"Archive root does not exist: {archive_root}\"\n             raise FileNotFoundError(message)\n         subdirectories = [item for item in archive_root.iterdir() if item.is_dir()]\n         if not subdirectories:\n-            message = (\n-                f\"Archive root {archive_root} has no subdirectories to target\"\n-            )\n+            message = f\"Archive root {archive_root} has no subdirectories to target\"\n             raise FileNotFoundError(message)\n         return max(subdirectories, key=lambda item: item.stat().st_mtime)\n \n     @staticmethod\n     def _normalise_channel_identifier(\n@@ -1038,12 +1036,11 @@\n     if bool(parameters_obj.get(\"dry_run\", False)):\n         return\n \n     while True:\n         prompt = (\n-            \"Archive captured. Delete Slack messages and files after export?\"\n-            \" [y/N]: \"\n+            \"Archive captured. Delete Slack messages and files after export?\" \" [y/N]: \"\n         )\n         response = input(prompt).strip().lower()\n         if response in {\"y\", \"yes\"}:\n             print(\n                 \"Confirmed. Slack source will be purged post-export.\", file=sys.stderr\n",
                "tool": "black",
                "tool_module": "black",
                "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
            },
            "exit": "exit 1",
            "message": "black failed for x_make_slack_dump_and_reset_z (exit 1)\ncwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff\nstarted_at: 2025-10-31T03:59:44.190306+00:00\nduration: 2.099s\ntool_version: python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6\nstdout:\n--- C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-30 18:16:19.336325+00:00\n+++ C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-31 03:59:46.109013+00:00\n@@ -886,11 +886,11 @@\n             raise RuntimeError(message)\n         return Path(archive_root_raw).expanduser().resolve()\n\u2026\nstderr:\nwould reformat C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 6 files would be left unchanged.",
            "repo": "x_make_slack_dump_and_reset_z",
            "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
            "stderr_preview": "would reformat C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\n\nOh no! \\U0001f4a5 \\U0001f494 \\U0001f4a5\n1 file would be reformatted, 6 files would be left unchanged.",
            "stdout_preview": "--- C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-30 18:16:19.336325+00:00\n+++ C:\\x_runner_x\\x_make_slack_dump_and_reset_z\\x_cls_make_slack_dump_and_reset_x.py\t2025-10-31 03:59:46.109013+00:00\n@@ -886,11 +886,11 @@\n             raise RuntimeError(message)\n         return Path(archive_root_raw).expanduser().resolve()\n\u2026",
            "suggested_action": "Investigate",
            "summary": "black failed for x_make_slack_dump_and_reset_z (exit 1) cwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m black . --line-length 88 --target-version py311 --check --diff started_at: 2025-10-\u2026",
            "tool": "black",
            "tool_version": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6"
        },
        {
            "captured_at": "2025-10-31T03:59:47.723668+00:00",
            "command": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
            "detail": {
                "cached": false,
                "cmd": [
                    "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
                    "-m",
                    "mypy",
                    "--package",
                    "x_make_slack_dump_and_reset_z",
                    "--strict",
                    "--no-warn-unused-configs",
                    "--show-error-codes",
                    "--warn-return-any",
                    "--warn-unreachable",
                    "--disallow-any-unimported",
                    "--disallow-any-expr",
                    "--disallow-any-decorated",
                    "--disallow-any-explicit"
                ],
                "cmd_display": "C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit",
                "cwd": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "duration_seconds": 1.317923300084658,
                "ended_at": "2025-10-31T03:59:47.723668+00:00",
                "exit": 1,
                "failed_files": [],
                "files_checked": [
                    "__init__.py",
                    "__main__.py",
                    "json_contracts/__init__.py",
                    "tests/__init__.py",
                    "tests/test_json_contracts.py",
                    "tests/test_slack_dump_and_reset.py",
                    "x_cls_make_slack_dump_and_reset_x.py"
                ],
                "repo": "x_make_slack_dump_and_reset_z",
                "repo_hash": "23d9bac4eefdfbd15ae230877dd10f39c521e6d1ffc09c999ab280583774c39b",
                "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
                "started_at": "2025-10-31T03:59:46.420961+00:00",
                "stderr": "",
                "stdout": "x_cls_make_slack_dump_and_reset_x.py:120: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_slack_dump_and_reset_x.py:676: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression type contains \"Any\" (has type \"Callable[[Any], Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1074: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1087: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1088: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1093: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1094: error: Expression has type \"Any\"  [misc]\nFound 9 errors in 1 file (checked 7 source files)\n",
                "tool": "mypy",
                "tool_module": "mypy",
                "tool_version": "mypy 1.18.2 (compiled: yes)"
            },
            "exit": "exit 1",
            "message": "mypy failed for x_make_slack_dump_and_reset_z (exit 1)\ncwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z\ncommand: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --show-error-codes --warn-return-any --warn-unreachable --disallow-any-unimported --disallow-any-expr --disallow-any-decorated --disallow-any-explicit\nstarted_at: 2025-10-31T03:59:46.420961+00:00\nduration: 1.318s\ntool_version: mypy 1.18.2 (compiled: yes)\nstdout:\nx_cls_make_slack_dump_and_reset_x.py:120: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_slack_dump_and_reset_x.py:676: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression type contains \"Any\" (has type \"Callable[[Any], Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1074: error: Expression has type \"Any\"  [misc]\n\u2026\nstderr:\n<empty>",
            "repo": "x_make_slack_dump_and_reset_z",
            "repo_path": "C:\\x_runner_x\\x_make_slack_dump_and_reset_z",
            "stderr_preview": null,
            "stdout_preview": "x_cls_make_slack_dump_and_reset_x.py:120: error: Unused \"type: ignore\" comment  [unused-ignore]\nx_cls_make_slack_dump_and_reset_x.py:676: error: Expression type contains \"Any\" (has type \"list[Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression type contains \"Any\" (has type \"Callable[[Any], Any]\")  [misc]\nx_cls_make_slack_dump_and_reset_x.py:956: error: Expression has type \"Any\"  [misc]\nx_cls_make_slack_dump_and_reset_x.py:1074: error: Expression has type \"Any\"  [misc]\n\u2026",
            "suggested_action": "Investigate",
            "summary": "mypy failed for x_make_slack_dump_and_reset_z (exit 1) cwd: C:\\x_runner_x\\x_make_slack_dump_and_reset_z command: C:\\x_runner_x\\.venv\\Scripts\\python.exe -m mypy --package x_make_slack_dump_and_reset_z --strict --no-warn-unused-configs --sho\u2026",
            "tool": "mypy",
            "tool_version": "mypy 1.18.2 (compiled: yes)"
        }
    ],
    "generated_at": "2025-10-31T03:59:53.126995+00:00",
    "runtime": {
        "environment": {
            "PATH": "C:\\windows\\system32;C:\\windows;C:\\windows\\System32\\Wbem;C:\\windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\windows\\System32\\OpenSSH\\;C:\\Program Files\\Git\\cmd;C:\\Program Files\\HP\\HP One Agent;C:\\Users\\eye43\\AppData\\Local\\Programs\\Python\\Launcher\\;C:\\Users\\eye43\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\x_runner_x\\tools\\node-v20.11.1-win-x64\\node-v20.11.1-win-x64;C:\\x_runner_x\\tools\\node-v20.11.1-win-x64\\node-v20.11.1-win-x64\\node_modules\\npm\\bin;C:\\Users\\eye43\\AppData\\Local\\Programs\\Python\\Python314\\Scripts;c:\\Users\\eye43\\.vscode\\extensions\\ms-python.debugpy-2025.14.1-win32-x64\\bundled\\scripts\\noConfigScripts;c:\\Users\\eye43\\AppData\\Roaming\\Code\\User\\globalStorage\\github.copilot-chat\\debugCommand",
            "PYTHONPATH": "c:\\x_runner_x"
        },
        "platform": "Windows-11-10.0.26100-SP0",
        "python_executable": "C:\\x_runner_x\\.venv\\Scripts\\python.exe",
        "python_version": "3.12.6 (main, Sep  9 2024, 20:50:27) [MSC v.1929 64 bit (AMD64)]",
        "run_completed_at": "2025-10-31T03:59:53.126641+00:00",
        "run_started_at": "2025-10-31T03:54:47.107463+00:00",
        "workspace_root": "C:\\x_runner_x"
    },
    "schema_version": "1.0",
    "summary": {
        "overall_stats": {
            "cache_hits": 49,
            "cache_misses": 61,
            "failed_tools": 13,
            "had_failures": true,
            "total_tools_run": 110
        },
        "repos": {
            "x_0_make_all_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "71d58f14f9556b6aded5bb4b8f73b3398af2bab78e7f35c4777e93adf51eca51",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_0_make_ppnw_dot_ai_venvs_x": {
                "cached": 2,
                "failed": 0,
                "repo_hash": "aab97556cecaa26d836e8f909d66208e47f10f98842760b68016079475cac8d7",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_0_make_ppnw_dot_ai_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "d4b7468271386d3b12a64de728bc687dffe0b3d5688406e6b141f25ef5214db8",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_legatus_acta_schedae_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "7570b71cff757450e17ef480704d8aa1a23f29ab9dfa364ff9b12e028b0e8149",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_legatus_capsula_calculus_x": {
                "cached": 2,
                "failed": 0,
                "repo_hash": "4bcde11d4f4e764c44772232ee06cc7ffdb5de7d70358d4235b11375078a4a33",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_legatus_tactica_impetus_x": {
                "cached": 0,
                "failed": 5,
                "repo_hash": "60eec4632cb4ef6a48af31080c4315fd7e6ad7cb201d6276fedd8ae3bba43311",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 2,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_cli_scaffolder_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "830816c5001cdb40e64dfc2ade4bdd1512d4065a0999e428aeafe239e7098924",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_common_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "36370f984177f8c11806f6dbdb63b91a88a9ff45ee453ba8de86f58dfcf7ad68",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_contract_validators_x": {
                "cached": 0,
                "failed": 2,
                "repo_hash": "cd9f8a9233fa98729305165e2296fe3b58283a12cfcb0d6a3c754adb6ab84622",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_github_clones_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "bdf6dbbcebbebb05082069f6300ac9c904b4b0df12e8a7a870901c2ba4b12048",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_github_visitor_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "313764e5b766f938b8b039b17a290b924fb69d218eda466e5845baf9aead1e59",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_graphviz_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "11f50bd2173049d7ebe9b1f6b91ff25cf63c1d4edf531c7f098e1fbbbd380810",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_markdown_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "ebfb021d8e9336f67c244fec5511d7e8321f46946d6865decf8c992288ffe0a7",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_mermaid_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "f0ad607723e8bb9f766b3a622bdc4c6fb4861e178d4df508223b7ac7e32716ab",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_persistent_env_var_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "a2d989a79377c86db138b35d6a6a5431d51f6f852333e86663a30620b4be14cd",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_pip_updates_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "f79f06968316a5e3c102f3151d5afecacaff7582319e70b7a722533d22029b8c",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_progress_board_x": {
                "cached": 0,
                "failed": 4,
                "repo_hash": "f99b4f3b6d9335be0324d2251299a8c81f08bb31aa7cbd5471e8c8d41a732d3f",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    }
                }
            },
            "x_make_py_mod_sideload_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "e73d5c6b1f833a1bc453d3ce7914f2327f8f19e000001b529b78501356825512",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_py_venv_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "b6cdc9357da6d257d5d6c635b287d0f70d57a3b72c937661963eb18bcadcb68d",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_pypi_x": {
                "cached": 0,
                "failed": 0,
                "repo_hash": "22741b01eeb3935ff6dc5efb5e07b076383bd359759f5e824ec31b813107c451",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_slack_dump_and_reset_z": {
                "cached": 0,
                "failed": 2,
                "repo_hash": "23d9bac4eefdfbd15ae230877dd10f39c521e6d1ffc09c999ab280583774c39b",
                "tools": {
                    "black": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": false,
                        "exit": 1,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": false,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            },
            "x_make_yahw_x": {
                "cached": 5,
                "failed": 0,
                "repo_hash": "33756efd77e902ab6182399ad7985b466cbfbc76fdc267da9a54f7b892e944f2",
                "tools": {
                    "black": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "mypy": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "pyright": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_check": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    },
                    "ruff_fix": {
                        "cached": true,
                        "exit": 0,
                        "timed_out": false
                    }
                }
            }
        },
        "timestamp": "2025-10-31T03:59:53.126995+00:00",
        "total_repos": 22
    },
    "tool_versions": {
        "black": "python -m black, 25.9.0 (compiled: yes)\nPython (CPython) 3.12.6",
        "mypy": "mypy 1.18.2 (compiled: yes)",
        "pyright": "pyright 1.1.407",
        "ruff": "ruff 0.14.3"
    },
    "workspace_root": "C:\\x_runner_x"
}