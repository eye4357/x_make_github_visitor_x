{
    "cached": false,
    "exit": 1,
    "stderr": "",
    "stdout": "BLE001 Do not catch blind exception: `Exception`\n  --> forceit.py:53:12\n   |\n51 |     try:\n52 |         return str(p.relative_to(root))\n53 |     except Exception:\n   |            ^^^^^^^^^\n54 |         return str(p)\n   |\n\nC901 `main` is too complex (17 > 10)\n  --> forceit.py:57:5\n   |\n57 | def main() -> int:\n   |     ^^^^\n58 |     src_root = _repo_parent_root()\n59 |     if not src_root.is_dir():\n   |\n\nPLR0912 Too many branches (16 > 12)\n  --> forceit.py:57:5\n   |\n57 | def main() -> int:\n   |     ^^^^\n58 |     src_root = _repo_parent_root()\n59 |     if not src_root.is_dir():\n   |\n\nPLR0915 Too many statements (56 > 50)\n  --> forceit.py:57:5\n   |\n57 | def main() -> int:\n   |     ^^^^\n58 |     src_root = _repo_parent_root()\n59 |     if not src_root.is_dir():\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n  --> forceit.py:89:20\n   |\n87 |             try:\n88 |                 same = filecmp.cmp(s, d, shallow=False)\n89 |             except Exception:\n   |                    ^^^^^^^^^\n90 |                 same = False\n91 |             if same:\n   |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> forceit.py:99:20\n    |\n 97 |                 copied += 1\n 98 |                 copied_pairs.append((s, d))\n 99 |             except Exception as e:\n    |                    ^^^^^^^^^\n100 |                 print(f\"ERROR copying {s} -> {d}: {e}\", file=sys.stderr)\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> forceit.py:122:20\n    |\n120 |                 rel = d.relative_to(DEST)\n121 |                 pkg = rel.parts[0] if rel.parts else d.name\n122 |             except Exception:\n    |                    ^^^^^^^^^\n123 |                 pkg = d.name\n124 |             pkg_counter[pkg] += 1\n    |\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n  --> x_cls_make_all_x.py:16:19\n   |\n14 | from typing import TYPE_CHECKING, Any, ClassVar, TypeAlias, cast\n15 |\n16 | _WORKSPACE_ROOT = os.path.abspath(\n   |                   ^^^^^^^^^^^^^^^\n17 |     os.path.join(os.path.dirname(__file__), \"..\")\n18 | )\n   |\nhelp: Replace with `Path(...).resolve()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n  --> x_cls_make_all_x.py:17:5\n   |\n16 | _WORKSPACE_ROOT = os.path.abspath(\n17 |     os.path.join(os.path.dirname(__file__), \"..\")\n   |     ^^^^^^^^^^^^\n18 | )\n   |\n\nPTH120 `os.path.dirname()` should be replaced by `Path.parent`\n  --> x_cls_make_all_x.py:17:18\n   |\n16 | _WORKSPACE_ROOT = os.path.abspath(\n17 |     os.path.join(os.path.dirname(__file__), \"..\")\n   |                  ^^^^^^^^^^^^^^^\n18 | )\n   |\nhelp: Replace with `Path(...).parent`\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `_import_class_from_candidates`\n  --> x_cls_make_all_x.py:29:75\n   |\n29 | def _import_class_from_candidates(attr: str, modules: tuple[str, ...]) -> Any:\n   |                                                                           ^^^\n30 |     for module_name in modules:\n31 |         try:\n   |\n\nTRY003 Avoid specifying long messages outside the exception class\n  --> x_cls_make_all_x.py:39:11\n   |\n37 |           except AttributeError:\n38 |               continue\n39 |       raise ModuleNotFoundError(\n   |  ___________^\n40 | |         f\"Unable to import {attr} from any candidate module: {modules}\"\n41 | |     )\n   | |_____^\n   |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n  --> x_cls_make_all_x.py:40:9\n   |\n38 |             continue\n39 |     raise ModuleNotFoundError(\n40 |         f\"Unable to import {attr} from any candidate module: {modules}\"\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n41 |     )\n   |\nhelp: Assign to variable; remove f-string literal\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:100:5\n    |\n 98 |   def _info(*args: object) -> None:\n 99 |       msg = \" \".join(str(a) for a in args)\n100 | /     try:\n101 | |         _LOGGER.info(\"%s\", msg)\n102 | |     except Exception:\n103 | |         pass\n    | |____________^\n104 |       try:\n105 |           print(msg)\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:102:5\n    |\n100 |       try:\n101 |           _LOGGER.info(\"%s\", msg)\n102 | /     except Exception:\n103 | |         pass\n    | |____________^\n104 |       try:\n105 |           print(msg)\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:102:12\n    |\n100 |     try:\n101 |         _LOGGER.info(\"%s\", msg)\n102 |     except Exception:\n    |            ^^^^^^^^^\n103 |         pass\n104 |     try:\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:106:12\n    |\n104 |     try:\n105 |         print(msg)\n106 |     except Exception:\n    |            ^^^^^^^^^\n107 |         try:\n108 |             sys.stdout.write(msg + \"\\n\")\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:107:9\n    |\n105 |           print(msg)\n106 |       except Exception:\n107 | /         try:\n108 | |             sys.stdout.write(msg + \"\\n\")\n109 | |         except Exception:\n110 | |             pass\n    | |________________^\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:109:9\n    |\n107 |           try:\n108 |               sys.stdout.write(msg + \"\\n\")\n109 | /         except Exception:\n110 | |             pass\n    | |________________^\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:109:16\n    |\n107 |         try:\n108 |             sys.stdout.write(msg + \"\\n\")\n109 |         except Exception:\n    |                ^^^^^^^^^\n110 |             pass\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:115:5\n    |\n113 |   def _error(*args: object) -> None:\n114 |       msg = \" \".join(str(a) for a in args)\n115 | /     try:\n116 | |         _LOGGER.error(\"%s\", msg)\n117 | |     except Exception:\n118 | |         pass\n    | |____________^\n119 |       try:\n120 |           print(msg, file=sys.stderr)\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:117:5\n    |\n115 |       try:\n116 |           _LOGGER.error(\"%s\", msg)\n117 | /     except Exception:\n118 | |         pass\n    | |____________^\n119 |       try:\n120 |           print(msg, file=sys.stderr)\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:117:12\n    |\n115 |     try:\n116 |         _LOGGER.error(\"%s\", msg)\n117 |     except Exception:\n    |            ^^^^^^^^^\n118 |         pass\n119 |     try:\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:121:12\n    |\n119 |     try:\n120 |         print(msg, file=sys.stderr)\n121 |     except Exception:\n    |            ^^^^^^^^^\n122 |         try:\n123 |             sys.stderr.write(msg + \"\\n\")\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:122:9\n    |\n120 |           print(msg, file=sys.stderr)\n121 |       except Exception:\n122 | /         try:\n123 | |             sys.stderr.write(msg + \"\\n\")\n124 | |         except Exception:\n125 | |             pass\n    | |________________^\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:124:9\n    |\n122 |           try:\n123 |               sys.stderr.write(msg + \"\\n\")\n124 | /         except Exception:\n125 | |             pass\n    | |________________^\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:124:16\n    |\n122 |         try:\n123 |             sys.stderr.write(msg + \"\\n\")\n124 |         except Exception:\n    |                ^^^^^^^^^\n125 |             pass\n    |\n\nFBT001 Boolean-typed positional argument in function definition\n   --> x_cls_make_all_x.py:128:29\n    |\n128 | def get_env_bool(name: str, default: bool = False) -> bool:\n    |                             ^^^^^^^\n129 |     v = os.environ.get(name)\n130 |     if v is None:\n    |\n\nFBT002 Boolean default positional argument in function definition\n   --> x_cls_make_all_x.py:128:29\n    |\n128 | def get_env_bool(name: str, default: bool = False) -> bool:\n    |                             ^^^^^^^\n129 |     v = os.environ.get(name)\n130 |     if v is None:\n    |\n\nE501 Line too long (97 > 88)\n   --> x_cls_make_all_x.py:152:89\n    |\n150 |     OrchestratorContext = _Any\n151 | else:\n152 |     # At runtime prefer the orchestrator_core helper if available; otherwise fall back to globals\n    |                                                                                         ^^^^^^^^^\n153 |     try:\n154 |         # Dynamically import the optional runtime helper to avoid static\n    |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:162:5\n    |\n160 |           if _bcf is not None:\n161 |               _build_context_from_config = _bcf\n162 | /     except Exception:\n163 | |         # leave _build_context_from_config as the previously-set value\n164 | |         pass\n    | |____________^\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:162:12\n    |\n160 |         if _bcf is not None:\n161 |             _build_context_from_config = _bcf\n162 |     except Exception:\n    |            ^^^^^^^^^\n163 |         # leave _build_context_from_config as the previously-set value\n164 |         pass\n    |\n\nC901 `validate_publish_manifest` is too complex (15 > 10)\n   --> x_cls_make_all_x.py:177:5\n    |\n177 | def validate_publish_manifest(\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n178 |     data: Any,\n179 | ) -> list[ManifestEntry]:\n    |\n\nPLR0912 Too many branches (16 > 12)\n   --> x_cls_make_all_x.py:177:5\n    |\n177 | def validate_publish_manifest(\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n178 |     data: Any,\n179 | ) -> list[ManifestEntry]:\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `data`\n   --> x_cls_make_all_x.py:178:11\n    |\n177 | def validate_publish_manifest(\n178 |     data: Any,\n    |           ^^^\n179 | ) -> list[ManifestEntry]:\n180 |     \"\"\"Validate the loaded manifest JSON and return a typed list of valid entries.\n    |\n\nE501 Line too long (102 > 88)\n   --> x_cls_make_all_x.py:186:89\n    |\n184 |       - version (str)\n185 |       - ancillary names (list[str] or null)\n186 |       - opts (object/dict) with optional keys (author, email, description, license_text, dependencies)\n    |                                                                                         ^^^^^^^^^^^^^^\n187 |\n188 |     Invalid entries are ignored and an error is logged.\n    |\n\nPLR2004 Magic value used in comparison, consider replacing `4` with a constant variable\n   --> x_cls_make_all_x.py:202:32\n    |\n200 |             if isinstance(raw, list):\n201 |                 lst = cast(\"list[object]\", raw)\n202 |                 if len(lst) != 4:\n    |                                ^\n203 |                     raise TypeError(\n204 |                         f\"entry must be a 4-tuple/list, got list with len {len(lst)}\"\n    |\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:203:21\n    |\n201 |                   lst = cast(\"list[object]\", raw)\n202 |                   if len(lst) != 4:\n203 | /                     raise TypeError(\n204 | |                         f\"entry must be a 4-tuple/list, got list with len {len(lst)}\"\n205 | |                     )\n    | |_____________________^\n206 |                   name, version, anc, opts = lst[0], lst[1], lst[2], lst[3]\n207 |               elif isinstance(raw, tuple):\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:203:27\n    |\n201 |                   lst = cast(\"list[object]\", raw)\n202 |                   if len(lst) != 4:\n203 |                       raise TypeError(\n    |  ___________________________^\n204 | |                         f\"entry must be a 4-tuple/list, got list with len {len(lst)}\"\n205 | |                     )\n    | |_____________________^\n206 |                   name, version, anc, opts = lst[0], lst[1], lst[2], lst[3]\n207 |               elif isinstance(raw, tuple):\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:204:25\n    |\n202 |                 if len(lst) != 4:\n203 |                     raise TypeError(\n204 |                         f\"entry must be a 4-tuple/list, got list with len {len(lst)}\"\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n205 |                     )\n206 |                 name, version, anc, opts = lst[0], lst[1], lst[2], lst[3]\n    |\nhelp: Assign to variable; remove f-string literal\n\nPLR2004 Magic value used in comparison, consider replacing `4` with a constant variable\n   --> x_cls_make_all_x.py:209:32\n    |\n207 |             elif isinstance(raw, tuple):\n208 |                 tpl = cast(\"tuple[object, ...]\", raw)\n209 |                 if len(tpl) != 4:\n    |                                ^\n210 |                     raise TypeError(\n211 |                         f\"entry must be a 4-tuple/list, got tuple with len {len(tpl)}\"\n    |\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:210:21\n    |\n208 |                   tpl = cast(\"tuple[object, ...]\", raw)\n209 |                   if len(tpl) != 4:\n210 | /                     raise TypeError(\n211 | |                         f\"entry must be a 4-tuple/list, got tuple with len {len(tpl)}\"\n212 | |                     )\n    | |_____________________^\n213 |                   name, version, anc, opts = tpl\n214 |               else:\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:210:27\n    |\n208 |                   tpl = cast(\"tuple[object, ...]\", raw)\n209 |                   if len(tpl) != 4:\n210 |                       raise TypeError(\n    |  ___________________________^\n211 | |                         f\"entry must be a 4-tuple/list, got tuple with len {len(tpl)}\"\n212 | |                     )\n    | |_____________________^\n213 |                   name, version, anc, opts = tpl\n214 |               else:\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:211:25\n    |\n209 |                 if len(tpl) != 4:\n210 |                     raise TypeError(\n211 |                         f\"entry must be a 4-tuple/list, got tuple with len {len(tpl)}\"\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n212 |                     )\n213 |                 name, version, anc, opts = tpl\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:215:17\n    |\n213 |                   name, version, anc, opts = tpl\n214 |               else:\n215 | /                 raise TypeError(\n216 | |                     f\"entry must be a 4-tuple/list, got {type(raw)!r}\"\n217 | |                 )\n    | |_________________^\n218 |\n219 |               if not isinstance(name, str) or not name:\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:215:23\n    |\n213 |                   name, version, anc, opts = tpl\n214 |               else:\n215 |                   raise TypeError(\n    |  _______________________^\n216 | |                     f\"entry must be a 4-tuple/list, got {type(raw)!r}\"\n217 | |                 )\n    | |_________________^\n218 |\n219 |               if not isinstance(name, str) or not name:\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:216:21\n    |\n214 |             else:\n215 |                 raise TypeError(\n216 |                     f\"entry must be a 4-tuple/list, got {type(raw)!r}\"\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n217 |                 )\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:220:17\n    |\n219 |             if not isinstance(name, str) or not name:\n220 |                 raise TypeError(\"name must be non-empty string\")\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n221 |             if not isinstance(version, str) or not version:\n222 |                 raise TypeError(\"version must be non-empty string\")\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:220:23\n    |\n219 |             if not isinstance(name, str) or not name:\n220 |                 raise TypeError(\"name must be non-empty string\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n221 |             if not isinstance(version, str) or not version:\n222 |                 raise TypeError(\"version must be non-empty string\")\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_all_x.py:220:33\n    |\n219 |             if not isinstance(name, str) or not name:\n220 |                 raise TypeError(\"name must be non-empty string\")\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n221 |             if not isinstance(version, str) or not version:\n222 |                 raise TypeError(\"version must be non-empty string\")\n    |\nhelp: Assign to variable; remove string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:222:17\n    |\n220 |                 raise TypeError(\"name must be non-empty string\")\n221 |             if not isinstance(version, str) or not version:\n222 |                 raise TypeError(\"version must be non-empty string\")\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n223 |\n224 |             anc_list: list[str] | None\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:222:23\n    |\n220 |                 raise TypeError(\"name must be non-empty string\")\n221 |             if not isinstance(version, str) or not version:\n222 |                 raise TypeError(\"version must be non-empty string\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n223 |\n224 |             anc_list: list[str] | None\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_all_x.py:222:33\n    |\n220 |                 raise TypeError(\"name must be non-empty string\")\n221 |             if not isinstance(version, str) or not version:\n222 |                 raise TypeError(\"version must be non-empty string\")\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n223 |\n224 |             anc_list: list[str] | None\n    |\nhelp: Assign to variable; remove string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:227:21\n    |\n225 |               if anc is not None:\n226 |                   if not isinstance(anc, list):\n227 | /                     raise TypeError(\n228 | |                         \"ancillaries must be null or list of strings\"\n229 | |                     )\n    | |_____________________^\n230 |                   anc_seq = cast(\"list[object]\", anc)\n231 |                   if not all(isinstance(x, str) for x in anc_seq):\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:227:27\n    |\n225 |               if anc is not None:\n226 |                   if not isinstance(anc, list):\n227 |                       raise TypeError(\n    |  ___________________________^\n228 | |                         \"ancillaries must be null or list of strings\"\n229 | |                     )\n    | |_____________________^\n230 |                   anc_seq = cast(\"list[object]\", anc)\n231 |                   if not all(isinstance(x, str) for x in anc_seq):\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_all_x.py:228:25\n    |\n226 |                 if not isinstance(anc, list):\n227 |                     raise TypeError(\n228 |                         \"ancillaries must be null or list of strings\"\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n229 |                     )\n230 |                 anc_seq = cast(\"list[object]\", anc)\n    |\nhelp: Assign to variable; remove string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:232:21\n    |\n230 |                 anc_seq = cast(\"list[object]\", anc)\n231 |                 if not all(isinstance(x, str) for x in anc_seq):\n232 |                     raise TypeError(\"ancillaries must be list[str]\")\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n233 |                 anc_list = [cast(\"str\", x) for x in anc_seq]\n234 |             else:\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:232:27\n    |\n230 |                 anc_seq = cast(\"list[object]\", anc)\n231 |                 if not all(isinstance(x, str) for x in anc_seq):\n232 |                     raise TypeError(\"ancillaries must be list[str]\")\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n233 |                 anc_list = [cast(\"str\", x) for x in anc_seq]\n234 |             else:\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_all_x.py:232:37\n    |\n230 |                 anc_seq = cast(\"list[object]\", anc)\n231 |                 if not all(isinstance(x, str) for x in anc_seq):\n232 |                     raise TypeError(\"ancillaries must be list[str]\")\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n233 |                 anc_list = [cast(\"str\", x) for x in anc_seq]\n234 |             else:\n    |\nhelp: Assign to variable; remove string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:238:17\n    |\n237 |             if not isinstance(opts, dict):\n238 |                 raise TypeError(\"opts must be an object/dict\")\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n239 |             opts_d = cast(\"dict[str, Any]\", opts)\n240 |             deps = opts_d.get(\"dependencies\", [])\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:238:23\n    |\n237 |             if not isinstance(opts, dict):\n238 |                 raise TypeError(\"opts must be an object/dict\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n239 |             opts_d = cast(\"dict[str, Any]\", opts)\n240 |             deps = opts_d.get(\"dependencies\", [])\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_all_x.py:238:33\n    |\n237 |             if not isinstance(opts, dict):\n238 |                 raise TypeError(\"opts must be an object/dict\")\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n239 |             opts_d = cast(\"dict[str, Any]\", opts)\n240 |             deps = opts_d.get(\"dependencies\", [])\n    |\nhelp: Assign to variable; remove string literal\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:242:17\n    |\n240 |             deps = opts_d.get(\"dependencies\", [])\n241 |             if deps is not None and not isinstance(deps, list):\n242 |                 raise TypeError(\"opts.dependencies must be a list if present\")\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n243 |\n244 |             valid.append((name, version, anc_list, opts_d))\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:242:23\n    |\n240 |             deps = opts_d.get(\"dependencies\", [])\n241 |             if deps is not None and not isinstance(deps, list):\n242 |                 raise TypeError(\"opts.dependencies must be a list if present\")\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n243 |\n244 |             valid.append((name, version, anc_list, opts_d))\n    |\n\nEM101 Exception must not use a string literal, assign to variable first\n   --> x_cls_make_all_x.py:242:33\n    |\n240 |             deps = opts_d.get(\"dependencies\", [])\n241 |             if deps is not None and not isinstance(deps, list):\n242 |                 raise TypeError(\"opts.dependencies must be a list if present\")\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n243 |\n244 |             valid.append((name, version, anc_list, opts_d))\n    |\nhelp: Assign to variable; remove string literal\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:245:16\n    |\n244 |             valid.append((name, version, anc_list, opts_d))\n245 |         except Exception as exc:\n    |                ^^^^^^^^^\n246 |             _error(f\"publish_manifest.json: invalid entry at index {i}: {exc}\")\n247 |             continue\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:252:22\n    |\n251 | try:\n252 |     _manifest_path = os.path.join(\n    |                      ^^^^^^^^^^^^\n253 |         os.path.dirname(__file__), \"publish_manifest.json\"\n254 |     )\n    |\n\nPTH120 `os.path.dirname()` should be replaced by `Path.parent`\n   --> x_cls_make_all_x.py:253:9\n    |\n251 | try:\n252 |     _manifest_path = os.path.join(\n253 |         os.path.dirname(__file__), \"publish_manifest.json\"\n    |         ^^^^^^^^^^^^^^^\n254 |     )\n255 |     if os.path.exists(_manifest_path):\n    |\nhelp: Replace with `Path(...).parent`\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:255:8\n    |\n253 |         os.path.dirname(__file__), \"publish_manifest.json\"\n254 |     )\n255 |     if os.path.exists(_manifest_path):\n    |        ^^^^^^^^^^^^^^\n256 |         with open(_manifest_path, encoding=\"utf-8\") as _mf:\n257 |             _loaded = json.load(_mf)\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n   --> x_cls_make_all_x.py:256:14\n    |\n254 |     )\n255 |     if os.path.exists(_manifest_path):\n256 |         with open(_manifest_path, encoding=\"utf-8\") as _mf:\n    |              ^^^^\n257 |             _loaded = json.load(_mf)\n258 |             if isinstance(_loaded, list):\n    |\nhelp: Replace with `Path.open()`\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:260:8\n    |\n258 |             if isinstance(_loaded, list):\n259 |                 _publish_manifest = validate_publish_manifest(_loaded)\n260 | except Exception:\n    |        ^^^^^^^^^\n261 |     _publish_manifest = []\n    |\n\nN801 Class name `x_cls_make_all_x` should use CapWords convention\n   --> x_cls_make_all_x.py:272:7\n    |\n270 | # Lightweight adapter class so the module exposes a ctx-aware constructor\n271 | # and can be instantiated by orchestrator flows that prefer objects.\n272 | class x_cls_make_all_x:\n    |       ^^^^^^^^^^^^^^^^\n273 |     def __init__(self, ctx: object | None = None) -> None:\n274 |         \"\"\"Context-aware orchestrator with stepwise methods.\"\"\"\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:280:9\n    |\n278 |       def run(self) -> None:\n279 |           ctx = self.build_context()\n280 | /         try:\n281 | |             globals()[\"_ORCHESTRATOR_CTX\"] = ctx\n282 | |         except Exception:\n283 | |             pass\n    | |________________^\n284 |           self.orchestrator_run(ctx)\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:282:9\n    |\n280 |           try:\n281 |               globals()[\"_ORCHESTRATOR_CTX\"] = ctx\n282 | /         except Exception:\n283 | |             pass\n    | |________________^\n284 |           self.orchestrator_run(ctx)\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:282:16\n    |\n280 |         try:\n281 |             globals()[\"_ORCHESTRATOR_CTX\"] = ctx\n282 |         except Exception:\n    |                ^^^^^^^^^\n283 |             pass\n284 |         self.orchestrator_run(ctx)\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:293:20\n    |\n291 |                 res = _build_context_from_config()\n292 |                 return cast(\"OrchestratorContext\", res)\n293 |             except Exception:\n    |                    ^^^^^^^^^\n294 |                 return None\n295 |         return None\n    |\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n   --> x_cls_make_all_x.py:299:16\n    |\n297 |     # Utilities moved into class\n298 |     def repo_parent_root(self) -> str:\n299 |         return os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\n    |                ^^^^^^^^^^^^^^^\n300 |\n301 |     def detect_clones_root(self, fallback: str | None = None) -> str:\n    |\nhelp: Replace with `Path(...).resolve()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:299:32\n    |\n297 |     # Utilities moved into class\n298 |     def repo_parent_root(self) -> str:\n299 |         return os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\n    |                                ^^^^^^^^^^^^\n300 |\n301 |     def detect_clones_root(self, fallback: str | None = None) -> str:\n    |\n\nPTH120 `os.path.dirname()` should be replaced by `Path.parent`\n   --> x_cls_make_all_x.py:299:45\n    |\n297 |     # Utilities moved into class\n298 |     def repo_parent_root(self) -> str:\n299 |         return os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\n    |                                             ^^^^^^^^^^^^^^^\n300 |\n301 |     def detect_clones_root(self, fallback: str | None = None) -> str:\n    |\nhelp: Replace with `Path(...).parent`\n\nPTH208 Use `pathlib.Path.iterdir()` instead.\n   --> x_cls_make_all_x.py:304:26\n    |\n302 |         cand = fallback or self.repo_parent_root()\n303 |         try:\n304 |             for entry in os.listdir(cand):\n    |                          ^^^^^^^^^^\n305 |                 git_dir = os.path.join(cand, entry, \".git\")\n306 |                 if os.path.isdir(git_dir):\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:305:27\n    |\n303 |         try:\n304 |             for entry in os.listdir(cand):\n305 |                 git_dir = os.path.join(cand, entry, \".git\")\n    |                           ^^^^^^^^^^^^\n306 |                 if os.path.isdir(git_dir):\n307 |                     return cand\n    |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n   --> x_cls_make_all_x.py:306:20\n    |\n304 |             for entry in os.listdir(cand):\n305 |                 git_dir = os.path.join(cand, entry, \".git\")\n306 |                 if os.path.isdir(git_dir):\n    |                    ^^^^^^^^^^^^^\n307 |                     return cand\n308 |         except Exception:\n    |\nhelp: Replace with `Path(...).is_dir()`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:308:9\n    |\n306 |                   if os.path.isdir(git_dir):\n307 |                       return cand\n308 | /         except Exception:\n309 | |             pass\n    | |________________^\n310 |           return cand\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:308:16\n    |\n306 |                 if os.path.isdir(git_dir):\n307 |                     return cand\n308 |         except Exception:\n    |                ^^^^^^^^^\n309 |             pass\n310 |         return cand\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `_instantiate_visitor`\n   --> x_cls_make_all_x.py:314:10\n    |\n312 |     def _instantiate_visitor(\n313 |         self, ctx: OrchestratorContext | None, root_dir: str | None = None\n314 |     ) -> Any:\n    |          ^^^\n315 |         root = root_dir or self.detect_clones_root()\n316 |         try:\n    |\n\nPTH119 `os.path.basename()` should be replaced by `Path.name`\n   --> x_cls_make_all_x.py:326:22\n    |\n324 |                 os.path.relpath(path, pkg_dir)\n325 |                 if os.path.commonpath([path, pkg_dir]) == pkg_dir\n326 |                 else os.path.basename(path)\n    |                      ^^^^^^^^^^^^^^^^\n327 |             )\n328 |         except Exception:\n    |\nhelp: Replace with `Path(...).name`\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:328:16\n    |\n326 |                 else os.path.basename(path)\n327 |             )\n328 |         except Exception:\n    |                ^^^^^^^^^\n329 |             return os.path.basename(path)\n    |\n\nPTH119 `os.path.basename()` should be replaced by `Path.name`\n   --> x_cls_make_all_x.py:329:20\n    |\n327 |             )\n328 |         except Exception:\n329 |             return os.path.basename(path)\n    |                    ^^^^^^^^^^^^^^^^\n330 |\n331 |     # Step 2: top-level flow\n    |\nhelp: Replace with `Path(...).name`\n\nC901 `clone_repos` is too complex (14 > 10)\n   --> x_cls_make_all_x.py:338:9\n    |\n337 |     # Step 3: clone repositories (moved logic from freestanding clone_repos)\n338 |     def clone_repos(self, ctx: OrchestratorContext | None) -> Any:\n    |         ^^^^^^^^^^^\n339 |         Cls = x_cls_make_github_clones_x\n340 |         target_dir = getattr(\n    |\n\nPLR0912 Too many branches (14 > 12)\n   --> x_cls_make_all_x.py:338:9\n    |\n337 |     # Step 3: clone repositories (moved logic from freestanding clone_repos)\n338 |     def clone_repos(self, ctx: OrchestratorContext | None) -> Any:\n    |         ^^^^^^^^^^^\n339 |         Cls = x_cls_make_github_clones_x\n340 |         target_dir = getattr(\n    |\n\nARG002 Unused method argument: `ctx`\n   --> x_cls_make_all_x.py:338:27\n    |\n337 |     # Step 3: clone repositories (moved logic from freestanding clone_repos)\n338 |     def clone_repos(self, ctx: OrchestratorContext | None) -> Any:\n    |                           ^^^\n339 |         Cls = x_cls_make_github_clones_x\n340 |         target_dir = getattr(\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `clone_repos`\n   --> x_cls_make_all_x.py:338:63\n    |\n337 |     # Step 3: clone repositories (moved logic from freestanding clone_repos)\n338 |     def clone_repos(self, ctx: OrchestratorContext | None) -> Any:\n    |                                                               ^^^\n339 |         Cls = x_cls_make_github_clones_x\n340 |         target_dir = getattr(\n    |\n\nN806 Variable `Cls` in function should be lowercase\n   --> x_cls_make_all_x.py:339:9\n    |\n337 |     # Step 3: clone repositories (moved logic from freestanding clone_repos)\n338 |     def clone_repos(self, ctx: OrchestratorContext | None) -> Any:\n339 |         Cls = x_cls_make_github_clones_x\n    |         ^^^\n340 |         target_dir = getattr(\n341 |             MakeAllConfig, \"CLONER_TARGET_DIR\", self.repo_parent_root()\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:366:17\n    |\n364 |                       include_forks=include_forks,\n365 |                   )\n366 | /                 try:\n367 | |                     cloner.force_reclone = False\n368 | |                 except Exception:\n369 | |                     pass\n    | |________________________^\n370 |               else:\n371 |                   raise\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:368:17\n    |\n366 |                   try:\n367 |                       cloner.force_reclone = False\n368 | /                 except Exception:\n369 | |                     pass\n    | |________________________^\n370 |               else:\n371 |                   raise\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:368:24\n    |\n366 |                 try:\n367 |                     cloner.force_reclone = False\n368 |                 except Exception:\n    |                        ^^^^^^^^^\n369 |                     pass\n370 |             else:\n    |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:375:9\n    |\n373 |               if hasattr(cloner, \"force_reclone\"):\n374 |                   cloner.force_reclone = False\n375 | /         except Exception:\n376 | |             pass\n    | |________________^\n377 |           try:\n378 |               invoked = False\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:375:16\n    |\n373 |             if hasattr(cloner, \"force_reclone\"):\n374 |                 cloner.force_reclone = False\n375 |         except Exception:\n    |                ^^^^^^^^^\n376 |             pass\n377 |         try:\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:393:21\n    |\n391 |                       cloner.main()\n392 |                   except TypeError:\n393 | /                     try:\n394 | |                         cloner.main()\n395 | |                     except Exception:\n396 | |                         pass\n    | |____________________________^\n397 |                   invoked = True\n398 |               if not invoked:\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:395:21\n    |\n393 |                       try:\n394 |                           cloner.main()\n395 | /                     except Exception:\n396 | |                         pass\n    | |____________________________^\n397 |                   invoked = True\n398 |               if not invoked:\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:395:28\n    |\n393 |                     try:\n394 |                         cloner.main()\n395 |                     except Exception:\n    |                            ^^^^^^^^^\n396 |                         pass\n397 |                 invoked = True\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:400:16\n    |\n398 |             if not invoked:\n399 |                 _info(\"No recognized cloner entrypoint found; skipping run\")\n400 |         except Exception as e:\n    |                ^^^^^^^^^\n401 |             _error(\"Cloner run failed:\", e)\n402 |         return cloner\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:406:23\n    |\n404 |     # Step 4: run visitor (moved logic from _run_visitor)\n405 |     def run_visitor(\n406 |         self, cloner: Any, ctx: OrchestratorContext | None\n    |                       ^^^\n407 |     ) -> None:\n408 |         root = None\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:411:16\n    |\n409 |         try:\n410 |             root = getattr(cloner, \"target_dir\", None)\n411 |         except Exception:\n    |                ^^^^^^^^^\n412 |             root = None\n413 |         root = root or self.detect_clones_root()\n    |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n   --> x_cls_make_all_x.py:414:12\n    |\n412 |             root = None\n413 |         root = root or self.detect_clones_root()\n414 |         if os.path.isdir(os.path.join(root, \".git\")):\n    |            ^^^^^^^^^^^^^\n415 |             parent = os.path.dirname(root.rstrip(\"/\\\\\"))\n416 |             for entry in os.listdir(parent):\n    |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:414:26\n    |\n412 |             root = None\n413 |         root = root or self.detect_clones_root()\n414 |         if os.path.isdir(os.path.join(root, \".git\")):\n    |                          ^^^^^^^^^^^^\n415 |             parent = os.path.dirname(root.rstrip(\"/\\\\\"))\n416 |             for entry in os.listdir(parent):\n    |\n\nPTH120 `os.path.dirname()` should be replaced by `Path.parent`\n   --> x_cls_make_all_x.py:415:22\n    |\n413 |         root = root or self.detect_clones_root()\n414 |         if os.path.isdir(os.path.join(root, \".git\")):\n415 |             parent = os.path.dirname(root.rstrip(\"/\\\\\"))\n    |                      ^^^^^^^^^^^^^^^\n416 |             for entry in os.listdir(parent):\n417 |                 if os.path.isdir(os.path.join(parent, entry, \".git\")):\n    |\nhelp: Replace with `Path(...).parent`\n\nPTH208 Use `pathlib.Path.iterdir()` instead.\n   --> x_cls_make_all_x.py:416:26\n    |\n414 |         if os.path.isdir(os.path.join(root, \".git\")):\n415 |             parent = os.path.dirname(root.rstrip(\"/\\\\\"))\n416 |             for entry in os.listdir(parent):\n    |                          ^^^^^^^^^^\n417 |                 if os.path.isdir(os.path.join(parent, entry, \".git\")):\n418 |                     root = parent\n    |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n   --> x_cls_make_all_x.py:417:20\n    |\n415 |             parent = os.path.dirname(root.rstrip(\"/\\\\\"))\n416 |             for entry in os.listdir(parent):\n417 |                 if os.path.isdir(os.path.join(parent, entry, \".git\")):\n    |                    ^^^^^^^^^^^^^\n418 |                     root = parent\n419 |                     break\n    |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:417:34\n    |\n415 |             parent = os.path.dirname(root.rstrip(\"/\\\\\"))\n416 |             for entry in os.listdir(parent):\n417 |                 if os.path.isdir(os.path.join(parent, entry, \".git\")):\n    |                                  ^^^^^^^^^^^^\n418 |                     root = parent\n419 |                     break\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:426:19\n    |\n424 |               vis = self._instantiate_visitor(ctx, root_dir=root)\n425 |           except Exception as e:\n426 |               raise AssertionError(\n    |  ___________________^\n427 | |                 f\"x_make_github_visitor instantiate failed: {e}\"\n428 | |             ) from e\n    | |_____________^\n429 |           try:\n430 |               vis.run_inspect_flow()\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:427:17\n    |\n425 |         except Exception as e:\n426 |             raise AssertionError(\n427 |                 f\"x_make_github_visitor instantiate failed: {e}\"\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n428 |             ) from e\n429 |         try:\n    |\nhelp: Assign to variable; remove f-string literal\n\nE501 Line too long (110 > 88)\n   --> x_cls_make_all_x.py:435:89\n    |\n433 |             if \"no child git repositories found\" in msg:\n434 |                 _info(\n435 |                     \"Visitor skipped: no child git repositories present at root; continuing orchestrator flow\"\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^\n436 |                 )\n437 |                 return\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:438:19\n    |\n436 |                   )\n437 |                   return\n438 |               raise AssertionError(\n    |  ___________________^\n439 | |                 f\"x_make_github_visitor run failed: {e}\"\n440 | |             ) from e\n    | |_____________^\n441 |\n442 |       # Step 5: publish and update installations (moved logic from _process_publishes_and_updates)\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:439:17\n    |\n437 |                 return\n438 |             raise AssertionError(\n439 |                 f\"x_make_github_visitor run failed: {e}\"\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n440 |             ) from e\n    |\nhelp: Assign to variable; remove f-string literal\n\nE501 Line too long (96 > 88)\n   --> x_cls_make_all_x.py:442:89\n    |\n440 |             ) from e\n441 |\n442 |     # Step 5: publish and update installations (moved logic from _process_publishes_and_updates)\n    |                                                                                         ^^^^^^^^\n443 |     def process_publishes_and_updates(\n444 |         self, cloner: Any, ctx: OrchestratorContext | None\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:444:23\n    |\n442 |     # Step 5: publish and update installations (moved logic from _process_publishes_and_updates)\n443 |     def process_publishes_and_updates(\n444 |         self, cloner: Any, ctx: OrchestratorContext | None\n    |                       ^^^\n445 |     ) -> None:\n446 |         published_versions, published_artifacts = self.publish_all(cloner, ctx)\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:461:9\n    |\n459 |           deadline = time.time() + timeout\n460 |           candidates = [name, name.replace(\"_\", \"-\")]\n461 | /         try:\n462 | |             time.sleep(5)\n463 | |         except Exception:\n464 | |             pass\n    | |________________^\n465 |           attempt = 0\n466 |           backoff = 1\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:463:9\n    |\n461 |           try:\n462 |               time.sleep(5)\n463 | /         except Exception:\n464 | |             pass\n    | |________________^\n465 |           attempt = 0\n466 |           backoff = 1\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:463:16\n    |\n461 |         try:\n462 |             time.sleep(5)\n463 |         except Exception:\n    |                ^^^^^^^^^\n464 |             pass\n465 |         attempt = 0\n    |\n\nS310 Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected.\n   --> x_cls_make_all_x.py:472:27\n    |\n470 |                 pj_url = f\"https://pypi.org/project/{candidate}/{version}/\"\n471 |                 try:\n472 |                     req = urllib.request.Request(pj_url, method=\"HEAD\")\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n473 |                     with urllib.request.urlopen(req, timeout=10) as resp:\n474 |                         if getattr(resp, \"status\", 200) == 200:\n    |\n\nS310 Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected.\n   --> x_cls_make_all_x.py:473:26\n    |\n471 |                 try:\n472 |                     req = urllib.request.Request(pj_url, method=\"HEAD\")\n473 |                     with urllib.request.urlopen(req, timeout=10) as resp:\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n474 |                         if getattr(resp, \"status\", 200) == 200:\n475 |                             _info(\n    |\n\nPLR2004 Magic value used in comparison, consider replacing `200` with a constant variable\n   --> x_cls_make_all_x.py:474:60\n    |\n472 |                     req = urllib.request.Request(pj_url, method=\"HEAD\")\n473 |                     with urllib.request.urlopen(req, timeout=10) as resp:\n474 |                         if getattr(resp, \"status\", 200) == 200:\n    |                                                            ^^^\n475 |                             _info(\n476 |                                 f\"PyPI: {name}=={version} is now available (queried {candidate} via project page)\"\n    |\n\nE501 Line too long (114 > 88)\n   --> x_cls_make_all_x.py:476:89\n    |\n474 |                         if getattr(resp, \"status\", 200) == 200:\n475 |                             _info(\n476 |                                 f\"PyPI: {name}=={version} is now available (queried {candidate} via project page)\"\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n477 |                             )\n478 |                             return True\n    |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:479:17\n    |\n477 |                               )\n478 |                               return True\n479 | /                 except Exception:\n480 | |                     pass\n    | |________________________^\n481 |                   json_url = f\"https://pypi.org/pypi/{candidate}/json\"\n482 |                   try:\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:479:24\n    |\n477 |                             )\n478 |                             return True\n479 |                 except Exception:\n    |                        ^^^^^^^^^\n480 |                     pass\n481 |                 json_url = f\"https://pypi.org/pypi/{candidate}/json\"\n    |\n\nS310 Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected.\n   --> x_cls_make_all_x.py:483:26\n    |\n481 |                 json_url = f\"https://pypi.org/pypi/{candidate}/json\"\n482 |                 try:\n483 |                     with urllib.request.urlopen(json_url, timeout=10) as resp:\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n484 |                         data = json.load(resp)\n485 |                     if version in data.get(\"releases\", {}):\n    |\n\nE501 Line too long (102 > 88)\n   --> x_cls_make_all_x.py:487:89\n    |\n485 |                     if version in data.get(\"releases\", {}):\n486 |                         _info(\n487 |                             f\"PyPI: {name}=={version} is now available (queried {candidate} via JSON)\"\n    |                                                                                         ^^^^^^^^^^^^^^\n488 |                         )\n489 |                         return True\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:490:24\n    |\n488 |                         )\n489 |                         return True\n490 |                 except Exception as exc:\n    |                        ^^^^^^^^^\n491 |                     _info(\n492 |                         f\"PyPI check attempt {attempt} for {name} (using {candidate}) failed: {exc}\"\n    |\n\nE501 Line too long (100 > 88)\n   --> x_cls_make_all_x.py:492:89\n    |\n490 |                 except Exception as exc:\n491 |                     _info(\n492 |                         f\"PyPI check attempt {attempt} for {name} (using {candidate}) failed: {exc}\"\n    |                                                                                         ^^^^^^^^^^^^\n493 |                     )\n494 |                     continue\n    |\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:495:13\n    |\n493 |                       )\n494 |                       continue\n495 | /             try:\n496 | |                 time.sleep(backoff)\n497 | |             except Exception:\n498 | |                 pass\n    | |____________________^\n499 |               backoff = min(backoff * 2, 10)\n500 |           _info(\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:497:13\n    |\n495 |               try:\n496 |                   time.sleep(backoff)\n497 | /             except Exception:\n498 | |                 pass\n    | |____________________^\n499 |               backoff = min(backoff * 2, 10)\n500 |           _info(\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:497:20\n    |\n495 |             try:\n496 |                 time.sleep(backoff)\n497 |             except Exception:\n    |                    ^^^^^^^^^\n498 |                 pass\n499 |             backoff = min(backoff * 2, 10)\n    |\n\nS107 Possible hardcoded password assigned to function default: \"token_env\"\n   --> x_cls_make_all_x.py:506:49\n    |\n505 |     # Publishing helpers kept as freestanding where small; core flow moved here\n506 |     def _check_test_pypi(self, token_env: str = \"TEST_PYPI_TOKEN\") -> None:\n    |                                                 ^^^^^^^^^^^^^^^^^\n507 |         try:\n508 |             token = os.environ.get(token_env)\n    |\n\nS310 Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected.\n   --> x_cls_make_all_x.py:510:19\n    |\n508 |             token = os.environ.get(token_env)\n509 |             url = \"https://test.pypi.org/\"\n510 |             req = urllib.request.Request(url, method=\"HEAD\")\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n511 |             if token:\n512 |                 req.add_header(\"Authorization\", f\"token {token}\")\n    |\n\nS310 Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected.\n   --> x_cls_make_all_x.py:513:18\n    |\n511 |             if token:\n512 |                 req.add_header(\"Authorization\", f\"token {token}\")\n513 |             with urllib.request.urlopen(req, timeout=10) as resp:\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n514 |                 status = getattr(resp, \"status\", None)\n515 |                 if status is not None and status >= 400:\n    |\n\nPLR2004 Magic value used in comparison, consider replacing `400` with a constant variable\n   --> x_cls_make_all_x.py:515:53\n    |\n513 |             with urllib.request.urlopen(req, timeout=10) as resp:\n514 |                 status = getattr(resp, \"status\", None)\n515 |                 if status is not None and status >= 400:\n    |                                                     ^^^\n516 |                     raise AssertionError(\n517 |                         f\"test.pypi.org returned status {status}\"\n    |\n\nTRY301 Abstract `raise` to an inner function\n   --> x_cls_make_all_x.py:516:21\n    |\n514 |                   status = getattr(resp, \"status\", None)\n515 |                   if status is not None and status >= 400:\n516 | /                     raise AssertionError(\n517 | |                         f\"test.pypi.org returned status {status}\"\n518 | |                     )\n    | |_____________________^\n519 |           except AssertionError:\n520 |               raise\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:516:27\n    |\n514 |                   status = getattr(resp, \"status\", None)\n515 |                   if status is not None and status >= 400:\n516 |                       raise AssertionError(\n    |  ___________________________^\n517 | |                         f\"test.pypi.org returned status {status}\"\n518 | |                     )\n    | |_____________________^\n519 |           except AssertionError:\n520 |               raise\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:517:25\n    |\n515 |                 if status is not None and status >= 400:\n516 |                     raise AssertionError(\n517 |                         f\"test.pypi.org returned status {status}\"\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n518 |                     )\n519 |         except AssertionError:\n    |\nhelp: Assign to variable; remove f-string literal\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:522:19\n    |\n520 |             raise\n521 |         except Exception as exc:\n522 |             raise AssertionError(f\"test.pypi.org check failed: {exc}\") from exc\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n523 |\n524 |     def _to_posix_rel(self, rel: str) -> str:\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:522:34\n    |\n520 |             raise\n521 |         except Exception as exc:\n522 |             raise AssertionError(f\"test.pypi.org check failed: {exc}\") from exc\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n523 |\n524 |     def _to_posix_rel(self, rel: str) -> str:\n    |\nhelp: Assign to variable; remove f-string literal\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:531:9\n    |\n529 |               )  # avoid accidental leading separators\n530 |               rel = rel.replace(\"\\\\\", \"/\")\n531 | /         except Exception:\n532 | |             pass\n    | |________________^\n533 |           return rel\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:531:16\n    |\n529 |             )  # avoid accidental leading separators\n530 |             rel = rel.replace(\"\\\\\", \"/\")\n531 |         except Exception:\n    |                ^^^^^^^^^\n532 |             pass\n533 |         return rel\n    |\n\nE501 Line too long (89 > 88)\n   --> x_cls_make_all_x.py:536:89\n    |\n535 |     def _safe_rel_from_abs(self, abs_path: str, base_dir: str) -> str | None:\n536 |         \"\"\"Return posix relative path if abs_path is a file under base_dir; else None.\"\"\"\n    |                                                                                         ^\n537 |         try:\n538 |             ap = os.path.abspath(abs_path)\n    |\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n   --> x_cls_make_all_x.py:538:18\n    |\n536 |         \"\"\"Return posix relative path if abs_path is a file under base_dir; else None.\"\"\"\n537 |         try:\n538 |             ap = os.path.abspath(abs_path)\n    |                  ^^^^^^^^^^^^^^^\n539 |             bd = os.path.abspath(base_dir)\n540 |             common = os.path.commonpath([ap, bd])\n    |\nhelp: Replace with `Path(...).resolve()`\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n   --> x_cls_make_all_x.py:539:18\n    |\n537 |         try:\n538 |             ap = os.path.abspath(abs_path)\n539 |             bd = os.path.abspath(base_dir)\n    |                  ^^^^^^^^^^^^^^^\n540 |             common = os.path.commonpath([ap, bd])\n541 |             if common != bd:\n    |\nhelp: Replace with `Path(...).resolve()`\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n   --> x_cls_make_all_x.py:543:20\n    |\n541 |             if common != bd:\n542 |                 return None\n543 |             if not os.path.isfile(ap):\n    |                    ^^^^^^^^^^^^^^\n544 |                 return None\n545 |             rel_native = os.path.relpath(ap, bd)\n    |\nhelp: Replace with `Path(...).is_file()`\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:549:16\n    |\n547 |                 return None\n548 |             return self._to_posix_rel(rel_native)\n549 |         except Exception:\n    |                ^^^^^^^^^\n550 |             return None\n    |\n\nC901 `_load_ancillary_allowlist` is too complex (12 > 10)\n   --> x_cls_make_all_x.py:552:9\n    |\n550 |             return None\n551 |\n552 |     def _load_ancillary_allowlist(\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n553 |         self, list_file: str, pkg_dir: str\n554 |     ) -> list[str]:\n    |\n\nE501 Line too long (94 > 88)\n   --> x_cls_make_all_x.py:555:89\n    |\n553 |         self, list_file: str, pkg_dir: str\n554 |     ) -> list[str]:\n555 |         \"\"\"Load an allowlist of ancillary files; return clean relative paths under pkg_dir.\"\"\"\n    |                                                                                         ^^^^^^\n556 |         out: list[str] = []\n557 |         try:\n    |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n   --> x_cls_make_all_x.py:558:20\n    |\n556 |         out: list[str] = []\n557 |         try:\n558 |             if not os.path.isfile(list_file):\n    |                    ^^^^^^^^^^^^^^\n559 |                 _info(f\"Ancillary allowlist not found: {list_file}\")\n560 |                 return out\n    |\nhelp: Replace with `Path(...).is_file()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n   --> x_cls_make_all_x.py:561:18\n    |\n559 |                 _info(f\"Ancillary allowlist not found: {list_file}\")\n560 |                 return out\n561 |             with open(list_file, encoding=\"utf-8\") as f:\n    |                  ^^^^\n562 |                 lines = f.readlines()\n563 |             seen: set[str] = set()\n    |\nhelp: Replace with `Path.open()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:571:45\n    |\n569 |                 if line.startswith(\"@\"):\n570 |                     line = line[1:].strip()\n571 |                 abs_path = os.path.normpath(os.path.join(pkg_dir, line))\n    |                                             ^^^^^^^^^^^^\n572 |                 # Ensure file is within package dir and is a file\n573 |                 try:\n    |\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n   --> x_cls_make_all_x.py:575:26\n    |\n573 |                 try:\n574 |                     common = os.path.commonpath(\n575 |                         [os.path.abspath(abs_path), os.path.abspath(pkg_dir)]\n    |                          ^^^^^^^^^^^^^^^\n576 |                     )\n577 |                     if common != os.path.abspath(pkg_dir):\n    |\nhelp: Replace with `Path(...).resolve()`\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n   --> x_cls_make_all_x.py:575:53\n    |\n573 |                 try:\n574 |                     common = os.path.commonpath(\n575 |                         [os.path.abspath(abs_path), os.path.abspath(pkg_dir)]\n    |                                                     ^^^^^^^^^^^^^^^\n576 |                     )\n577 |                     if common != os.path.abspath(pkg_dir):\n    |\nhelp: Replace with `Path(...).resolve()`\n\nPTH100 `os.path.abspath()` should be replaced by `Path.resolve()`\n   --> x_cls_make_all_x.py:577:34\n    |\n575 |                         [os.path.abspath(abs_path), os.path.abspath(pkg_dir)]\n576 |                     )\n577 |                     if common != os.path.abspath(pkg_dir):\n    |                                  ^^^^^^^^^^^^^^^\n578 |                         _info(\n579 |                             f\"Skipping ancillary outside package dir: {line}\"\n    |\nhelp: Replace with `Path(...).resolve()`\n\nS112 `try`-`except`-`continue` detected, consider logging the exception\n   --> x_cls_make_all_x.py:582:17\n    |\n580 |                           )\n581 |                           continue\n582 | /                 except Exception:\n583 | |                     continue\n    | |____________________________^\n584 |                   if not os.path.isfile(abs_path):\n585 |                       _info(f\"Skipping non-file ancillary entry: {line}\")\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:582:24\n    |\n580 |                         )\n581 |                         continue\n582 |                 except Exception:\n    |                        ^^^^^^^^^\n583 |                     continue\n584 |                 if not os.path.isfile(abs_path):\n    |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n   --> x_cls_make_all_x.py:584:24\n    |\n582 |                 except Exception:\n583 |                     continue\n584 |                 if not os.path.isfile(abs_path):\n    |                        ^^^^^^^^^^^^^^\n585 |                     _info(f\"Skipping non-file ancillary entry: {line}\")\n586 |                     continue\n    |\nhelp: Replace with `Path(...).is_file()`\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:589:24\n    |\n587 |                 try:\n588 |                     rel = os.path.relpath(abs_path, pkg_dir)\n589 |                 except Exception:\n    |                        ^^^^^^^^^\n590 |                     rel = os.path.basename(abs_path)\n591 |                 if rel.startswith(\"..\"):\n    |\n\nPTH119 `os.path.basename()` should be replaced by `Path.name`\n   --> x_cls_make_all_x.py:590:27\n    |\n588 |                     rel = os.path.relpath(abs_path, pkg_dir)\n589 |                 except Exception:\n590 |                     rel = os.path.basename(abs_path)\n    |                           ^^^^^^^^^^^^^^^^\n591 |                 if rel.startswith(\"..\"):\n592 |                     continue\n    |\nhelp: Replace with `Path(...).name`\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:598:16\n    |\n596 |                     seen.add(rel)\n597 |                     out.append(rel)\n598 |         except Exception as e:\n    |                ^^^^^^^^^\n599 |             _error(f\"Failed to load ancillary allowlist {list_file}: {e}\")\n600 |         return out\n    |\n\nC901 `_locate_repo_main_and_ancillaries` is too complex (16 > 10)\n   --> x_cls_make_all_x.py:602:9\n    |\n600 |         return out\n601 |\n602 |     def _locate_repo_main_and_ancillaries(\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n603 |         self,\n604 |         cloner: Any,\n    |\n\nPLR0912 Too many branches (16 > 12)\n   --> x_cls_make_all_x.py:602:9\n    |\n600 |         return out\n601 |\n602 |     def _locate_repo_main_and_ancillaries(\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n603 |         self,\n604 |         cloner: Any,\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:604:17\n    |\n602 |     def _locate_repo_main_and_ancillaries(\n603 |         self,\n604 |         cloner: Any,\n    |                 ^^^\n605 |         pkg: str,\n606 |         main_basename: str | None,\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:615:16\n    |\n613 |                 else self.repo_parent_root()\n614 |             )\n615 |         except Exception:\n    |                ^^^^^^^^^\n616 |             base = self.repo_parent_root()\n617 |         pkg_dir = os.path.join(base, pkg)\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:617:19\n    |\n615 |         except Exception:\n616 |             base = self.repo_parent_root()\n617 |         pkg_dir = os.path.join(base, pkg)\n    |                   ^^^^^^^^^^^^\n618 |         if not os.path.isdir(pkg_dir):\n619 |             raise FileNotFoundError(\n    |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n   --> x_cls_make_all_x.py:618:16\n    |\n616 |             base = self.repo_parent_root()\n617 |         pkg_dir = os.path.join(base, pkg)\n618 |         if not os.path.isdir(pkg_dir):\n    |                ^^^^^^^^^^^^^\n619 |             raise FileNotFoundError(\n620 |                 f\"Repo package directory not found for {pkg!r} at {pkg_dir}\"\n    |\nhelp: Replace with `Path(...).is_dir()`\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:619:19\n    |\n617 |           pkg_dir = os.path.join(base, pkg)\n618 |           if not os.path.isdir(pkg_dir):\n619 |               raise FileNotFoundError(\n    |  ___________________^\n620 | |                 f\"Repo package directory not found for {pkg!r} at {pkg_dir}\"\n621 | |             )\n    | |_____________^\n622 |           if main_basename is None:\n623 |               main_basename = pkg.replace(\"x_make_\", \"x_cls_make_\") + \".py\"\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:620:17\n    |\n618 |         if not os.path.isdir(pkg_dir):\n619 |             raise FileNotFoundError(\n620 |                 f\"Repo package directory not found for {pkg!r} at {pkg_dir}\"\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n621 |             )\n622 |         if main_basename is None:\n    |\nhelp: Assign to variable; remove f-string literal\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:624:21\n    |\n622 |         if main_basename is None:\n623 |             main_basename = pkg.replace(\"x_make_\", \"x_cls_make_\") + \".py\"\n624 |         main_path = os.path.join(pkg_dir, main_basename)\n    |                     ^^^^^^^^^^^^\n625 |         if not os.path.exists(main_path):\n626 |             for fn in os.listdir(pkg_dir):\n    |\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:625:16\n    |\n623 |             main_basename = pkg.replace(\"x_make_\", \"x_cls_make_\") + \".py\"\n624 |         main_path = os.path.join(pkg_dir, main_basename)\n625 |         if not os.path.exists(main_path):\n    |                ^^^^^^^^^^^^^^\n626 |             for fn in os.listdir(pkg_dir):\n627 |                 if fn.startswith(\"x_cls_make_\") and fn.endswith(\".py\"):\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH208 Use `pathlib.Path.iterdir()` instead.\n   --> x_cls_make_all_x.py:626:23\n    |\n624 |         main_path = os.path.join(pkg_dir, main_basename)\n625 |         if not os.path.exists(main_path):\n626 |             for fn in os.listdir(pkg_dir):\n    |                       ^^^^^^^^^^\n627 |                 if fn.startswith(\"x_cls_make_\") and fn.endswith(\".py\"):\n628 |                     main_path = os.path.join(pkg_dir, fn)\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:628:33\n    |\n626 |             for fn in os.listdir(pkg_dir):\n627 |                 if fn.startswith(\"x_cls_make_\") and fn.endswith(\".py\"):\n628 |                     main_path = os.path.join(pkg_dir, fn)\n    |                                 ^^^^^^^^^^^^\n629 |                     break\n630 |         if not os.path.exists(main_path):\n    |\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:630:16\n    |\n628 |                     main_path = os.path.join(pkg_dir, fn)\n629 |                     break\n630 |         if not os.path.exists(main_path):\n    |                ^^^^^^^^^^^^^^\n631 |             raise FileNotFoundError(\n632 |                 f\"Could not locate main file in repo for package {pkg!r} (expected {main_basename})\"\n    |\nhelp: Replace with `Path(...).exists()`\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:631:19\n    |\n629 |                       break\n630 |           if not os.path.exists(main_path):\n631 |               raise FileNotFoundError(\n    |  ___________________^\n632 | |                 f\"Could not locate main file in repo for package {pkg!r} (expected {main_basename})\"\n633 | |             )\n    | |_____________^\n634 |           anc_rel: list[str] = []\n635 |           if ancillary_names:\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:632:17\n    |\n630 |         if not os.path.exists(main_path):\n631 |             raise FileNotFoundError(\n632 |                 f\"Could not locate main file in repo for package {pkg!r} (expected {main_basename})\"\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n633 |             )\n634 |         anc_rel: list[str] = []\n    |\nhelp: Assign to variable; remove f-string literal\n\nE501 Line too long (100 > 88)\n   --> x_cls_make_all_x.py:632:89\n    |\n630 |         if not os.path.exists(main_path):\n631 |             raise FileNotFoundError(\n632 |                 f\"Could not locate main file in repo for package {pkg!r} (expected {main_basename})\"\n    |                                                                                         ^^^^^^^^^^^^\n633 |             )\n634 |         anc_rel: list[str] = []\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:640:33\n    |\n638 |                 if name.startswith(\"@\"):\n639 |                     # Allowlist file relative to the repo package directory\n640 |                     list_file = os.path.join(pkg_dir, name[1:].strip())\n    |                                 ^^^^^^^^^^^^\n641 |                     for allowed_rel in self._load_ancillary_allowlist(\n642 |                         list_file, pkg_dir\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:650:29\n    |\n648 |                 # Normalize any leading separators from manifest entries\n649 |                 safe_name = name.lstrip(\"/\\\\\")\n650 |                 candidate = os.path.join(pkg_dir, safe_name)\n    |                             ^^^^^^^^^^^^\n651 |                 if os.path.isfile(candidate):\n652 |                     rel_path: str | None = self._safe_rel_from_abs(\n    |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n   --> x_cls_make_all_x.py:651:20\n    |\n649 |                 safe_name = name.lstrip(\"/\\\\\")\n650 |                 candidate = os.path.join(pkg_dir, safe_name)\n651 |                 if os.path.isfile(candidate):\n    |                    ^^^^^^^^^^^^^^\n652 |                     rel_path: str | None = self._safe_rel_from_abs(\n653 |                         candidate, pkg_dir\n    |\nhelp: Replace with `Path(...).is_file()`\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n   --> x_cls_make_all_x.py:658:22\n    |\n656 |                         seen.add(rel_path)\n657 |                         anc_rel.append(rel_path)\n658 |                 elif os.path.isdir(candidate):\n    |                      ^^^^^^^^^^^^^\n659 |                     # No auto-expansion (security). Require allowlist.\n660 |                     _info(\n    |\nhelp: Replace with `Path(...).is_dir()`\n\nE501 Line too long (137 > 88)\n   --> x_cls_make_all_x.py:661:89\n    |\n659 | \u00e2\u20ac\u00a6         # No auto-expansion (security). Require allowlist.\n660 | \u00e2\u20ac\u00a6         _info(\n661 | \u00e2\u20ac\u00a6             f\"Ancillary directory provided but not auto-included (use '@<allowlist>' or opts['ancillary_allowlist']): {name}\"\n    |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n662 | \u00e2\u20ac\u00a6         )\n663 | \u00e2\u20ac\u00a6     else:\n    |\n\nN803 Argument name `PublisherCls` should be lowercase\n   --> x_cls_make_all_x.py:669:9\n    |\n667 |     def _instantiate_publisher(\n668 |         self,\n669 |         PublisherCls: Any,\n    |         ^^^^^^^^^^^^^^^^^\n670 |         name: str,\n671 |         version: str,\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `PublisherCls`\n   --> x_cls_make_all_x.py:669:23\n    |\n667 |     def _instantiate_publisher(\n668 |         self,\n669 |         PublisherCls: Any,\n    |                       ^^^\n670 |         name: str,\n671 |         version: str,\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `_instantiate_publisher`\n   --> x_cls_make_all_x.py:674:10\n    |\n672 |         ctx: OrchestratorContext | None,\n673 |         safe_kwargs: dict[str, Any],\n674 |     ) -> Any:\n    |          ^^^\n675 |         try:\n676 |             return PublisherCls(\n    |\n\nC901 `_publish_do_publish` is too complex (17 > 10)\n   --> x_cls_make_all_x.py:693:9\n    |\n691 |         return PublisherCls(name=name, version=version, **safe_kwargs)\n692 |\n693 |     def _publish_do_publish(\n    |         ^^^^^^^^^^^^^^^^^^^\n694 |         self,\n695 |         name: str,\n    |\n\nPLR0913 Too many arguments in function definition (10 > 5)\n   --> x_cls_make_all_x.py:693:9\n    |\n691 |         return PublisherCls(name=name, version=version, **safe_kwargs)\n692 |\n693 |     def _publish_do_publish(\n    |         ^^^^^^^^^^^^^^^^^^^\n694 |         self,\n695 |         name: str,\n    |\n\nPLR0912 Too many branches (14 > 12)\n   --> x_cls_make_all_x.py:693:9\n    |\n691 |         return PublisherCls(name=name, version=version, **safe_kwargs)\n692 |\n693 |     def _publish_do_publish(\n    |         ^^^^^^^^^^^^^^^^^^^\n694 |         self,\n695 |         name: str,\n    |\n\nPLR0915 Too many statements (59 > 50)\n   --> x_cls_make_all_x.py:693:9\n    |\n691 |         return PublisherCls(name=name, version=version, **safe_kwargs)\n692 |\n693 |     def _publish_do_publish(\n    |         ^^^^^^^^^^^^^^^^^^^\n694 |         self,\n695 |         name: str,\n    |\n\nARG002 Unused method argument: `base`\n   --> x_cls_make_all_x.py:700:9\n    |\n698 |         ancillary_files: list[str],\n699 |         *,\n700 |         base: str,\n    |         ^^^^\n701 |         cloner: Any,\n702 |         ctx: OrchestratorContext | None,\n    |\n\nARG002 Unused method argument: `cloner`\n   --> x_cls_make_all_x.py:701:9\n    |\n699 |         *,\n700 |         base: str,\n701 |         cloner: Any,\n    |         ^^^^^^\n702 |         ctx: OrchestratorContext | None,\n703 |         local_kwargs: dict[str, Any],\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:701:17\n    |\n699 |         *,\n700 |         base: str,\n701 |         cloner: Any,\n    |                 ^^^\n702 |         ctx: OrchestratorContext | None,\n703 |         local_kwargs: dict[str, Any],\n    |\n\nN806 Variable `PublisherCls` in function should be lowercase\n   --> x_cls_make_all_x.py:707:9\n    |\n705 |         published_artifacts: dict[str, dict[str, Any]],\n706 |     ) -> None:\n707 |         PublisherCls = x_cls_make_pypi_x\n    |         ^^^^^^^^^^^^\n708 |         safe_kwargs = {\n709 |             k: v\n    |\n\nE501 Line too long (96 > 88)\n   --> x_cls_make_all_x.py:714:89\n    |\n712 |         }\n713 |\n714 |         # Normalize ancillaries: include only explicitly listed files and files from allowlists.\n    |                                                                                         ^^^^^^^^\n715 |         pkg_dir = os.path.dirname(main_file)\n716 |         seen_rel: set[str] = set()\n    |\n\nPTH120 `os.path.dirname()` should be replaced by `Path.parent`\n   --> x_cls_make_all_x.py:715:19\n    |\n714 |         # Normalize ancillaries: include only explicitly listed files and files from allowlists.\n715 |         pkg_dir = os.path.dirname(main_file)\n    |                   ^^^^^^^^^^^^^^^\n716 |         seen_rel: set[str] = set()\n717 |         norm_anc_rel: list[str] = []\n    |\nhelp: Replace with `Path(...).parent`\n\nPTH117 `os.path.isabs()` should be replaced by `Path.is_absolute()`\n   --> x_cls_make_all_x.py:723:24\n    |\n721 |                 ap = (\n722 |                     rel_or_abs\n723 |                     if os.path.isabs(rel_or_abs)\n    |                        ^^^^^^^^^^^^^\n724 |                     else os.path.join(pkg_dir, rel_or_abs)\n725 |                 )\n    |\nhelp: Replace with `Path(...).is_absolute()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:724:26\n    |\n722 |                     rel_or_abs\n723 |                     if os.path.isabs(rel_or_abs)\n724 |                     else os.path.join(pkg_dir, rel_or_abs)\n    |                          ^^^^^^^^^^^^\n725 |                 )\n726 |                 if os.path.isdir(ap):\n    |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n   --> x_cls_make_all_x.py:726:20\n    |\n724 |                     else os.path.join(pkg_dir, rel_or_abs)\n725 |                 )\n726 |                 if os.path.isdir(ap):\n    |                    ^^^^^^^^^^^^^\n727 |                     # Directories are ignored unless files are enumerated via allowlists\n728 |                     _info(\n    |\nhelp: Replace with `Path(...).is_dir()`\n\nE501 Line too long (148 > 88)\n   --> x_cls_make_all_x.py:729:89\n    |\n727 | \u00e2\u20ac\u00a6 files are enumerated via allowlists\n728 | \u00e2\u20ac\u00a6\n729 | \u00e2\u20ac\u00a6ry (no auto-expansion): {os.path.relpath(ap, pkg_dir) if not os.path.isabs(rel_or_abs) else ap}\"\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n730 | \u00e2\u20ac\u00a6\n731 | \u00e2\u20ac\u00a6\n    |\n\nPTH117 `os.path.isabs()` should be replaced by `Path.is_absolute()`\n   --> x_cls_make_all_x.py:729:114\n    |\n727 | \u00e2\u20ac\u00a6     # Directories are ignored unless files are enumerated via allowlists\n728 | \u00e2\u20ac\u00a6     _info(\n729 | \u00e2\u20ac\u00a6         f\"Ignoring ancillary directory (no auto-expansion): {os.path.relpath(ap, pkg_dir) if not os.path.isabs(rel_or_abs) else ap}\"\n    |                                                                                                    ^^^^^^^^^^^^^\n730 | \u00e2\u20ac\u00a6     )\n731 | \u00e2\u20ac\u00a6     return\n    |\nhelp: Replace with `Path(...).is_absolute()`\n\nERA001 Found commented-out code\n   --> x_cls_make_all_x.py:733:17\n    |\n731 |                     return\n732 |                 rel = self._safe_rel_from_abs(ap, pkg_dir)\n733 |                 ##rel = self._safe_rel_from_abs(ap, pkg_dir)\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n734 |                 if not rel:\n735 |                     return\n    |\nhelp: Remove commented-out code\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:741:20\n    |\n739 |                     seen_rel.add(rel)\n740 |                     norm_anc_rel.append(rel)\n741 |             except Exception:\n    |                    ^^^^^^^^^\n742 |                 return\n    |\n\nE501 Line too long (107 > 88)\n   --> x_cls_make_all_x.py:746:89\n    |\n744 |         # 1) Files explicitly provided by manifest (already relative to pkg_dir)\n745 |         for a in ancillary_files or []:\n746 |             # Entries like '@list.txt' could have been passed through; ignore here (handled below via opts)\n    |                                                                                         ^^^^^^^^^^^^^^^^^^^\n747 |             if a.startswith(\"@\"):\n748 |                 continue\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:762:17\n    |\n760 |         for spec in allow_files:\n761 |             list_path = (\n762 |                 os.path.join(pkg_dir, spec[1:].strip())\n    |                 ^^^^^^^^^^^^\n763 |                 if spec.startswith(\"@\")\n764 |                 else os.path.join(pkg_dir, spec)\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:764:22\n    |\n762 |                 os.path.join(pkg_dir, spec[1:].strip())\n763 |                 if spec.startswith(\"@\")\n764 |                 else os.path.join(pkg_dir, spec)\n    |                      ^^^^^^^^^^^^\n765 |             )\n766 |             for rel in self._load_ancillary_allowlist(list_path, pkg_dir):\n    |\n\nPTH109 `os.getcwd()` should be replaced by `Path.cwd()`\n   --> x_cls_make_all_x.py:778:19\n    |\n776 |             )\n777 |             # Run with cwd=pkg_dir and pass POSIX relative paths\n778 |             cwd = os.getcwd()\n    |                   ^^^^^^^^^\n779 |             main_rel = os.path.basename(main_file)\n780 |             try:\n    |\nhelp: Replace with `Path.cwd()`\n\nPTH119 `os.path.basename()` should be replaced by `Path.name`\n   --> x_cls_make_all_x.py:779:24\n    |\n777 |             # Run with cwd=pkg_dir and pass POSIX relative paths\n778 |             cwd = os.getcwd()\n779 |             main_rel = os.path.basename(main_file)\n    |                        ^^^^^^^^^^^^^^^^\n780 |             try:\n781 |                 os.chdir(pkg_dir)\n    |\nhelp: Replace with `Path(...).name`\n\nSIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`\n   --> x_cls_make_all_x.py:784:17\n    |\n782 |                   published = publisher.publish(main_rel, norm_anc_rel)\n783 |               finally:\n784 | /                 try:\n785 | |                     os.chdir(cwd)\n786 | |                 except Exception:\n787 | |                     pass\n    | |________________________^\n788 |           except Exception as exc:\n789 |               # ...existing error handling...\n    |\nhelp: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:786:17\n    |\n784 |                   try:\n785 |                       os.chdir(cwd)\n786 | /                 except Exception:\n787 | |                     pass\n    | |________________________^\n788 |           except Exception as exc:\n789 |               # ...existing error handling...\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:786:24\n    |\n784 |                 try:\n785 |                     os.chdir(cwd)\n786 |                 except Exception:\n    |                        ^^^^^^^^^\n787 |                     pass\n788 |         except Exception as exc:\n    |\n\nE501 Line too long (95 > 88)\n   --> x_cls_make_all_x.py:810:89\n    |\n808 |             ):\n809 |                 _info(\n810 |                     f\"SKIP: {name} version {version} already exists on PyPI. Skipping publish.\"\n    |                                                                                         ^^^^^^^\n811 |                 )\n812 |                 published = True\n    |\n\nPLR0913 Too many arguments in function definition (8 > 5)\n   --> x_cls_make_all_x.py:826:9\n    |\n824 |             _info(f\"publish skipped for {name} {version} (minimal stub)\")\n825 |\n826 |     def _publish_one(\n    |         ^^^^^^^^^^^^\n827 |         self,\n828 |         name: str,\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:833:17\n    |\n831 |         ancillary_files: list[str],\n832 |         *,\n833 |         cloner: Any,\n    |                 ^^^\n834 |         ctx: OrchestratorContext | None,\n835 |         published_versions: dict[str, str | None],\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`\n   --> x_cls_make_all_x.py:837:19\n    |\n835 |         published_versions: dict[str, str | None],\n836 |         published_artifacts: dict[str, dict[str, Any]],\n837 |         **kwargs: Any,\n    |                   ^^^\n838 |     ) -> None:\n839 |         _info(f\"Publishing {name} version {version}\")\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:849:20\n    |\n847 |                     else self.repo_parent_root()\n848 |                 )\n849 |             except Exception:\n    |                    ^^^^^^^^^\n850 |                 base = self.repo_parent_root()\n851 |             self._publish_do_publish(\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:869:23\n    |\n867 |     # Step 5a: publish all packages (moved logic from freestanding publish_all)\n868 |     def publish_all(\n869 |         self, cloner: Any, ctx: OrchestratorContext | None\n    |                       ^^^\n870 |     ) -> tuple[dict[str, str | None], dict[str, dict[str, Any]]]:\n871 |         published_versions: dict[str, str | None] = {}\n    |\n\nTRY003 Avoid specifying long messages outside the exception class\n   --> x_cls_make_all_x.py:877:19\n    |\n875 |               self._check_test_pypi()\n876 |           except Exception as exc:\n877 |               raise AssertionError(\n    |  ___________________^\n878 | |                 f\"test.pypi.org connectivity/token check failed: {exc}\"\n879 | |             ) from exc\n    | |_____________^\n880 |           to_publish = getattr(MakeAllConfig, \"PUBLISH_MANIFEST\", [])\n881 |           for repo_name, version, anc_names, opts in to_publish:\n    |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n   --> x_cls_make_all_x.py:878:17\n    |\n876 |         except Exception as exc:\n877 |             raise AssertionError(\n878 |                 f\"test.pypi.org connectivity/token check failed: {exc}\"\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n879 |             ) from exc\n880 |         to_publish = getattr(MakeAllConfig, \"PUBLISH_MANIFEST\", [])\n    |\nhelp: Assign to variable; remove f-string literal\n\nN803 Argument name `PipUpdatesCls` should be lowercase\n   --> x_cls_make_all_x.py:907:15\n    |\n905 |     # Step 5b: run pip updates (moved logic from freestanding run_pip_updates)\n906 |     def _instantiate_pipupdates(\n907 |         self, PipUpdatesCls: Any, ctx: Any | None, use_user_flag: bool\n    |               ^^^^^^^^^^^^^^^^^^\n908 |     ) -> Any:\n909 |         try:\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `PipUpdatesCls`\n   --> x_cls_make_all_x.py:907:30\n    |\n905 |     # Step 5b: run pip updates (moved logic from freestanding run_pip_updates)\n906 |     def _instantiate_pipupdates(\n907 |         self, PipUpdatesCls: Any, ctx: Any | None, use_user_flag: bool\n    |                              ^^^\n908 |     ) -> Any:\n909 |         try:\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `ctx`\n   --> x_cls_make_all_x.py:907:40\n    |\n905 |     # Step 5b: run pip updates (moved logic from freestanding run_pip_updates)\n906 |     def _instantiate_pipupdates(\n907 |         self, PipUpdatesCls: Any, ctx: Any | None, use_user_flag: bool\n    |                                        ^^^^^^^^^^\n908 |     ) -> Any:\n909 |         try:\n    |\n\nFBT001 Boolean-typed positional argument in function definition\n   --> x_cls_make_all_x.py:907:52\n    |\n905 |     # Step 5b: run pip updates (moved logic from freestanding run_pip_updates)\n906 |     def _instantiate_pipupdates(\n907 |         self, PipUpdatesCls: Any, ctx: Any | None, use_user_flag: bool\n    |                                                    ^^^^^^^^^^^^^\n908 |     ) -> Any:\n909 |         try:\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `_instantiate_pipupdates`\n   --> x_cls_make_all_x.py:908:10\n    |\n906 |     def _instantiate_pipupdates(\n907 |         self, PipUpdatesCls: Any, ctx: Any | None, use_user_flag: bool\n908 |     ) -> Any:\n    |          ^^^\n909 |         try:\n910 |             return PipUpdatesCls(ctx)\n    |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n   --> x_cls_make_all_x.py:911:9\n    |\n909 |           try:\n910 |               return PipUpdatesCls(ctx)\n911 | /         except Exception:\n912 | |             pass\n    | |________________^\n913 |           attempt_kwargs: list[dict[str, Any]] = [\n914 |               {\"ctx\": ctx},\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:911:16\n    |\n909 |         try:\n910 |             return PipUpdatesCls(ctx)\n911 |         except Exception:\n    |                ^^^^^^^^^\n912 |             pass\n913 |         attempt_kwargs: list[dict[str, Any]] = [\n    |\n\nS112 `try`-`except`-`continue` detected, consider logging the exception\n   --> x_cls_make_all_x.py:922:13\n    |\n920 |               try:\n921 |                   return PipUpdatesCls(**kwargs)\n922 | /             except Exception:\n923 | |                 continue\n    | |________________________^\n924 |           return PipUpdatesCls()\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:922:20\n    |\n920 |             try:\n921 |                 return PipUpdatesCls(**kwargs)\n922 |             except Exception:\n    |                    ^^^^^^^^^\n923 |                 continue\n924 |         return PipUpdatesCls()\n    |\n\nC901 `_locate_and_choose_packages` is too complex (12 > 10)\n   --> x_cls_make_all_x.py:953:9\n    |\n951 |         return any_failures_local\n952 |\n953 |     def _locate_and_choose_packages(\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n954 |         self, cloner: Any, published_versions: dict[str, str | None]\n955 |     ) -> tuple[list[str], str, bool]:\n    |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n   --> x_cls_make_all_x.py:954:23\n    |\n953 |     def _locate_and_choose_packages(\n954 |         self, cloner: Any, published_versions: dict[str, str | None]\n    |                       ^^^\n955 |     ) -> tuple[list[str], str, bool]:\n956 |         try:\n    |\n\nARG002 Unused method argument: `published_versions`\n   --> x_cls_make_all_x.py:954:28\n    |\n953 |     def _locate_and_choose_packages(\n954 |         self, cloner: Any, published_versions: dict[str, str | None]\n    |                            ^^^^^^^^^^^^^^^^^^\n955 |     ) -> tuple[list[str], str, bool]:\n956 |         try:\n    |\n\nBLE001 Do not catch blind exception: `Exception`\n   --> x_cls_make_all_x.py:962:16\n    |\n960 |                 else self.repo_parent_root()\n961 |             )\n962 |         except Exception:\n    |                ^^^^^^^^^\n963 |             base = self.repo_parent_root()\n964 |         pip_updates_script = os.path.join(\n    |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:964:30\n    |\n962 |         except Exception:\n963 |             base = self.repo_parent_root()\n964 |         pip_updates_script = os.path.join(\n    |                              ^^^^^^^^^^^^\n965 |             base, \"x_4357_make_pip_updates_x\", \"x_cls_make_pip_updates_x.py\"\n966 |         )\n    |\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:967:16\n    |\n965 |             base, \"x_4357_make_pip_updates_x\", \"x_cls_make_pip_updates_x.py\"\n966 |         )\n967 |         if not os.path.exists(pip_updates_script):\n    |                ^^^^^^^^^^^^^^\n968 |             # Try alternative workspace naming without 4357 prefix\n969 |             alt_pkg = os.path.join(\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:969:23\n    |\n967 |         if not os.path.exists(pip_updates_script):\n968 |             # Try alternative workspace naming without 4357 prefix\n969 |             alt_pkg = os.path.join(\n    |                       ^^^^^^^^^^^^\n970 |                 base, \"x_make_pip_updates_x\", \"x_cls_make_pip_updates_x.py\"\n971 |             )\n    |\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:972:16\n    |\n970 |                 base, \"x_make_pip_updates_x\", \"x_cls_make_pip_updates_x.py\"\n971 |             )\n972 |             if os.path.exists(alt_pkg):\n    |                ^^^^^^^^^^^^^^\n973 |                 pip_updates_script = alt_pkg\n974 |         if not os.path.exists(pip_updates_script):\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:974:16\n    |\n972 |             if os.path.exists(alt_pkg):\n973 |                 pip_updates_script = alt_pkg\n974 |         if not os.path.exists(pip_updates_script):\n    |                ^^^^^^^^^^^^^^\n975 |             alt = os.path.join(\n976 |                 os.getcwd(),\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:975:19\n    |\n973 |                 pip_updates_script = alt_pkg\n974 |         if not os.path.exists(pip_updates_script):\n975 |             alt = os.path.join(\n    |                   ^^^^^^^^^^^^\n976 |                 os.getcwd(),\n977 |                 \"x_4357_make_pip_updates_x\",\n    |\n\nPTH109 `os.getcwd()` should be replaced by `Path.cwd()`\n   --> x_cls_make_all_x.py:976:17\n    |\n974 |         if not os.path.exists(pip_updates_script):\n975 |             alt = os.path.join(\n976 |                 os.getcwd(),\n    |                 ^^^^^^^^^\n977 |                 \"x_4357_make_pip_updates_x\",\n978 |                 \"x_cls_make_pip_updates_x.py\",\n    |\nhelp: Replace with `Path.cwd()`\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:980:16\n    |\n978 |                 \"x_cls_make_pip_updates_x.py\",\n979 |             )\n980 |             if os.path.exists(alt):\n    |                ^^^^^^^^^^^^^^\n981 |                 pip_updates_script = alt\n982 |         if not os.path.exists(pip_updates_script):\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:982:16\n    |\n980 |             if os.path.exists(alt):\n981 |                 pip_updates_script = alt\n982 |         if not os.path.exists(pip_updates_script):\n    |                ^^^^^^^^^^^^^^\n983 |             alt2 = os.path.join(\n984 |                 os.getcwd(),\n    |\nhelp: Replace with `Path(...).exists()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n   --> x_cls_make_all_x.py:983:20\n    |\n981 |                 pip_updates_script = alt\n982 |         if not os.path.exists(pip_updates_script):\n983 |             alt2 = os.path.join(\n    |                    ^^^^^^^^^^^^\n984 |                 os.getcwd(),\n985 |                 \"x_make_pip_updates_x\",\n    |\n\nPTH109 `os.getcwd()` should be replaced by `Path.cwd()`\n   --> x_cls_make_all_x.py:984:17\n    |\n982 |         if not os.path.exists(pip_updates_script):\n983 |             alt2 = os.path.join(\n984 |                 os.getcwd(),\n    |                 ^^^^^^^^^\n985 |                 \"x_make_pip_updates_x\",\n986 |                 \"x_cls_make_pip_updates_x.py\",\n    |\nhelp: Replace with `Path.cwd()`\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n   --> x_cls_make_all_x.py:988:16\n    |\n986 |                 \"x_cls_make_pip_updates_x.py\",\n987 |             )\n988 |             if os.path.exists(alt2):\n    |                ^^^^^^^^^^^^^^\n989 |                 pip_updates_script = alt2\n990 |         use_user_flag = False\n    |\nhelp: Replace with `Path(...).exists()`\n\nPLC0415 `import` should be at the top-level of a file\n    --> x_cls_make_all_x.py:1017:9\n     |\n1015 |         self, packages: list[str]\n1016 |     ) -> dict[str, str | None]:\n1017 |         import importlib.metadata\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n1018 |\n1019 |         initial_installed: dict[str, str | None] = {}\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1026:20\n     |\n1024 |                 initial_installed[pkg] = v\n1025 |                 _info(f\"{pkg}: {v}\")\n1026 |             except Exception as e:\n     |                    ^^^^^^^^^\n1027 |                 initial_installed[pkg] = None\n1028 |                 _info(f\"{pkg}: not installed ({e})\")\n     |\n\nFBT001 Boolean-typed positional argument in function definition\n    --> x_cls_make_all_x.py:1035:9\n     |\n1033 |         mismatches: list[tuple[str, str, str | None]],\n1034 |         pip_updates_script: str,\n1035 |         use_user_flag: bool,\n     |         ^^^^^^^^^^^^^\n1036 |         final_installed: dict[str, str | None],\n1037 |     ) -> int:\n     |\n\nS603 `subprocess` call: check for execution of untrusted input\n    --> x_cls_make_all_x.py:1045:22\n     |\n1043 |         )\n1044 |         _info(f\"Retrying install for pinned versions: {' '.join(retry_cmd)}\")\n1045 |         retry_proc = subprocess.run(\n     |                      ^^^^^^^^^^^^^^\n1046 |             retry_cmd, capture_output=True, text=True, check=False\n1047 |         )\n     |\n\nPLC0415 `import` should be at the top-level of a file\n    --> x_cls_make_all_x.py:1055:17\n     |\n1053 |             try:\n1054 |                 # import locally to avoid relying on a top-level import\n1055 |                 import importlib.metadata as _importlib_metadata\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1056 |\n1057 |                 final_installed[p] = _importlib_metadata.version(p)\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1058:20\n     |\n1057 |                 final_installed[p] = _importlib_metadata.version(p)\n1058 |             except Exception:\n     |                    ^^^^^^^^^\n1059 |                 final_installed[p] = None\n1060 |         return retry_proc.returncode\n     |\n\nFBT001 Boolean-typed positional argument in function definition\n    --> x_cls_make_all_x.py:1067:9\n     |\n1065 |         packages: list[str],\n1066 |         published_versions: dict[str, str | None],\n1067 |         use_user_flag: bool,\n     |         ^^^^^^^^^^^^^\n1068 |     ) -> None:\n1069 |         python = sys.executable\n     |\n\nS603 `subprocess` call: check for execution of untrusted input\n    --> x_cls_make_all_x.py:1087:24\n     |\n1085 |             _info(\"Fallback pip install:\", \" \".join(cmd))\n1086 |             try:\n1087 |                 proc = subprocess.run(\n     |                        ^^^^^^^^^^^^^^\n1088 |                     cmd, capture_output=True, text=True, check=False\n1089 |                 )\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1094:20\n     |\n1092 |                 if proc.stderr:\n1093 |                     _error(proc.stderr.strip())\n1094 |             except Exception as e:\n     |                    ^^^^^^^^^\n1095 |                 _error(f\"Fallback pip install failed: {e}\")\n     |\n\nC901 `run_pip_updates` is too complex (15 > 10)\n    --> x_cls_make_all_x.py:1097:9\n     |\n1095 |                 _error(f\"Fallback pip install failed: {e}\")\n1096 |\n1097 |     def run_pip_updates(\n     |         ^^^^^^^^^^^^^^^\n1098 |         self,\n1099 |         cloner: Any,\n     |\n\nPLR0912 Too many branches (15 > 12)\n    --> x_cls_make_all_x.py:1097:9\n     |\n1095 |                 _error(f\"Fallback pip install failed: {e}\")\n1096 |\n1097 |     def run_pip_updates(\n     |         ^^^^^^^^^^^^^^^\n1098 |         self,\n1099 |         cloner: Any,\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n    --> x_cls_make_all_x.py:1099:17\n     |\n1097 |     def run_pip_updates(\n1098 |         self,\n1099 |         cloner: Any,\n     |                 ^^^\n1100 |         published_versions: dict[str, str | None],\n1101 |         published_artifacts: dict[str, dict[str, Any]],\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `ctx`\n    --> x_cls_make_all_x.py:1102:14\n     |\n1100 |         published_versions: dict[str, str | None],\n1101 |         published_artifacts: dict[str, dict[str, Any]],\n1102 |         ctx: Any | None = None,\n     |              ^^^^^^^^^^\n1103 |     ) -> None:\n1104 |         packages, pip_updates_script, use_user_flag = (\n     |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n    --> x_cls_make_all_x.py:1112:9\n     |\n1110 |                       ctx.publish_opts.get(\"use_user\", use_user_flag)\n1111 |                   )\n1112 | /         except Exception:\n1113 | |             pass\n     | |________________^\n1114 |           if not packages:\n1115 |               _info(\"No published packages to update; skipping pip-updates step\")\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1112:16\n     |\n1110 |                     ctx.publish_opts.get(\"use_user\", use_user_flag)\n1111 |                 )\n1112 |         except Exception:\n     |                ^^^^^^^^^\n1113 |             pass\n1114 |         if not packages:\n     |\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n    --> x_cls_make_all_x.py:1118:36\n     |\n1116 |             return\n1117 |         script_exists = bool(\n1118 |             pip_updates_script and os.path.exists(pip_updates_script)\n     |                                    ^^^^^^^^^^^^^^\n1119 |         )\n1120 |         used_fallback = False\n     |\nhelp: Replace with `Path(...).exists()`\n\nE501 Line too long (97 > 88)\n    --> x_cls_make_all_x.py:1129:89\n     |\n1127 |                 if rc != 0:\n1128 |                     _error(\n1129 |                         f\"pip-updates reported exit code {rc}; switching to fallback pip install\"\n     |                                                                                         ^^^^^^^^^\n1130 |                     )\n1131 |                     used_fallback = True\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1132:20\n     |\n1130 |                     )\n1131 |                     used_fallback = True\n1132 |             except Exception as e:\n     |                    ^^^^^^^^^\n1133 |                 _error(\n1134 |                     f\"pip-updates invocation failed: {e}; switching to fallback pip install\"\n     |\n\nE501 Line too long (92 > 88)\n    --> x_cls_make_all_x.py:1134:89\n     |\n1132 |             except Exception as e:\n1133 |                 _error(\n1134 |                     f\"pip-updates invocation failed: {e}; switching to fallback pip install\"\n     |                                                                                         ^^^^\n1135 |                 )\n1136 |                 used_fallback = True\n     |\n\nE501 Line too long (102 > 88)\n    --> x_cls_make_all_x.py:1181:89\n     |\n1179 |             if mismatches:\n1180 |                 _error(\n1181 |                     f\"Post-install verification detected {mismatches} mismatches, exiting with code 2\"\n     |                                                                                         ^^^^^^^^^^^^^^\n1182 |                 )\n1183 |                 sys.exit(2)\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1184:16\n     |\n1182 |                 )\n1183 |                 sys.exit(2)\n1184 |         except Exception as e:\n     |                ^^^^^^^^^\n1185 |             _error(f\"Post-install verification failed: {e}\")\n     |\n\nARG002 Unused method argument: `pkg_dir`\n    --> x_cls_make_all_x.py:1190:9\n     |\n1188 |         self,\n1189 |         pkg: str,\n1190 |         pkg_dir: str,\n     |         ^^^^^^^\n1191 |         repo_pkg_dir: str,\n1192 |         installed_main: str,\n     |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1197:20\n     |\n1195 |         \"\"\"Compare installed main file with repo copy.\"\"\"\n1196 |         try:\n1197 |             if not os.path.isfile(installed_main):\n     |                    ^^^^^^^^^^^^^^\n1198 |                 _error(\n1199 |                     f\"Installed main file not found for {pkg}: {installed_main}\"\n     |\nhelp: Replace with `Path(...).is_file()`\n\nE501 Line too long (89 > 88)\n    --> x_cls_make_all_x.py:1202:89\n     |\n1200 |                 )\n1201 |                 return 1\n1202 |             # Prefer explicit repo_main (from manifest), else fall back to basename match\n     |                                                                                         ^\n1203 |             if repo_main is None:\n1204 |                 main_name = os.path.basename(installed_main)\n     |\n\nPTH119 `os.path.basename()` should be replaced by `Path.name`\n    --> x_cls_make_all_x.py:1204:29\n     |\n1202 |             # Prefer explicit repo_main (from manifest), else fall back to basename match\n1203 |             if repo_main is None:\n1204 |                 main_name = os.path.basename(installed_main)\n     |                             ^^^^^^^^^^^^^^^^\n1205 |                 repo_main_candidate = os.path.join(repo_pkg_dir, main_name)\n1206 |             else:\n     |\nhelp: Replace with `Path(...).name`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1205:39\n     |\n1203 |             if repo_main is None:\n1204 |                 main_name = os.path.basename(installed_main)\n1205 |                 repo_main_candidate = os.path.join(repo_pkg_dir, main_name)\n     |                                       ^^^^^^^^^^^^\n1206 |             else:\n1207 |                 repo_main_candidate = repo_main\n     |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1208:20\n     |\n1206 |             else:\n1207 |                 repo_main_candidate = repo_main\n1208 |             if not os.path.isfile(repo_main_candidate):\n     |                    ^^^^^^^^^^^^^^\n1209 |                 _error(\n1210 |                     f\"Repo main file not found for {pkg}: {repo_main_candidate} (dir={repo_pkg_dir})\"\n     |\nhelp: Replace with `Path(...).is_file()`\n\nE501 Line too long (101 > 88)\n    --> x_cls_make_all_x.py:1210:89\n     |\n1208 |             if not os.path.isfile(repo_main_candidate):\n1209 |                 _error(\n1210 |                     f\"Repo main file not found for {pkg}: {repo_main_candidate} (dir={repo_pkg_dir})\"\n     |                                                                                         ^^^^^^^^^^^^^\n1211 |                 )\n1212 |                 return 1\n     |\n\nPTH123 `open()` should be replaced by `Path.open()`\n    --> x_cls_make_all_x.py:1213:18\n     |\n1211 |                 )\n1212 |                 return 1\n1213 |             with open(installed_main, \"rb\") as f1, open(\n     |                  ^^^^\n1214 |                 repo_main_candidate, \"rb\"\n1215 |             ) as f2:\n     |\nhelp: Replace with `Path.open()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n    --> x_cls_make_all_x.py:1213:52\n     |\n1211 |                 )\n1212 |                 return 1\n1213 |             with open(installed_main, \"rb\") as f1, open(\n     |                                                    ^^^^\n1214 |                 repo_main_candidate, \"rb\"\n1215 |             ) as f2:\n     |\nhelp: Replace with `Path.open()`\n\nE501 Line too long (118 > 88)\n    --> x_cls_make_all_x.py:1218:89\n     |\n1216 |                 if f1.read() != f2.read():\n1217 |                     _error(\n1218 |                         f\"Main file content mismatch for {pkg}: installed={installed_main} repo={repo_main_candidate}\"\n     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1219 |                     )\n1220 |                     return 1\n     |\n\nPTH119 `os.path.basename()` should be replaced by `Path.name`\n    --> x_cls_make_all_x.py:1222:44\n     |\n1220 |                     return 1\n1221 |             _info(\n1222 |                 f\"Main file OK for {pkg}: {os.path.basename(installed_main)}\"\n     |                                            ^^^^^^^^^^^^^^^^\n1223 |             )\n1224 |             return 0\n     |\nhelp: Replace with `Path(...).name`\n\nTRY300 Consider moving this statement to an `else` block\n    --> x_cls_make_all_x.py:1224:13\n     |\n1222 |                 f\"Main file OK for {pkg}: {os.path.basename(installed_main)}\"\n1223 |             )\n1224 |             return 0\n     |             ^^^^^^^^\n1225 |         except Exception as e:\n1226 |             _error(f\"Error comparing main file for {pkg}: {e}\")\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1225:16\n     |\n1223 |             )\n1224 |             return 0\n1225 |         except Exception as e:\n     |                ^^^^^^^^^\n1226 |             _error(f\"Error comparing main file for {pkg}: {e}\")\n1227 |             return 1\n     |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1238:20\n     |\n1236 |     ) -> int:\n1237 |         try:\n1238 |             if not os.path.isfile(installed_path):\n     |                    ^^^^^^^^^^^^^^\n1239 |                 _error(f\"Installed ancillary file not found: {installed_path}\")\n1240 |                 return 1\n     |\nhelp: Replace with `Path(...).is_file()`\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1241:20\n     |\n1239 |                 _error(f\"Installed ancillary file not found: {installed_path}\")\n1240 |                 return 1\n1241 |             if not os.path.isfile(repo_path):\n     |                    ^^^^^^^^^^^^^^\n1242 |                 _error(f\"Repo ancillary file not found: {repo_path}\")\n1243 |                 return 1\n     |\nhelp: Replace with `Path(...).is_file()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n    --> x_cls_make_all_x.py:1244:18\n     |\n1242 |                 _error(f\"Repo ancillary file not found: {repo_path}\")\n1243 |                 return 1\n1244 |             with open(installed_path, \"rb\") as f_inst, open(\n     |                  ^^^^\n1245 |                 repo_path, \"rb\"\n1246 |             ) as f_repo:\n     |\nhelp: Replace with `Path.open()`\n\nPTH123 `open()` should be replaced by `Path.open()`\n    --> x_cls_make_all_x.py:1244:56\n     |\n1242 |                 _error(f\"Repo ancillary file not found: {repo_path}\")\n1243 |                 return 1\n1244 |             with open(installed_path, \"rb\") as f_inst, open(\n     |                                                        ^^^^\n1245 |                 repo_path, \"rb\"\n1246 |             ) as f_repo:\n     |\nhelp: Replace with `Path.open()`\n\nTRY300 Consider moving this statement to an `else` block\n    --> x_cls_make_all_x.py:1253:13\n     |\n1251 |                     return 1\n1252 |             _info(f\"Ancillary file OK for {pkg}: {anc_name}\")\n1253 |             return 0\n     |             ^^^^^^^^\n1254 |         except Exception as e:\n1255 |             _error(\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1254:16\n     |\n1252 |             _info(f\"Ancillary file OK for {pkg}: {anc_name}\")\n1253 |             return 0\n1254 |         except Exception as e:\n     |                ^^^^^^^^^\n1255 |             _error(\n1256 |                 f\"Error comparing ancillary file for {pkg}: {anc_name}: {e}\"\n     |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1270:20\n     |\n1268 |         mismatches = 0\n1269 |         try:\n1270 |             if not os.path.isdir(installed_dir):\n     |                    ^^^^^^^^^^^^^\n1271 |                 _error(\n1272 |                     f\"Installed ancillary directory not found: {installed_dir}\"\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1275:20\n     |\n1273 |                 )\n1274 |                 return 1\n1275 |             if not os.path.isdir(repo_dir):\n     |                    ^^^^^^^^^^^^^\n1276 |                 _error(f\"Repo ancillary directory not found: {repo_dir}\")\n1277 |                 return 1\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH208 Use `pathlib.Path.iterdir()` instead.\n    --> x_cls_make_all_x.py:1281:27\n     |\n1279 |             def _top_files(d: str) -> set[str]:\n1280 |                 out: set[str] = set()\n1281 |                 for fn in os.listdir(d):\n     |                           ^^^^^^^^^^\n1282 |                     fp = os.path.join(d, fn)\n1283 |                     if os.path.isfile(fp):\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1282:26\n     |\n1280 |                 out: set[str] = set()\n1281 |                 for fn in os.listdir(d):\n1282 |                     fp = os.path.join(d, fn)\n     |                          ^^^^^^^^^^^^\n1283 |                     if os.path.isfile(fp):\n1284 |                         out.add(fn)\n     |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1283:24\n     |\n1281 |                 for fn in os.listdir(d):\n1282 |                     fp = os.path.join(d, fn)\n1283 |                     if os.path.isfile(fp):\n     |                        ^^^^^^^^^^^^^^\n1284 |                         out.add(fn)\n1285 |                 return out\n     |\nhelp: Replace with `Path(...).is_file()`\n\nE501 Line too long (103 > 88)\n    --> x_cls_make_all_x.py:1292:89\n     |\n1290 |             for rel in sorted(repo_files - inst_files):\n1291 |                 _error(\n1292 |                     f\"Ancillary directory content missing in installed package {pkg}: {anc_name}/{rel}\"\n     |                                                                                         ^^^^^^^^^^^^^^^\n1293 |                 )\n1294 |                 mismatches += 1\n     |\n\nE501 Line too long (102 > 88)\n    --> x_cls_make_all_x.py:1297:89\n     |\n1295 |             for rel in sorted(inst_files - repo_files):\n1296 |                 _error(\n1297 |                     f\"Ancillary directory has extra file in installed package {pkg}: {anc_name}/{rel}\"\n     |                                                                                         ^^^^^^^^^^^^^^\n1298 |                 )\n1299 |                 mismatches += 1\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1301:29\n     |\n1299 |                 mismatches += 1\n1300 |             for rel in sorted(repo_files & inst_files):\n1301 |                 inst_path = os.path.join(installed_dir, rel)\n     |                             ^^^^^^^^^^^^\n1302 |                 repo_path = os.path.join(repo_dir, rel)\n1303 |                 mismatches += self._compare_ancillary_file(\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1302:29\n     |\n1300 |             for rel in sorted(repo_files & inst_files):\n1301 |                 inst_path = os.path.join(installed_dir, rel)\n1302 |                 repo_path = os.path.join(repo_dir, rel)\n     |                             ^^^^^^^^^^^^\n1303 |                 mismatches += self._compare_ancillary_file(\n1304 |                     inst_path, repo_path, pkg, f\"{anc_name}/{rel}\"\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1306:16\n     |\n1304 |                     inst_path, repo_path, pkg, f\"{anc_name}/{rel}\"\n1305 |                 )\n1306 |         except Exception as e:\n     |                ^^^^^^^^^\n1307 |             _error(\n1308 |                 f\"Error comparing ancillary directory for {pkg}: {anc_name}: {e}\"\n     |\n\nE501 Line too long (98 > 88)\n    --> x_cls_make_all_x.py:1320:89\n     |\n1318 |         expected_anc: list[str],\n1319 |     ) -> int:\n1320 |         \"\"\"Compare ancillary files/directories listed in expected_anc using helper comparators.\"\"\"\n     |                                                                                         ^^^^^^^^^^\n1321 |         mismatches = 0\n1322 |         # Deduplicate expected list to avoid duplicate logs\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1325:16\n     |\n1323 |         try:\n1324 |             expected = list(dict.fromkeys(expected_anc))\n1325 |         except Exception:\n     |                ^^^^^^^^^\n1326 |             expected = expected_anc\n1327 |         for anc_name in expected:\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1330:25\n     |\n1328 |             # Normalize expected path to OS-specific separators for fs access\n1329 |             anc_os_rel = os.path.normpath(anc_name.replace(\"\\\\\", \"/\"))\n1330 |             repo_path = os.path.join(repo_pkg_dir, anc_os_rel)\n     |                         ^^^^^^^^^^^^\n1331 |             target_is_dir = os.path.isdir(repo_path)\n1332 |             # Installed paths are recorded as relative to the package dir\n     |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1331:29\n     |\n1329 |             anc_os_rel = os.path.normpath(anc_name.replace(\"\\\\\", \"/\"))\n1330 |             repo_path = os.path.join(repo_pkg_dir, anc_os_rel)\n1331 |             target_is_dir = os.path.isdir(repo_path)\n     |                             ^^^^^^^^^^^^^\n1332 |             # Installed paths are recorded as relative to the package dir\n1333 |             installed_path = os.path.join(pkg_dir, anc_os_rel)\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1333:30\n     |\n1331 |             target_is_dir = os.path.isdir(repo_path)\n1332 |             # Installed paths are recorded as relative to the package dir\n1333 |             installed_path = os.path.join(pkg_dir, anc_os_rel)\n     |                              ^^^^^^^^^^^^\n1334 |             if not os.path.exists(repo_path):\n1335 |                 _error(f\"Ancillary missing from repo for {pkg}: {anc_name}\")\n     |\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n    --> x_cls_make_all_x.py:1334:20\n     |\n1332 |             # Installed paths are recorded as relative to the package dir\n1333 |             installed_path = os.path.join(pkg_dir, anc_os_rel)\n1334 |             if not os.path.exists(repo_path):\n     |                    ^^^^^^^^^^^^^^\n1335 |                 _error(f\"Ancillary missing from repo for {pkg}: {anc_name}\")\n1336 |                 mismatches += 1\n     |\nhelp: Replace with `Path(...).exists()`\n\nPTH110 `os.path.exists()` should be replaced by `Path.exists()`\n    --> x_cls_make_all_x.py:1338:20\n     |\n1336 |                 mismatches += 1\n1337 |                 continue\n1338 |             if not os.path.exists(installed_path):\n     |                    ^^^^^^^^^^^^^^\n1339 |                 _error(\n1340 |                     f\"Ancillary missing from installed package for {pkg}: {anc_name}\"\n     |\nhelp: Replace with `Path(...).exists()`\n\nC901 `_find_installed_path` is too complex (12 > 10)\n    --> x_cls_make_all_x.py:1354:9\n     |\n1352 |         return mismatches\n1353 |\n1354 |     def _find_installed_path(\n     |         ^^^^^^^^^^^^^^^^^^^^\n1355 |         self, rel_path: str, target_is_dir: bool\n1356 |     ) -> str | None:\n     |\n\nFBT001 Boolean-typed positional argument in function definition\n    --> x_cls_make_all_x.py:1355:30\n     |\n1354 |     def _find_installed_path(\n1355 |         self, rel_path: str, target_is_dir: bool\n     |                              ^^^^^^^^^^^^^\n1356 |     ) -> str | None:\n1357 |         import site\n     |\n\nPLC0415 `import` should be at the top-level of a file\n    --> x_cls_make_all_x.py:1357:9\n     |\n1355 |         self, rel_path: str, target_is_dir: bool\n1356 |     ) -> str | None:\n1357 |         import site\n     |         ^^^^^^^^^^^\n1358 |\n1359 |         for base in site.getsitepackages():\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1360:25\n     |\n1359 |         for base in site.getsitepackages():\n1360 |             candidate = os.path.join(base, rel_path)\n     |                         ^^^^^^^^^^^^\n1361 |             if target_is_dir and os.path.isdir(candidate):\n1362 |                 return candidate\n     |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1361:34\n     |\n1359 |         for base in site.getsitepackages():\n1360 |             candidate = os.path.join(base, rel_path)\n1361 |             if target_is_dir and os.path.isdir(candidate):\n     |                                  ^^^^^^^^^^^^^\n1362 |                 return candidate\n1363 |             if not target_is_dir and os.path.isfile(candidate):\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1363:38\n     |\n1361 |             if target_is_dir and os.path.isdir(candidate):\n1362 |                 return candidate\n1363 |             if not target_is_dir and os.path.isfile(candidate):\n     |                                      ^^^^^^^^^^^^^^\n1364 |                 return candidate\n1365 |         try:\n     |\nhelp: Replace with `Path(...).is_file()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1371:33\n     |\n1369 |                     if target_is_dir:\n1370 |                         for d in dirs:\n1371 |                             p = os.path.join(root, d)\n     |                                 ^^^^^^^^^^^^\n1372 |                             if os.path.normcase(p).endswith(\n1373 |                                 norm_tail\n     |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1374:35\n     |\n1372 |                             if os.path.normcase(p).endswith(\n1373 |                                 norm_tail\n1374 |                             ) and os.path.isdir(p):\n     |                                   ^^^^^^^^^^^^^\n1375 |                                 return p\n1376 |                     else:\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1378:33\n     |\n1376 |                     else:\n1377 |                         for f in files:\n1378 |                             p = os.path.join(root, f)\n     |                                 ^^^^^^^^^^^^\n1379 |                             if os.path.normcase(p).endswith(\n1380 |                                 norm_tail\n     |\n\nPTH113 `os.path.isfile()` should be replaced by `Path.is_file()`\n    --> x_cls_make_all_x.py:1381:35\n     |\n1379 |                             if os.path.normcase(p).endswith(\n1380 |                                 norm_tail\n1381 |                             ) and os.path.isfile(p):\n     |                                   ^^^^^^^^^^^^^^\n1382 |                                 return p\n1383 |         except Exception:\n     |\nhelp: Replace with `Path(...).is_file()`\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n    --> x_cls_make_all_x.py:1383:9\n     |\n1381 |                               ) and os.path.isfile(p):\n1382 |                                   return p\n1383 | /         except Exception:\n1384 | |             pass\n     | |________________^\n1385 |           return None\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1383:16\n     |\n1381 |                             ) and os.path.isfile(p):\n1382 |                                 return p\n1383 |         except Exception:\n     |                ^^^^^^^^^\n1384 |             pass\n1385 |         return None\n     |\n\nPLC0415 `import` should be at the top-level of a file\n    --> x_cls_make_all_x.py:1388:9\n     |\n1387 |     def _locate_installed_pkg_dir(self, pkg_name: str) -> str:\n1388 |         import importlib.util as _ilu\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1389 |\n1390 |         spec = _ilu.find_spec(pkg_name)\n     |\n\nPTH120 `os.path.dirname()` should be replaced by `Path.parent`\n    --> x_cls_make_all_x.py:1397:24\n     |\n1395 |                 return locs[0]\n1396 |             if spec.origin:\n1397 |                 return os.path.dirname(spec.origin)\n     |                        ^^^^^^^^^^^^^^^\n1398 |         path = self._find_installed_path(pkg_name, True)\n1399 |         if not path:\n     |\nhelp: Replace with `Path(...).parent`\n\nFBT003 Boolean positional value in function call\n    --> x_cls_make_all_x.py:1398:52\n     |\n1396 |             if spec.origin:\n1397 |                 return os.path.dirname(spec.origin)\n1398 |         path = self._find_installed_path(pkg_name, True)\n     |                                                    ^^^^\n1399 |         if not path:\n1400 |             raise FileNotFoundError(\n     |\n\nTRY003 Avoid specifying long messages outside the exception class\n    --> x_cls_make_all_x.py:1400:19\n     |\n1398 |           path = self._find_installed_path(pkg_name, True)\n1399 |           if not path:\n1400 |               raise FileNotFoundError(\n     |  ___________________^\n1401 | |                 f\"Package directory not found for {pkg_name}\"\n1402 | |             )\n     | |_____________^\n1403 |           return path\n     |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n    --> x_cls_make_all_x.py:1401:17\n     |\n1399 |         if not path:\n1400 |             raise FileNotFoundError(\n1401 |                 f\"Package directory not found for {pkg_name}\"\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1402 |             )\n1403 |         return path\n     |\nhelp: Assign to variable; remove f-string literal\n\nPTH208 Use `pathlib.Path.iterdir()` instead.\n    --> x_cls_make_all_x.py:1410:23\n     |\n1408 |         main_path = \"\"\n1409 |         try:\n1410 |             for fn in os.listdir(pkg_dir):\n     |                       ^^^^^^^^^^\n1411 |                 if fn.startswith(\"x_cls_make_\") and fn.endswith(\".py\"):\n1412 |                     main_path = os.path.join(pkg_dir, fn)\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1412:33\n     |\n1410 |             for fn in os.listdir(pkg_dir):\n1411 |                 if fn.startswith(\"x_cls_make_\") and fn.endswith(\".py\"):\n1412 |                     main_path = os.path.join(pkg_dir, fn)\n     |                                 ^^^^^^^^^^^^\n1413 |                     break\n1414 |         except Exception:\n     |\n\nS110 `try`-`except`-`pass` detected, consider logging the exception\n    --> x_cls_make_all_x.py:1414:9\n     |\n1412 |                       main_path = os.path.join(pkg_dir, fn)\n1413 |                       break\n1414 | /         except Exception:\n1415 | |             pass\n     | |________________^\n1416 |           if not main_path:\n1417 |               raise FileNotFoundError(\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1414:16\n     |\n1412 |                     main_path = os.path.join(pkg_dir, fn)\n1413 |                     break\n1414 |         except Exception:\n     |                ^^^^^^^^^\n1415 |             pass\n1416 |         if not main_path:\n     |\n\nTRY003 Avoid specifying long messages outside the exception class\n    --> x_cls_make_all_x.py:1417:19\n     |\n1415 |               pass\n1416 |           if not main_path:\n1417 |               raise FileNotFoundError(\n     |  ___________________^\n1418 | |                 f\"Conventional main file x_cls_make_*.py not found in package dir {pkg_dir}\"\n1419 | |             )\n     | |_____________^\n1420 |           return main_path, []\n     |\n\nEM102 Exception must not use an f-string literal, assign to variable first\n    --> x_cls_make_all_x.py:1418:17\n     |\n1416 |         if not main_path:\n1417 |             raise FileNotFoundError(\n1418 |                 f\"Conventional main file x_cls_make_*.py not found in package dir {pkg_dir}\"\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1419 |             )\n1420 |         return main_path, []\n     |\nhelp: Assign to variable; remove f-string literal\n\nE501 Line too long (92 > 88)\n    --> x_cls_make_all_x.py:1418:89\n     |\n1416 |         if not main_path:\n1417 |             raise FileNotFoundError(\n1418 |                 f\"Conventional main file x_cls_make_*.py not found in package dir {pkg_dir}\"\n     |                                                                                         ^^^^\n1419 |             )\n1420 |         return main_path, []\n     |\n\nC901 `_compare_installed_with_repo` is too complex (13 > 10)\n    --> x_cls_make_all_x.py:1431:9\n     |\n1429 |         return m.get(dist_name)\n1430 |\n1431 |     def _compare_installed_with_repo(\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1432 |         self,\n1433 |         cloner: Any,\n     |\n\nPLR0912 Too many branches (16 > 12)\n    --> x_cls_make_all_x.py:1431:9\n     |\n1429 |         return m.get(dist_name)\n1430 |\n1431 |     def _compare_installed_with_repo(\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1432 |         self,\n1433 |         cloner: Any,\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n    --> x_cls_make_all_x.py:1433:17\n     |\n1431 |     def _compare_installed_with_repo(\n1432 |         self,\n1433 |         cloner: Any,\n     |                 ^^^\n1434 |         packages: list[str],\n1435 |         published_artifacts: dict[str, dict[str, Any]],\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1443:16\n     |\n1441 |                 else self.repo_parent_root()\n1442 |             )\n1443 |         except Exception:\n     |                ^^^^^^^^^\n1444 |             base = self.repo_parent_root()\n1445 |         _info(\n     |\n\nE501 Line too long (89 > 88)\n    --> x_cls_make_all_x.py:1446:89\n     |\n1444 |             base = self.repo_parent_root()\n1445 |         _info(\n1446 |             f\"Starting post-install file verification for packages: {','.join(packages)}\"\n     |                                                                                         ^\n1447 |         )\n1448 |         total_mismatches = 0\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1451:30\n     |\n1449 |         for pkg in packages:\n1450 |             repo_dir_name = pkg\n1451 |             repo_candidate = os.path.join(base, repo_dir_name)\n     |                              ^^^^^^^^^^^^\n1452 |             if not os.path.isdir(repo_candidate):\n1453 |                 mapped = self._dist_to_repo(pkg)\n     |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1452:20\n     |\n1450 |             repo_dir_name = pkg\n1451 |             repo_candidate = os.path.join(base, repo_dir_name)\n1452 |             if not os.path.isdir(repo_candidate):\n     |                    ^^^^^^^^^^^^^\n1453 |                 mapped = self._dist_to_repo(pkg)\n1454 |                 if mapped:\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1456:28\n     |\n1454 |                 if mapped:\n1455 |                     repo_dir_name = mapped\n1456 |             repo_pkg_dir = os.path.join(base, repo_dir_name)\n     |                            ^^^^^^^^^^^^\n1457 |\n1458 |             # locate installed dir\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1461:20\n     |\n1459 |             try:\n1460 |                 pkg_dir = self._locate_installed_pkg_dir(pkg)\n1461 |             except Exception as e:\n     |                    ^^^^^^^^^\n1462 |                 _error(\n1463 |                     f\"Skipping comparison for {pkg}: cannot locate installed package: {e}\"\n     |\n\nE501 Line too long (90 > 88)\n    --> x_cls_make_all_x.py:1463:89\n     |\n1461 |             except Exception as e:\n1462 |                 _error(\n1463 |                     f\"Skipping comparison for {pkg}: cannot locate installed package: {e}\"\n     |                                                                                         ^^\n1464 |                 )\n1465 |                 continue\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1478:38\n     |\n1476 |                 if art and isinstance(art.get(\"main\"), str):\n1477 |                     main_rel = cast(\"str\", art[\"main\"])\n1478 |                     installed_main = os.path.join(pkg_dir, main_rel)\n     |                                      ^^^^^^^^^^^^\n1479 |                     repo_main_path = os.path.join(repo_pkg_dir, main_rel)\n1480 |                 else:\n     |\n\nPTH118 `os.path.join()` should be replaced by `Path` with `/` operator\n    --> x_cls_make_all_x.py:1479:38\n     |\n1477 |                     main_rel = cast(\"str\", art[\"main\"])\n1478 |                     installed_main = os.path.join(pkg_dir, main_rel)\n1479 |                     repo_main_path = os.path.join(repo_pkg_dir, main_rel)\n     |                                      ^^^^^^^^^^^^\n1480 |                 else:\n1481 |                     installed_main, _ = self._find_main_and_ancillaries_in_dir(\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1484:20\n     |\n1482 |                         pkg_dir\n1483 |                     )\n1484 |             except Exception as e:\n     |                    ^^^^^^^^^\n1485 |                 _error(f\"Skipping {pkg}: error determining main file: {e}\")\n1486 |                 continue\n     |\n\nPTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`\n    --> x_cls_make_all_x.py:1488:20\n     |\n1486 |                 continue\n1487 |\n1488 |             if not os.path.isdir(repo_pkg_dir):\n     |                    ^^^^^^^^^^^^^\n1489 |                 _error(\n1490 |                     f\"Repo copy for dist {pkg} not found (expected repo dir {repo_pkg_dir}); skipping file comparisons\"\n     |\nhelp: Replace with `Path(...).is_dir()`\n\nE501 Line too long (119 > 88)\n    --> x_cls_make_all_x.py:1490:89\n     |\n1488 |             if not os.path.isdir(repo_pkg_dir):\n1489 |                 _error(\n1490 |                     f\"Repo copy for dist {pkg} not found (expected repo dir {repo_pkg_dir}); skipping file comparisons\"\n     |                                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n1491 |                 )\n1492 |                 continue\n     |\n\nE501 Line too long (89 > 88)\n    --> x_cls_make_all_x.py:1518:89\n     |\n1516 |         if total_mismatches:\n1517 |             _error(\n1518 |                 f\"Post-install verification completed with {total_mismatches} mismatches\"\n     |                                                                                         ^\n1519 |             )\n1520 |         else:\n     |\n\nE501 Line too long (95 > 88)\n    --> x_cls_make_all_x.py:1522:89\n     |\n1520 |         else:\n1521 |             _info(\n1522 |                 \"Post-install verification completed: all checked files match the cloned repos\"\n     |                                                                                         ^^^^^^^\n1523 |             )\n1524 |         return total_mismatches\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `clone_repos`\n    --> x_cls_make_all_x.py:1538:60\n     |\n1538 | def clone_repos(ctx: OrchestratorContext | None = None) -> Any:\n     |                                                            ^^^\n1539 |     return _orchestrator().clone_repos(ctx)\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n    --> x_cls_make_all_x.py:1543:13\n     |\n1542 | def publish_all(\n1543 |     cloner: Any, ctx: OrchestratorContext | None = None\n     |             ^^^\n1544 | ) -> tuple[dict[str, str | None], dict[str, dict[str, Any]]]:\n1545 |     return _orchestrator().publish_all(cloner, ctx)\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n    --> x_cls_make_all_x.py:1549:13\n     |\n1548 | def run_pip_updates(\n1549 |     cloner: Any,\n     |             ^^^\n1550 |     published_versions: dict[str, str | None],\n1551 |     published_artifacts: dict[str, dict[str, Any]],\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `ctx`\n    --> x_cls_make_all_x.py:1552:10\n     |\n1550 |     published_versions: dict[str, str | None],\n1551 |     published_artifacts: dict[str, dict[str, Any]],\n1552 |     ctx: Any | None = None,\n     |          ^^^^^^^^^^\n1553 | ) -> None:\n1554 |     _orchestrator().run_pip_updates(\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n    --> x_cls_make_all_x.py:1563:26\n     |\n1563 | def _run_visitor(cloner: Any, ctx: OrchestratorContext | None) -> None:\n     |                          ^^^\n1564 |     return _orchestrator().run_visitor(cloner, ctx)\n     |\n\nANN401 Dynamically typed expressions (typing.Any) are disallowed in `cloner`\n    --> x_cls_make_all_x.py:1568:13\n     |\n1567 | def _process_publishes_and_updates(\n1568 |     cloner: Any, ctx: OrchestratorContext | None\n     |             ^^^\n1569 | ) -> None:\n1570 |     return _orchestrator().process_publishes_and_updates(cloner, ctx)\n     |\n\nBLE001 Do not catch blind exception: `Exception`\n    --> x_cls_make_all_x.py:1582:12\n     |\n1580 |     try:\n1581 |         main()\n1582 |     except Exception as e:\n     |            ^^^^^^^^^\n1583 |         _error(f\"Error: {e}\")\n1584 |         sys.exit(1)\n     |\n\nFound 350 errors.\nNo fixes available (29 hidden fixes can be enabled with the `--unsafe-fixes` option).\n"
}